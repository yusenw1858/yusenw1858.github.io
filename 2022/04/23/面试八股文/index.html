<!DOCTYPE html><html><head><meta charset=UTF-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=0"><title>C++面试八股文 | 森森成长日记</title><meta name=author content=森森><meta name=copyright content=森森><link rel="shortcut icon" href=http://example.com/img/favicon.png><meta name=description content="面向对象多态分类及实现 静态多态：函数重载，运算符重载，函数模版（函数模版的代码会经过两次编译，第一次在申明的位置编译函数代码本身，仅生成函数头，第二次在调用的地方对参数替换后的代码进行编译，实际上就是编译器替我们写对应数据类型的函数）  &#x2F;&#x2F;函数重载    void fun(int a)&amp;#123;  &#x2F;&#x2F;参数类型不同        cout&lt;&lt;&quot;this is int&amp;q"><meta property=og:type content=article><meta property=og:title content=C++面试八股文><meta property=og:url content=http://example.com/2022/04/23/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1%E6%96%87/ ><meta property=og:site_name content=森森成长日记><meta property=og:description content="面向对象多态分类及实现 静态多态：函数重载，运算符重载，函数模版（函数模版的代码会经过两次编译，第一次在申明的位置编译函数代码本身，仅生成函数头，第二次在调用的地方对参数替换后的代码进行编译，实际上就是编译器替我们写对应数据类型的函数）  &#x2F;&#x2F;函数重载    void fun(int a)&amp;#123;  &#x2F;&#x2F;参数类型不同        cout&lt;&lt;&quot;this is int&amp;q"><meta property=og:locale content=zh_CN><meta property=og:image content=http://example.com/img/logo.gif><meta property=article:published_time content=2022-04-23T11:08:41.079Z><meta property=article:modified_time content=2022-04-24T09:20:17.404Z><meta property=article:author content=森森><meta name=twitter:card content=summary><meta name=twitter:image content=http://example.com/img/logo.gif><meta http-equiv=Cache-Control content=no-siteapp><link href=https://cdn.jsdelivr.net rel=preconnect><link href=http://example.com rel=prefetch><link href=https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css rel=stylesheet><link href=/css/main.css rel=stylesheet><script src=/js/utlis.js></script><script>!function(){var t=$query("html");"true"===localStorage.isDark?t.setAttribute("theme","dark"):t.removeAttribute("theme")}()</script><meta name=generator content="Hexo 6.1.0"></head><body><script>var $config={CDN:{fancyboxJs:"https://cdn.jsdelivr.net/npm/@fancyapps/ui@4.0.26/dist/fancybox.umd.js",fancyboxCss:"https://cdn.jsdelivr.net/npm/@fancyapps/ui@4.0.26/dist/fancybox.css"},codeBlockExpand:{enable:!0,height:400,scrollTop:200}}</script><div id=body-wrap><nav id=nav-wrap><div class=navbar><div class=bar><a href=/ class=title>森森成长日记</a><ul class=menu></ul><i class="fas fa-bars open-nav"></i></div></div><div id=mobile-nav><ul></ul></div></nav><header id=header><div class=header-author><a href=/ class=author><img src=/img/logo.gif alt=森森 class=author-avatar><div class=author-name>森森</div></a></div><div class=header-description><p></p><div class=header-icon></div></div></header><main id=main><article id=post><div class=post-info><div class=post-title><h1>C++面试八股文</h1></div><div class=post-meta><div class=post-date><i class="far fa-calendar-alt fa-fw post-meta-icon"></i> <span class=post-meta-label>发表于 2022-04-23 | </span><i class="fas fa-history fa-fw post-meta-icon"></i> <span class=post-meta-label>更新于 2022-04-24</span></div><div class=post-meta-wordcount><i class="far fa-file-word fa-fw post-meta-icon"></i> <span class=post-meta-label>总字数:</span> <span class=word-count>23.7k | </span><i class="far fa-clock fa-fw post-meta-icon"></i> <span class=post-meta-label>阅读时长:</span> <span>91分钟</span> | <i class="far fa-eye fa-fw post-meta-icon"></i> <span class=post-meta-label>阅读量:</span> <span id=Discuss-Visitors>0</span></div></div></div><div class=post-content><h2 id=面向对象><a href=#面向对象 class=headerlink title=面向对象></a>面向对象</h2><h3 id=多态分类及实现><a href=#多态分类及实现 class=headerlink title=多态分类及实现></a>多态分类及实现</h3><blockquote><p><code>静态多态：函数重载，运算符重载，函数模版</code>（函数模版的代码会经过两次编译，第一次在申明的位置编译函数代码本身，仅生成函数头，第二次在调用的地方对参数替换后的代码进行编译，实际上就是编译器替我们写对应数据类型的函数）</p></blockquote><figure class="highlight c++"><table><tr><td class=code><pre><span class=line><span class=comment>//函数重载    </span></span><br><span class=line><span class=function><span class=type>void</span> <span class=title>fun</span><span class=params>(<span class=type>int</span> a)</span></span>&#123;  <span class=comment>//参数类型不同  </span></span><br><span class=line>      cout&lt;&lt;<span class=string>&quot;this is int&quot;</span>&lt;&lt;endl;  </span><br><span class=line>  &#125;  </span><br><span class=line></span><br><span class=line>  <span class=function><span class=type>void</span> <span class=title>fun</span><span class=params>(<span class=type>int</span> a,<span class=type>int</span> b)</span></span>&#123;  </span><br><span class=line>      cout&lt;&lt;<span class=string>&quot;this is int int&quot;</span>;  </span><br><span class=line>  &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class=code><pre><span class=line>//运算符重载，对于两个int类型，编译器知道怎么相加，但是对于自定义的数据类型，编译器就不知道了  </span><br><span class=line>//可以自定义+号，进行自定义的数据类型相加，这就是运算符重载  </span><br><span class=line>class Person &#123;  </span><br><span class=line>public:  </span><br><span class=line>	Person() &#123;&#125;;   </span><br><span class=line>	Person(int a, int b)  </span><br><span class=line>	&#123;  </span><br><span class=line>		this-&gt;m_A = a;  </span><br><span class=line>		this-&gt;m_B = b;  </span><br><span class=line>	&#125;  </span><br><span class=line>	//成员函数实现 + 号运算符重载   </span><br><span class=line>	Person operator+(const Person&amp; p) &#123;   //在类内定义运算符重载  </span><br><span class=line>		Person temp;					// 实际调用为 Person p3;  </span><br><span class=line>		temp.m_A = this-&gt;m_A + p.m_A;   // p3 = poperator+(p2);  这个是本质  </span><br><span class=line>		temp.m_B = this-&gt;m_B + p.m_B;   //但是编辑器简化为  </span><br><span class=line>		return temp;		// p3 = p1 + p2;   实际运行的时候编译器会把这个转化为上面这个  </span><br><span class=line>	&#125;  </span><br><span class=line>public:  </span><br><span class=line>	int m_A;  </span><br><span class=line>	int m_B;  </span><br><span class=line>&#125;;  </span><br><span class=line>//全局函数实现 + 号运算符重载  </span><br><span class=line>//Person operator+(const Person&amp; p1, const Person&amp; p2) &#123;  </span><br><span class=line>//	Person temp(0, 0);          //本质上是Person p3 = operator+(p1,p2);  </span><br><span class=line>//	temp.m_A = pm_A + pm_A;	//但是有编译器存在，可以写成  </span><br><span class=line>//	temp.m_B = pm_B + pm_B;//Person p3 = p1 + p2 ;编译器会自动转化为上面的  </span><br><span class=line>//	return temp;  </span><br><span class=line>//&#125;  </span><br><span class=line>//运算符重载 可以发生函数重载   </span><br><span class=line>Person operator+(const Person&amp; p2, int val)    </span><br><span class=line>&#123;  </span><br><span class=line>	Person temp;            //Person p2 = p1 + 10;  </span><br><span class=line>	temp.m_A = pm_A + val;// 运算符重载的函数重载，第一次重载+号，第二次传入不同的数据类型重载  </span><br><span class=line>	temp.m_B = pm_B + val;  </span><br><span class=line>	return temp;  </span><br><span class=line>&#125;  </span><br><span class=line>void test() &#123;  </span><br><span class=line>	Person p1(10, 10);  </span><br><span class=line>	Person p2(20, 20);  </span><br><span class=line>	//成员函数方式  </span><br><span class=line>	Person p3 = p2 + p1;  //相当于 poperaor+(p1)  </span><br><span class=line>	cout &lt;&lt; &quot;mA:&quot; &lt;&lt; pm_A &lt;&lt; &quot; mB:&quot; &lt;&lt; pm_B &lt;&lt; endl;  </span><br><span class=line></span><br><span class=line>	Person p4 = p3 + 10; //相当于 operator+(p3,10)  </span><br><span class=line>	cout &lt;&lt; &quot;mA:&quot; &lt;&lt; pm_A &lt;&lt; &quot; mB:&quot; &lt;&lt; pm_B &lt;&lt; endl;  </span><br><span class=line>&#125;  </span><br><span class=line>int main() &#123;  </span><br><span class=line>	test();  </span><br><span class=line>	system(&quot;pause&quot;);  </span><br><span class=line>	return 0;  </span><br><span class=line>&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class=code><pre><span class=line><span class=comment>//交换整型函数  </span></span><br><span class=line><span class=function><span class=type>void</span> <span class=title>swapInt</span><span class=params>(<span class=type>int</span>&amp; a, <span class=type>int</span>&amp; b)</span> </span>&#123;  </span><br><span class=line>	<span class=type>int</span> temp = a;  </span><br><span class=line>	a = b;  </span><br><span class=line>	b = temp;  </span><br><span class=line>&#125;  </span><br><span class=line><span class=comment>//交换浮点型函数  </span></span><br><span class=line><span class=function><span class=type>void</span> <span class=title>swapDouble</span><span class=params>(<span class=type>double</span>&amp; a, <span class=type>double</span>&amp; b)</span> </span>&#123;  </span><br><span class=line>	<span class=type>double</span> temp = a;  </span><br><span class=line>	a = b;  </span><br><span class=line>	b = temp;  </span><br><span class=line>&#125;  </span><br><span class=line><span class=comment>//利用模板提供通用的交换函数  </span></span><br><span class=line><span class=keyword>template</span>&lt;<span class=keyword>typename</span> T&gt; <span class=comment>//typename可以用class替代  </span></span><br><span class=line><span class=function><span class=type>void</span> <span class=title>mySwap</span><span class=params>(T&amp; a, T&amp; b)</span> <span class=comment>//也可以定义多个数据类型  </span></span></span><br><span class=line><span class=function></span>&#123;						<span class=comment>//如 template&lt;class T1,class T2&gt;  </span></span><br><span class=line>	T temp = a;  </span><br><span class=line>	a = b;  </span><br><span class=line>	b = temp;  </span><br><span class=line>&#125;  </span><br><span class=line><span class=function><span class=type>void</span> <span class=title>test01</span><span class=params>()</span>  </span></span><br><span class=line><span class=function></span>&#123;  </span><br><span class=line>	<span class=type>int</span> a = <span class=number>10</span>;  </span><br><span class=line>	<span class=type>int</span> b = <span class=number>20</span>;  </span><br><span class=line>	<span class=comment>//swapInt(a, b);  </span></span><br><span class=line>	<span class=comment>//利用模板实现交换  </span></span><br><span class=line>	<span class=comment>//1、自动类型推导  </span></span><br><span class=line>	<span class=built_in>mySwap</span>(a, b);  </span><br><span class=line>	<span class=comment>//2、显示指定类型  </span></span><br><span class=line>	<span class=built_in>mySwap</span>&lt;<span class=type>int</span>&gt;(a, b); <span class=comment>//多个类型，mySwap&lt;int,double&gt;(a,b);  </span></span><br><span class=line>	cout &lt;&lt; <span class=string>&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;  </span><br><span class=line>	cout &lt;&lt; <span class=string>&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl;  </span><br><span class=line>&#125;  </span><br><span class=line><span class=function><span class=type>int</span> <span class=title>main</span><span class=params>()</span> </span>&#123;  </span><br><span class=line>	<span class=built_in>test01</span>();  </span><br><span class=line>	<span class=built_in>system</span>(<span class=string>&quot;pause&quot;</span>);  </span><br><span class=line>	<span class=keyword>return</span> <span class=number>0</span>;  </span><br><span class=line>&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>动态多态（运行期/晚绑定）</code></p></blockquote><figure class="highlight c++"><table><tr><td class=code><pre><span class=line><span class=keyword>class</span> <span class="title class_">Animal</span>  </span><br><span class=line>&#123;  </span><br><span class=line><span class=keyword>public</span>:  </span><br><span class=line>	<span class=comment>//Speak函数就是虚函数  </span></span><br><span class=line>	<span class=comment>//函数前面加上virtual关键字，变成虚函数，那么编译器在编译的时候就不能确定函数调用了。  </span></span><br><span class=line>	<span class=function><span class=keyword>virtual</span> <span class=type>void</span> <span class=title>speak</span><span class=params>()</span>  </span></span><br><span class=line><span class=function>	</span>&#123;  </span><br><span class=line>		cout &lt;&lt; <span class=string>&quot;动物在说话&quot;</span> &lt;&lt; endl;  </span><br><span class=line>	&#125;  </span><br><span class=line>&#125;;  </span><br><span class=line><span class=keyword>class</span> <span class="title class_">Cat</span> :<span class=keyword>public</span> Animal  </span><br><span class=line>&#123;  </span><br><span class=line><span class=keyword>public</span>:  </span><br><span class=line>	<span class=function><span class=type>void</span> <span class=title>speak</span><span class=params>()</span>  </span></span><br><span class=line><span class=function>	</span>&#123;  </span><br><span class=line>		cout &lt;&lt; <span class=string>&quot;小猫在说话&quot;</span> &lt;&lt; endl;  </span><br><span class=line>	&#125;  </span><br><span class=line>&#125;;  </span><br><span class=line><span class=keyword>class</span> <span class="title class_">Dog</span> :<span class=keyword>public</span> Animal  </span><br><span class=line>&#123;  </span><br><span class=line><span class=keyword>public</span>:  </span><br><span class=line>	<span class=function><span class=type>void</span> <span class=title>speak</span><span class=params>()</span>  </span></span><br><span class=line><span class=function>	</span>&#123;  </span><br><span class=line>		cout &lt;&lt; <span class=string>&quot;小狗在说话&quot;</span> &lt;&lt; endl;  </span><br><span class=line>	&#125;  </span><br><span class=line>&#125;;  </span><br><span class=line><span class=comment>//我们希望传入什么对象，那么就调用什么对象的函数  </span></span><br><span class=line><span class=comment>//如果函数地址在编译阶段就能确定，那么静态联编  </span></span><br><span class=line><span class=comment>//如果函数地址在运行阶段才能确定，就是动态联编  </span></span><br><span class=line><span class=function><span class=type>void</span> <span class=title>DoSpeak</span><span class=params>(Animal &amp; animal)</span>  </span></span><br><span class=line><span class=function></span>&#123;  </span><br><span class=line>	animal.<span class=built_in>speak</span>();  </span><br><span class=line>&#125;  </span><br><span class=line><span class=comment>//多态满足条件：   </span></span><br><span class=line><span class=comment>//1、有继承关系  </span></span><br><span class=line><span class=comment>//2、子类重写父类中的虚函数  </span></span><br><span class=line><span class=comment>//多态使用：  </span></span><br><span class=line><span class=comment>//父类指针或引用指向子类对象  </span></span><br><span class=line><span class=function><span class=type>void</span> <span class=title>test01</span><span class=params>()</span>  </span></span><br><span class=line><span class=function></span>&#123;  </span><br><span class=line>	Cat cat;  </span><br><span class=line>	<span class=built_in>DoSpeak</span>(cat);  </span><br><span class=line>	Dog dog;  </span><br><span class=line>	<span class=built_in>DoSpeak</span>(dog);  </span><br><span class=line>&#125;  </span><br><span class=line><span class=function><span class=type>int</span> <span class=title>main</span><span class=params>()</span> </span>&#123;  </span><br><span class=line>	<span class=built_in>test01</span>();  </span><br><span class=line>	<span class=built_in>system</span>(<span class=string>&quot;pause&quot;</span>);  </span><br><span class=line>	<span class=keyword>return</span> <span class=number>0</span>;  </span><br><span class=line>&#125;</span><br></pre></td></tr></table></figure><h3 id=动态多态实现原理><a href=#动态多态实现原理 class=headerlink title=动态多态实现原理></a>动态多态实现原理</h3><ul><li>虚函数指针：在含有虚函数类的对象中，是对象所有，指向虚函数表，在运行时确定。（64位系统8字节）</li><li>虚函数表：在含有虚函数的类中，为类所有，如果派生类实现了基类的某个虚函数，则在虚表中覆盖原本基类的那个虚函数指针，在编译时根据类的声明创建。</li><li>创建对象的时候，会根据这个对象的类型给这个对象的虚函数指针进行赋值，即是什么类型的对象虚指针就指向该对象下的虚表，如果是创建子类对象，会先调用父类的构造函数，在调用子类的构造函数，所以虚指针指向子类的虚表</li><li>如果子类没有对父类的虚函数重写，则子类的虚表的内容还是和父类的虚表的内容一样；如果重写了，替换重写之后的虚函数；如果自己还有增加的虚函数，则把虚函数的地址也存放到虚表的后面</li><li>当父类的指针指向子类的对象时，根据虚指针就能访问子类的虚函数；</li></ul><h3 id=构造函数的分类及调用><a href=#构造函数的分类及调用 class=headerlink title=构造函数的分类及调用></a>构造函数的分类及调用</h3><blockquote><p>两种分类方式：</p></blockquote><blockquote><p>按参数分为： <code>有参构造和无参构造</code></p></blockquote><blockquote><p>按类型分为： <code>普通构造和拷贝构造，移动构造函数</code></p></blockquote><blockquote><p>三种调用方式：<code>括号法，显示法隐式转换法</code></p></blockquote><blockquote><p><code>示例：</code></p></blockquote><figure class="highlight plaintext"><table><tr><td class=code><pre><span class=line>//1、构造函数分类  </span><br><span class=line>// 按照参数分类分为 有参和无参构造   无参又称为默认构造函数  </span><br><span class=line>// 按照类型分类分为 普通构造和拷贝构造  </span><br><span class=line>class Person &#123;  </span><br><span class=line>public:  </span><br><span class=line>	//无参（默认）构造函数  </span><br><span class=line>	Person() &#123;  </span><br><span class=line>		cout &lt;&lt; &quot;无参构造函数!&quot; &lt;&lt; endl;  </span><br><span class=line>	&#125;  </span><br><span class=line>	//有参构造函数  </span><br><span class=line>	Person(int a) &#123;  </span><br><span class=line>		age = a;  </span><br><span class=line>		cout &lt;&lt; &quot;有参构造函数!&quot; &lt;&lt; endl;  </span><br><span class=line>	&#125;  </span><br><span class=line>	//拷贝构造函数  </span><br><span class=line>	Person(const Person&amp; p) &#123;  </span><br><span class=line>		age = p.age;  </span><br><span class=line>		cout &lt;&lt; &quot;拷贝构造函数!&quot; &lt;&lt; endl;  </span><br><span class=line>	&#125;  </span><br><span class=line>	//析构函数  </span><br><span class=line>	~Person() &#123;  </span><br><span class=line>		cout &lt;&lt; &quot;析构函数!&quot; &lt;&lt; endl;  </span><br><span class=line>	&#125;  </span><br><span class=line>public:  </span><br><span class=line>	int age;  </span><br><span class=line>&#125;;  </span><br><span class=line>//2、构造函数的调用  </span><br><span class=line>//调用无参构造函数  </span><br><span class=line>void test01() &#123;  </span><br><span class=line>	Person p; //调用无参构造函数  </span><br><span class=line>    //注意1：调用无参构造函数不能加括号，如果加了编译器认为这是一个函数声明  </span><br><span class=line>	//Person p2(); //函数声明  </span><br><span class=line>&#125;  </span><br><span class=line>//调用有参的构造函数  </span><br><span class=line>void test02() &#123;  </span><br><span class=line>	//1  括号法，常用  </span><br><span class=line>	Person p1(10);  </span><br><span class=line>	//2 显式法  </span><br><span class=line>	Person p2 = Person(10); //拷贝构造  </span><br><span class=line>	Person p3 = Person(p2); //拷贝构造  </span><br><span class=line>	//Person(10)单独写就是匿名对象  当前行结束之后，马上析构  </span><br><span class=line>	//3 隐式转换法  </span><br><span class=line>	Person p4 = 10; // Person p4 = Person(10);   //拷贝构造  </span><br><span class=line>	Person p5 = p4; // Person p5 = Person(p4);  //拷贝构造  </span><br><span class=line>	//注意2：不能利用 拷贝构造函数 初始化匿名对象 编译器认为是对象声明  </span><br><span class=line>	//Person p5(p4); //函数声明  </span><br><span class=line>&#125;  </span><br><span class=line>int main() &#123;  </span><br><span class=line>	test01();  </span><br><span class=line>	//test02();  </span><br><span class=line>	system(&quot;pause&quot;);  </span><br><span class=line>	return 0;  </span><br><span class=line>&#125;</span><br></pre></td></tr></table></figure><ul><li>移动构造函数。用于将其他类型的变量，隐式转换为本类对象。下面的转换构造函数，将int类型的r转换为Student类型的对象，对象的age为r，num为1004.</li></ul><figure class="highlight plaintext"><table><tr><td class=code><pre><span class=line>Student(int r) &#123;   </span><br><span class=line>int num=1004;   </span><br><span class=line>int age= r;   </span><br><span class=line>&#125;</span><br></pre></td></tr></table></figure><ul><li><blockquote><p><code>有了有参的构造了，编译器就不提供默认的构造函数。所以写了有参构造，一定要写无参构造</code></p></blockquote></li><li><blockquote><p><code>如果没有属性要求在堆区开辟，深浅拷贝无所谓,深拷贝针对有属性在堆区开辟</code></p></blockquote></li><li><blockquote><p><code>只定义了析构函数，编译器将自动为我们生成拷贝构造函数和默认构造函数。</code></p></blockquote></li></ul><h3 id=构造函数、析构函数调用顺序><a href=#构造函数、析构函数调用顺序 class=headerlink title=构造函数、析构函数调用顺序></a>构造函数、析构函数调用顺序</h3><ul><li>子类继承了父类，子类构造的时候，会先调用父类的构造函数对其初始化，再调用子类的构造函数（如果子类重写了构造函数，将覆盖父类构造函数初始化的值，如果子类有新的成员变量，则会调用子类构造函数阶段赋值）</li><li>子类析构的时候，会先调用自身的析构函数，然后调用父类的析构函数</li><li>**父类指针析构的时候，会调用自身的析构函数，不会调用子类的析构函数，当实现多态的时候（父类指针指向子类对象），将父类析构函数设置为虚函数，这样父类析构的时候会先调用子类的析构函数，再调用父类的析构函数 **</li></ul><h3 id=构造函数为什么不能虚函数><a href=#构造函数为什么不能虚函数 class=headerlink title=构造函数为什么不能虚函数></a>构造函数为什么不能虚函数</h3><ol><li>从存储空间角度：调用虚函数需要虚指针，而对象还没有构造，显然没有虚指针（悖论）</li><li>从使用角度：虚函数主要是为了实现多态，而构造函数没有这方面的必要。</li><li>从实现上看，vtable 在构造函数调用后才建立，因而构造函数不可能成为虚函数。</li></ol><h3 id=拷贝构造函数的参数传递方式><a href=#拷贝构造函数的参数传递方式 class=headerlink title=拷贝构造函数的参数传递方式></a>拷贝构造函数的参数传递方式</h3><blockquote><p><code>参考回答</code></p></blockquote><ol><li><blockquote><p>拷贝构造函数的参数必须使用引用传递</p></blockquote></li><li><blockquote><p>如果拷贝构造函数中的参数不是一个引用，那么就相当于采用了传值的方式(pass-by-value)，而<code>传值的方式会调用该类的拷贝构造函数</code>，从而造成无穷递归地调用拷贝构造函数。因此拷贝构造函数的参数必须是一个引用。</p></blockquote><blockquote><p>需要澄清的是，<em><em>传指针其实也是传值，如果上面的拷贝构造函数写成CClass(const CClass</em> c_class)，也是不行的</em>*。事实上，只有传引用不是传值外，其他所有的传递方式都是传值。</p></blockquote></li></ol><h3 id=拷贝赋值和移动赋值？><a href=#拷贝赋值和移动赋值？ class=headerlink title=拷贝赋值和移动赋值？></a>拷贝赋值和移动赋值？</h3><blockquote><p><code>参考回答</code></p></blockquote><ol><li><blockquote><p>拷贝赋值是通过拷贝构造函数来赋值，在创建对象时，使用同一类中之前创建的对象来初始化新创建的对象。</p></blockquote></li><li><blockquote><p>移动赋值是通过移动构造函数来赋值，二者的主要区别在于</p></blockquote><blockquote><p>1）拷贝构造函数的形参是一个左值引用，而移动构造函数的形参是一个右值引用；</p></blockquote><blockquote><p>2）拷贝构造函数完成的是整个对象或变量的拷贝，而移动构造函数是生成一个指针指向源对象或变量的地址，接管源对象的内存，相对于大量数据的拷贝节省时间和内存空间。</p></blockquote></li></ol><h3 id=深拷贝与浅拷贝><a href=#深拷贝与浅拷贝 class=headerlink title=深拷贝与浅拷贝></a>深拷贝与浅拷贝</h3><blockquote><p><code>特别注意，深拷贝与浅拷贝如果不涉及到指针，则无区别</code></p></blockquote><blockquote><p><code>一般说的深拷贝与浅拷贝，涉及到指针的操作</code></p></blockquote><blockquote><p>浅拷贝：简单的赋值拷贝操作，<code>增加一个指针指向原来的区域</code></p></blockquote><blockquote><p>深拷贝：在堆区重新申请空间，进行拷贝操作<code>重新申请空间，拷贝值到所申请的空间</code></p></blockquote><blockquote><p><code>为什么需要深拷贝？ 因为如果重新增加一个指针指向原来的区域（浅拷贝），如果其中一个指针释放，那么其他的指针依然指向该空间，这些指针就会变成悬空指针</code></p></blockquote><blockquote><p><code>示例：</code></p></blockquote><figure class="highlight plaintext"><table><tr><td class=code><pre><span class=line>class Person &#123;  </span><br><span class=line>public:  </span><br><span class=line>	//无参（默认）构造函数  </span><br><span class=line>	Person() &#123;  </span><br><span class=line>		cout &lt;&lt; &quot;无参构造函数!&quot; &lt;&lt; endl;  </span><br><span class=line>	&#125;  </span><br><span class=line>	//有参构造函数  </span><br><span class=line>	Person(int age ,int height) &#123;  </span><br><span class=line>		cout &lt;&lt; &quot;有参构造函数!&quot; &lt;&lt; endl;  </span><br><span class=line>		m_age = age;  </span><br><span class=line>		m_height = new int(height);  </span><br><span class=line>	&#125;  </span><br><span class=line>	//拷贝构造函数    </span><br><span class=line>	Person(const Person&amp; p) &#123;  </span><br><span class=line>		cout &lt;&lt; &quot;拷贝构造函数!&quot; &lt;&lt; endl;  </span><br><span class=line>		//如果不利用深拷贝在堆区创建新内存，会导致浅拷贝带来的重复释放堆区问题  </span><br><span class=line>		m_age = p.m_age;  </span><br><span class=line>		m_height = new int(*p.m_height);  </span><br><span class=line>	&#125;  </span><br><span class=line>	//析构函数  </span><br><span class=line>	~Person() &#123;  </span><br><span class=line>		cout &lt;&lt; &quot;析构函数!&quot; &lt;&lt; endl;  </span><br><span class=line>		if (m_height != NULL)  </span><br><span class=line>		&#123;  </span><br><span class=line>			delete m_height;  </span><br><span class=line>		&#125;  </span><br><span class=line>	&#125;  </span><br><span class=line>public:  </span><br><span class=line>	int m_age;  </span><br><span class=line>	int* m_height;  </span><br><span class=line>&#125;;  </span><br><span class=line>void test01()  </span><br><span class=line>&#123;  </span><br><span class=line>	Person p1(18, 180);  </span><br><span class=line>	Person p2(p1);  </span><br><span class=line>	cout &lt;&lt; &quot;p1的年龄： &quot; &lt;&lt; pm_age &lt;&lt; &quot; 身高： &quot; &lt;&lt; *pm_height &lt;&lt; endl;  </span><br><span class=line>	cout &lt;&lt; &quot;p2的年龄： &quot; &lt;&lt; pm_age &lt;&lt; &quot; 身高： &quot; &lt;&lt; *pm_height &lt;&lt; endl;  </span><br><span class=line>&#125;  </span><br><span class=line>int main() &#123;  </span><br><span class=line>	test01();  </span><br><span class=line>	system(&quot;pause&quot;);  </span><br><span class=line>	return 0;  </span><br><span class=line>&#125;</span><br></pre></td></tr></table></figure><blockquote><blockquote><p>总结：如果属性有在堆区开辟的，一定要自己提供拷贝构造函数，防止浅拷贝带来的问题</p></blockquote></blockquote><h3 id=虚析构><a href=#虚析构 class=headerlink title=虚析构></a>虚析构</h3><ol><li><blockquote><p>虚析构：将可能会被继承的父类的析构函数设置为虚函数，可以保证当我们new一个子类，然后使用基类指针指向该子类对象，释放基类指针时可以释放掉子类的空间，防止内存泄漏。如果基类的析构函数不是虚函数，在特定情况下会导致派生来无法被析构。</p></blockquote><ol><li>用派生类类型指针绑定派生类实例，析构的时候，不管基类析构函数是不是虚函数，都会正常析构</li><li>用基类类型指针绑定派生类实例，析构的时候，如果基类析构函数不是虚函数，则只会析构基类，不会析构派生类对象，从而造成内存泄漏。</li></ol><blockquote><p>C++默认的析构函数不是虚函数是因为虚函数需要额外的虚函数表和虚表指针，占用额外的内存。而对于不会被继承的类来说，其析构函数如果是虚函数，就会浪费内存。<code>因此C++默认的析构函数不是虚函数，而是只有当需要当作父类时，设置为虚函数。</code></p></blockquote></li></ol><figure class="highlight plaintext"><table><tr><td class=code><pre><span class=line>class Shape  </span><br><span class=line>&#123;  </span><br><span class=line>public:  </span><br><span class=line>  Shape();                    // 构造函数不能是虚函数  </span><br><span class=line>  virtual double calcArea();  </span><br><span class=line>  virtual ~Shape();           // 虚析构函数  </span><br><span class=line>&#125;;  </span><br><span class=line>class Circle : public Shape     // 圆形类  </span><br><span class=line>&#123;  </span><br><span class=line>public:  </span><br><span class=line>  virtual double calcArea();  </span><br><span class=line>  ...  </span><br><span class=line>&#125;;  </span><br><span class=line>int main()  </span><br><span class=line>&#123;  </span><br><span class=line>  Shape * shape1 = new Circle(0);  </span><br><span class=line>  shape1-&gt;calcArea();      </span><br><span class=line>  delete shape1;  // 因为Shape有虚析构函数，所以delete释放内存时，先调用子类析构函数，再调用基类析构函数，防止内存泄漏。  </span><br><span class=line>  shape1 = NULL;  </span><br><span class=line>  return 0；  </span><br><span class=line>&#125;</span><br></pre></td></tr></table></figure><h3 id=虚函数、纯虚函数><a href=#虚函数、纯虚函数 class=headerlink title=虚函数、纯虚函数></a>虚函数、纯虚函数</h3><ul><li>纯虚函数只是一个接口，是个函数的声明而已，它要留到子类里去实现。</li><li>虚函数有具体实现，哪怕是空实现，在子类里面可以不重写；但纯虚函数必须在子类实现才可以实例化子类。</li><li>虚函数的类用于 “实作继承”，继承接口的同时也继承了父类的实现。纯虚函数关注的是接口的统一性，实现由子类完成。</li><li>带纯虚函数的类叫抽象类，这种类不能直接生成对象，而只有被继承，并重写其虚函数后，才能使用。抽象类被继承后，子类可以继续是抽象类，也可以是普通类。</li></ul><h3 id=虚继承（菱形继承）><a href=#虚继承（菱形继承） class=headerlink title=虚继承（菱形继承）></a>虚继承（菱形继承）</h3><blockquote><p>虚继承用于解决多继承条件下的菱形继承问题（浪费存储空间、存在二义性）。</p></blockquote><blockquote><p>底层实现原理与编译器相关，一般通过<code>虚基类指针</code>和<code>虚基类表</code>实现，每个虚继承的子类都有一个虚基类指针（占用一个指针的存储空间，4字节）和虚基类表（不占用类对象的存储空间）（需要强调的是，虚基类依旧会在子类里面存在拷贝，只是仅仅最多存在一份而已，并不是不在子类里面了）；当虚继承的子类被当做父类继承时，虚基类指针也会被继承。</p></blockquote><blockquote><p>实际上，vbptr 指的是虚基类表指针（virtual base table pointer），该指针指向了一个虚基类表（virtual table），虚表中记录了虚基类与本类的偏移地址；通过偏移地址，这样就找到了虚基类成员，而虚继承也不用像普通多继承那样维持着公共基类（虚基类）的两份同样的拷贝，节省了存储空间。</p></blockquote><blockquote><p>![image-20220413172857263](&#x2F;Users&#x2F;apple&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20220413172857263.png)</p></blockquote><h3 id=虚继承、虚函数对比><a href=#虚继承、虚函数对比 class=headerlink title=虚继承、虚函数对比></a>虚继承、虚函数对比</h3><ul><li>相同之处：都利用了虚指针（均占用类的存储空间）和虚表（均不占用类的存储空间）</li><li>不同之处：<ul><li>虚继承<ul><li>虚基类依旧存在继承类中，只占用存储空间</li><li>虚基类表存储的是虚基类相对直接继承类的偏移</li></ul></li><li>虚函数<ul><li>虚函数不占用存储空间</li><li>虚函数表存储的是虚函数地址</li></ul></li></ul></li></ul><h3 id=哪些函数不能被声明为虚函数><a href=#哪些函数不能被声明为虚函数 class=headerlink title=哪些函数不能被声明为虚函数></a>哪些函数不能被声明为虚函数</h3><blockquote><p><code>参考回答</code></p></blockquote><blockquote><p>常见的不不能声明为虚函数的有：<code>普通函数（非成员函数），静态成员函数，内联成员函数，构造函数，友元函数。</code></p></blockquote><ol><li><blockquote><p>为什么C++不支持普通函数为虚函数？</p></blockquote><blockquote><p>普通函数（非成员函数）只能被overload，不能被override，<code>声明为虚函数也没有什么意思，</code>因此编译器会在编译时绑定函数。</p></blockquote></li><li><blockquote><p>为什么C++不支持构造函数为虚函数？</p></blockquote><blockquote><p>这个原因很简单，主要是从语义上考虑，所以不支持。因为构造函数本来就是为了明确初始化对象成员才产生的，然而virtual function主要是为了再不完全了解细节的情况下也能正确处理对象。另外，virtual函数是在不同类型的对象产生不同的动作，现在对象还没有产生，如何使用virtual函数来完成你想完成的动作。（这不就是典型的悖论）</p></blockquote><blockquote><p>构造函数用来创建一个新的对象,而虚函数的运行是建立在对象的基础上,在构造函数执行时,对象尚未形成,所以不能将构造函数定义为虚函数</p></blockquote></li><li><blockquote><p>为什么C++不支持内联成员函数为虚函数？</p></blockquote><blockquote><p>其实很简单，那内联函数就是为了在代码中直接展开，减少函数调用花费的代价，虚函数是为了在继承后对象能够准确的执行自己的动作，这是不可能统一的。（再说了，<code>inline函数在编译时被展开，虚函数在运行时才能动态的绑定函数</code>）</p></blockquote><blockquote><p><code>内联函数是在编译时期展开,而虚函数的特性是运行时才动态联编,所以两者矛盾,不能定义内联函数为虚函数</code></p></blockquote></li><li><blockquote><p>为什么C++不支持静态成员函数为虚函数？</p></blockquote><blockquote><p>这也很简单，<code>静态成员函数对于每个类来说只有一份代码，所有的对象都共享这一份代码，他也没有要动态绑定的必要性。</code></p></blockquote><blockquote><p><code>静态成员函数属于一个类而非某一对象,没有this指针,它无法进行对象的判别</code></p></blockquote></li><li><blockquote><p>为什么C++不支持友元函数为虚函数？</p></blockquote><blockquote><p><code>因为C++不支持友元函数的继承，</code>对于没有继承特性的函数没有虚函数的说法。</p></blockquote></li></ol><h3 id=虚函数表里存放的内容是什么时候写进去的><a href=#虚函数表里存放的内容是什么时候写进去的 class=headerlink title=虚函数表里存放的内容是什么时候写进去的></a>虚函数表里存放的内容是什么时候写进去的</h3><blockquote><p><code>参考回答</code></p></blockquote><ol><li>虚函数表是一个存储虚函数地址的数组,以NULL结尾。<code>虚表（vftable）在编译阶段生成，对象内存空间开辟以后，写入对象中的 vfptr，然后调用构造函数。即：虚表在构造函数之前写入</code></li><li>除了在构造函数之前写入之外，我们还需要考虑到虚表的二次写入机制，通过此机制让每个对象的虚表指针都能准确的指向到自己类的虚表，为实现动多态提供支持。</li></ol><h3 id=重写、重载、隐藏><a href=#重写、重载、隐藏 class=headerlink title=重写、重载、隐藏></a>重写、重载、隐藏</h3><p>1）重载（overload）</p><p>重载是指在同一范围定义中的同名成员函数才存在重载关系。主要特点是函数名相同，参数类型和数目有所不同，不能出现参数个数和类型均相同，仅仅依靠返回值不同来区分的函数。重载和函数成员是否是虚函数无关</p><figure class="highlight c++"><table><tr><td class=code><pre><span class=line><span class=keyword>class</span> <span class="title class_">A</span>&#123;</span><br><span class=line>    ... <span class=comment>//函数重载（参数类型不同或者个数不同）</span></span><br><span class=line>    <span class=function><span class=keyword>virtual</span> <span class=type>int</span> <span class=title>fun</span><span class=params>()</span></span>; </span><br><span class=line>    <span class=function><span class=type>void</span> <span class=title>fun</span><span class=params>(<span class=type>int</span>)</span></span>;</span><br><span class=line>    <span class=function><span class=type>void</span> <span class=title>fun</span><span class=params>(<span class=type>double</span>, <span class=type>double</span>)</span></span>;</span><br><span class=line>    <span class=function><span class=type>static</span> <span class=type>int</span> <span class=title>fun</span><span class=params>(<span class=type>char</span>)</span></span>;</span><br><span class=line>    ...</span><br><span class=line>&#125;</span><br></pre></td></tr></table></figure><p>2）重写（覆盖）（override）</p><p>重写指的是在派生类中覆盖基类中的同名函数，<strong>重写就是重写函数体</strong>，<strong>要求基类函数必须是虚函数</strong>且：</p><ul><li>与基类的虚函数有相同的参数个数</li><li>与基类的虚函数有相同的参数类型</li><li>与基类的虚函数有相同的返回值类型</li></ul><p>重载与重写的区别：</p><ul><li>重写是父类和子类之间的垂直关系，重载是不同函数之间的水平关系</li><li>重写要求参数列表相同，重载则要求参数列表不同，返回值不要求</li><li>重写关系中，调用方法根据对象类型决定，重载根据调用时实参表与形参表的对应关系来选择函数体</li></ul><figure class="highlight c++"><table><tr><td class=code><pre><span class=line><span class=comment>//父类</span></span><br><span class=line><span class=keyword>class</span> <span class="title class_">A</span>&#123;</span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>    <span class=function><span class=keyword>virtual</span> <span class=type>int</span> <span class=title>fun</span><span class=params>(<span class=type>int</span> a)</span></span>&#123;&#125;</span><br><span class=line>&#125;</span><br><span class=line><span class=comment>//子类</span></span><br><span class=line><span class=keyword>class</span> <span class="title class_">B</span> : <span class=keyword>public</span> A&#123;</span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>    <span class=comment>//重写,一般加override可以确保是重写父类的函数</span></span><br><span class=line>    <span class=function><span class=keyword>virtual</span> <span class=type>int</span> <span class=title>fun</span><span class=params>(<span class=type>int</span> a)</span> <span class=keyword>override</span></span>&#123;&#125;</span><br><span class=line>&#125;</span><br></pre></td></tr></table></figure><p>3)隐藏指的是某些情况下，派生类中的函数屏蔽了基类中的同名函数，包括以下情况：</p><ul><li>两个函数参数相同，但是基类函数不是虚函数。<strong>和重写的区别在于基类函数是否是虚函数。</strong>举个例子：</li></ul><figure class="highlight c++"><table><tr><td class=code><pre><span class=line><span class=comment>//父类</span></span><br><span class=line><span class=keyword>class</span> <span class="title class_">A</span>&#123;</span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>    <span class=function><span class=type>void</span> <span class=title>fun</span><span class=params>(<span class=type>int</span> a)</span></span>&#123;</span><br><span class=line>        cout &lt;&lt; <span class=string>&quot;A中的fun函数&quot;</span> &lt;&lt; endl;</span><br><span class=line>    &#125;</span><br><span class=line>&#125;;</span><br><span class=line><span class=comment>//子类</span></span><br><span class=line><span class=keyword>class</span> <span class="title class_">B</span> : <span class=keyword>public</span> A&#123;</span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>    <span class=comment>//隐藏父类的fun函数</span></span><br><span class=line>    <span class=function><span class=type>void</span> <span class=title>fun</span><span class=params>(<span class=type>int</span> a)</span></span>&#123;</span><br><span class=line>        cout &lt;&lt; <span class=string>&quot;B中的fun函数&quot;</span> &lt;&lt; endl;</span><br><span class=line>    &#125;</span><br><span class=line>&#125;;</span><br><span class=line><span class=function><span class=type>int</span> <span class=title>main</span><span class=params>()</span></span>&#123;</span><br><span class=line>    B b;</span><br><span class=line>    b.<span class=built_in>fun</span>(<span class=number>2</span>); <span class=comment>//调用的是B中的fun函数</span></span><br><span class=line>    b.A::<span class=built_in>fun</span>(<span class=number>2</span>); <span class=comment>//调用A中fun函数</span></span><br><span class=line>    <span class=keyword>return</span> <span class=number>0</span>;</span><br><span class=line>&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class=code><pre><span class=line>两个函数参数不同，无论基类函数是不是虚函数，都会被隐藏。和重载的区别在于两个函数不在同一个类中。举个例子：</span><br><span class=line><span class=comment>//父类</span></span><br><span class=line><span class=keyword>class</span> <span class="title class_">A</span>&#123;</span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>    <span class=function><span class=keyword>virtual</span> <span class=type>void</span> <span class=title>fun</span><span class=params>(<span class=type>int</span> a)</span></span>&#123;</span><br><span class=line>        cout &lt;&lt; <span class=string>&quot;A中的fun函数&quot;</span> &lt;&lt; endl;</span><br><span class=line>    &#125;</span><br><span class=line>&#125;;</span><br><span class=line><span class=comment>//子类</span></span><br><span class=line><span class=keyword>class</span> <span class="title class_">B</span> : <span class=keyword>public</span> A&#123;</span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>    <span class=comment>//隐藏父类的fun函数</span></span><br><span class=line>   <span class=function><span class=keyword>virtual</span> <span class=type>void</span> <span class=title>fun</span><span class=params>(<span class=type>char</span>* a)</span></span>&#123;</span><br><span class=line>       cout &lt;&lt; <span class=string>&quot;A中的fun函数&quot;</span> &lt;&lt; endl;</span><br><span class=line>   &#125;</span><br><span class=line>&#125;;</span><br><span class=line><span class=function><span class=type>int</span> <span class=title>main</span><span class=params>()</span></span>&#123;</span><br><span class=line>    B b;</span><br><span class=line>    b.<span class=built_in>fun</span>(<span class=number>2</span>); <span class=comment>//报错，调用的是B中的fun函数，参数类型不对</span></span><br><span class=line>    b.A::<span class=built_in>fun</span>(<span class=number>2</span>); <span class=comment>//调用A中fun函数</span></span><br><span class=line>    <span class=keyword>return</span> <span class=number>0</span>;</span><br><span class=line>&#125;</span><br><span class=line>Copy to clipboardErrorCopied</span><br><span class=line>补充：</span><br><span class=line></span><br><span class=line><span class=comment>// 父类</span></span><br><span class=line><span class=keyword>class</span> <span class="title class_">A</span> &#123;</span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>    <span class=function><span class=keyword>virtual</span> <span class=type>void</span> <span class=title>fun</span><span class=params>(<span class=type>int</span> a)</span> </span>&#123; <span class=comment>// 虚函数</span></span><br><span class=line>        cout &lt;&lt; <span class=string>&quot;This is A fun &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class=line>    &#125;  </span><br><span class=line>    <span class=function><span class=type>void</span> <span class=title>add</span><span class=params>(<span class=type>int</span> a, <span class=type>int</span> b)</span> </span>&#123;</span><br><span class=line>        cout &lt;&lt; <span class=string>&quot;This is A add &quot;</span> &lt;&lt; a + b &lt;&lt; endl;</span><br><span class=line>    &#125;</span><br><span class=line>&#125;;</span><br><span class=line></span><br><span class=line><span class=comment>// 子类</span></span><br><span class=line><span class=keyword>class</span> <span class="title class_">B</span>: <span class=keyword>public</span> A &#123;</span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>    <span class=function><span class=type>void</span> <span class=title>fun</span><span class=params>(<span class=type>int</span> a)</span> <span class=keyword>override</span> </span>&#123;  <span class=comment>// 覆盖</span></span><br><span class=line>        cout &lt;&lt; <span class=string>&quot;this is B fun &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class=line>    &#125;</span><br><span class=line>    <span class=function><span class=type>void</span> <span class=title>add</span><span class=params>(<span class=type>int</span> a)</span> </span>&#123;   <span class=comment>// 隐藏</span></span><br><span class=line>        cout &lt;&lt; <span class=string>&quot;This is B add &quot;</span> &lt;&lt; a + a &lt;&lt; endl;</span><br><span class=line>    &#125;</span><br><span class=line>&#125;;</span><br><span class=line></span><br><span class=line><span class=function><span class=type>int</span> <span class=title>main</span><span class=params>()</span> </span>&#123;</span><br><span class=line>    <span class=comment>// 基类指针指向派生类对象时，基类指针可以直接调用到派生类的覆盖函数，也可以通过 :: 调用到基类被覆盖</span></span><br><span class=line>    <span class=comment>// 的虚函数；而基类指针只能调用基类的被隐藏函数，无法识别派生类中的隐藏函数。</span></span><br><span class=line></span><br><span class=line>    A *p = <span class=keyword>new</span> <span class=built_in>B</span>();</span><br><span class=line>    p-&gt;<span class=built_in>fun</span>(<span class=number>1</span>);      <span class=comment>// 调用子类 fun 覆盖函数</span></span><br><span class=line>    p-&gt;A::<span class=built_in>fun</span>(<span class=number>1</span>);   <span class=comment>// 调用父类 fun</span></span><br><span class=line>    p-&gt;<span class=built_in>add</span>(<span class=number>1</span>, <span class=number>2</span>);</span><br><span class=line>    <span class=comment>// p-&gt;add(1);      // 错误，识别的是 A 类中的 add 函数，参数不匹配</span></span><br><span class=line>    <span class=comment>// p-&gt;B::add(1);   // 错误，无法识别子类 add 函数</span></span><br><span class=line>    <span class=keyword>return</span> <span class=number>0</span>;</span><br><span class=line>&#125;</span><br></pre></td></tr></table></figure><h3 id=struct-class-区别><a href=#struct-class-区别 class=headerlink title="struct class 区别"></a>struct class 区别</h3><ul><li><blockquote><p>struct 用于描述数据结构集合， class 是对一个对象数据的封装；</p></blockquote></li><li><blockquote><p>struct 中默认 public 的，而 class 中默认 private</p></blockquote></li></ul><figure class="highlight plaintext"><table><tr><td class=code><pre><span class=line>struct person&#123;  </span><br><span class=line>    int a;  </span><br><span class=line>&#125;;  </span><br><span class=line> class student&#123;  </span><br><span class=line>     int b ;  </span><br><span class=line> &#125;;  </span><br><span class=line>int main() &#123;  </span><br><span class=line>    person p1;  </span><br><span class=line>    student s;  </span><br><span class=line>    pa = 10; //默认属性public  </span><br><span class=line>//    s.b = 10; 报错，默认private属性不可以访问；  </span><br><span class=line>    return 0;  </span><br><span class=line>&#125;</span><br></pre></td></tr></table></figure><ol><li><blockquote><p>在继承关系中，struct 默认是公有继承，而 class 是私有继承；</p></blockquote><blockquote><p>clsaa继承图：</p></blockquote><blockquote><p>![截屏2022-03-15 19.07.26](&#x2F;Users&#x2F;apple&#x2F;Desktop&#x2F;计算机资料&#x2F;图片&#x2F;截屏2022-03-15 19.07.26.png)</p></blockquote></li><li><blockquote><p>class 可以定义模板参数，就像 typename，而 struct 不能</p></blockquote><figure class="highlight plaintext"><table><tr><td class=code><pre><span class=line>template&lt;typename T, typename Y&gt;  </span><br><span class=line>// 可以把typename 换成 class    </span><br><span class=line>int Func(const T&amp; t, const Y&amp; y)</span><br></pre></td></tr></table></figure></li></ol><h3 id=this-指针><a href=#this-指针 class=headerlink title="this 指针"></a>this 指针</h3><ol><li><blockquote><p>当对一个对象调用成员函数时，编译程序先将对象的地址赋给 <code>this</code> 指针，然后调用成员函数，每次成员函数存取数据成员时，都隐式使用 <code>this</code> 指针。</p></blockquote></li><li><blockquote><p><code>this</code> 指针被隐含地声明为:</p></blockquote><figure class="highlight plaintext"><table><tr><td class=code><pre><span class=line>ClassName *const this</span><br></pre></td></tr></table></figure><p>，这意味着不能给 <code>this</code> 指针赋值；在 <code>ClassName</code> 类的 <code>const</code> 成员函数中，<code>this</code> 指针的类型为：</p><figure class="highlight plaintext"><table><tr><td class=code><pre><span class=line>const ClassName* const</span><br></pre></td></tr></table></figure><p>，这说明不能对 <code>this</code> 指针所指向的这种对象是不可修改的（即不能对这种对象的数据成员进行赋值操作）；</p></li><li><blockquote><p><code>this</code> 并不是一个常规变量，而是个右值，所以不能取得 <code>this</code> 的地址（不能 <code>&amp;this</code>）。</p></blockquote></li><li><blockquote><p>在以下场景中，经常需要显式引用this指针：</p></blockquote><ul><li><blockquote><p>为实现对象的链式引用；</p></blockquote></li><li><blockquote><p>为避免对同一对象进行赋值操作；</p></blockquote></li><li><blockquote><p>在实现一些数据结构时，如 <code>list</code>。</p></blockquote></li></ul></li></ol><h3 id=delete-this-合法吗？><a href=#delete-this-合法吗？ class=headerlink title="delete this 合法吗？"></a>delete this 合法吗？</h3><blockquote><blockquote><p>Is it legal (and moral) for a member function to say delete this?</p></blockquote></blockquote><blockquote><p>合法，但：</p></blockquote><ol><li>必须保证 this 对象是通过 <code>new</code>（不是 <code>new[]</code>、不是 placement new、不是栈上、不是全局、不是其他对象成员）分配的</li><li>必须保证成员函数的 <code>delete this</code>后面没有调用 this 了</li></ol><h3 id=如何定义一个只能在堆上（栈上）生成对象的类？><a href=#如何定义一个只能在堆上（栈上）生成对象的类？ class=headerlink title=如何定义一个只能在堆上（栈上）生成对象的类？></a>如何定义一个只能在堆上（栈上）生成对象的类？</h3><blockquote><blockquote><p>如何定义一个只能在堆上（栈上）生成对象的类?</p></blockquote></blockquote><blockquote><p>只能在堆上</p></blockquote><blockquote><p>方法：将析构函数设置为私有</p></blockquote><blockquote><p>原因：C++ 是静态绑定语言，编译器管理栈上对象的生命周期，编译器在为类对象分配栈空间时，会先检查类的析构函数的访问性。若析构函数不可访问，则不能在栈上创建对象。</p></blockquote><blockquote><p>只能在栈上</p></blockquote><blockquote><p>方法：将 new 和 delete 重载为私有</p></blockquote><blockquote><p>原因：在堆上生成对象，使用 new 关键词操作，其过程分为两阶段：第一阶段，使用 new 在堆上寻找可用内存，分配给对象；第二阶段，调用构造函数生成对象。将 new 操作设置为私有，那么第一阶段就无法完成，就不能够在堆上生成对象。</p></blockquote><h3 id=nullptr调用成员函数可以吗？为什么？><a href=#nullptr调用成员函数可以吗？为什么？ class=headerlink title=nullptr调用成员函数可以吗？为什么？></a>nullptr调用成员函数可以吗？为什么？</h3><blockquote><p>能调用<code>不涉及访问成员变量的函数</code>，若该函数访问了成员变量，则报错。</p></blockquote><blockquote><p>原因：因为在<code>编译时对象</code>就绑定了<code>函数地址</code>，和指针空不空没关系。</p></blockquote><blockquote><p><code>答案解析</code></p></blockquote><figure class="highlight plaintext"><table><tr><td class=code><pre><span class=line>//给出实例  </span><br><span class=line>class animal&#123;  </span><br><span class=line>public:  </span><br><span class=line>    void sleep()&#123; cout &lt;&lt; &quot;animal sleep&quot; &lt;&lt; endl; &#125;  </span><br><span class=line>    void breathe()&#123; cout &lt;&lt; &quot;animal breathe haha&quot; &lt;&lt; endl; &#125;  </span><br><span class=line>&#125;;  </span><br><span class=line>class fish :public animal&#123;  </span><br><span class=line>public:  </span><br><span class=line>    void breathe()&#123; cout &lt;&lt; &quot;fish bubble&quot; &lt;&lt; endl; &#125;  </span><br><span class=line>&#125;;  </span><br><span class=line>int main()&#123;  </span><br><span class=line>    animal *pAn=nullptr; //不是虚函数，编译期间就绑定了函数地址，这个一个animal类型的指针，不管指向哪里。调用成员函数的时候都能找到函数地址  </span><br><span class=line>    pAn-&gt;breathe();   // 输出：animal breathe haha  </span><br><span class=line>    fish *pFish = nullptr;//同理，编译器就绑定了地址  </span><br><span class=line>    pFish-&gt;breathe(); // 输出：fish bubble  </span><br><span class=line>    return 0;  </span><br><span class=line>&#125;</span><br></pre></td></tr></table></figure><blockquote><p>原因：因为在<code>编译时对象</code>就绑定了<code>函数地址</code>，和指针空不空没关系。</p></blockquote><h3 id=friend-友元类和友元函数><a href=#friend-友元类和友元函数 class=headerlink title="friend 友元类和友元函数"></a>friend 友元类和友元函数</h3><ul><li>能访问私有成员</li><li>破坏封装性</li><li>友元关系不可传递</li><li>友元关系的单向性</li><li>友元声明的形式及数量不受限制</li></ul><h3 id=成员初始化列表><a href=#成员初始化列表 class=headerlink title=成员初始化列表></a>成员初始化列表</h3><blockquote><p>好处</p></blockquote><ul><li>更高效：少了一次调用默认构造函数的过程。</li><li>有些场合必须要用初始化列表：<ol><li>常量成员，因为常量只能初始化不能赋值，所以必须放在初始化列表里面</li><li>引用类型，引用必须在定义的时候初始化，并且不能重新赋值，所以也要写在初始化列表里面</li><li>没有默认构造函数的类类型，因为使用初始化列表可以不必调用默认构造函数来初始化</li></ol></li></ul><h3 id=initializer-list-列表初始化（c-11）><a href=#initializer-list-列表初始化（c-11） class=headerlink title="initializer_list 列表初始化（c++11）"></a>initializer_list 列表初始化（c++11）</h3><blockquote><p>用花括号初始化器列表初始化一个对象，其中对应构造函数接受一个</p></blockquote><figure class="highlight plaintext"><table><tr><td class=code><pre><span class=line>std::initializer_list</span><br></pre></td></tr></table></figure><p>参数.</p><blockquote><p>initializer_list 使用</p></blockquote><figure class="highlight plaintext"><table><tr><td class=code><pre><span class=line>#include &lt;iostream&gt;  </span><br><span class=line>#include &lt;vector&gt;  </span><br><span class=line>#include &lt;initializer_list&gt;  </span><br><span class=line></span><br><span class=line>template &lt;class T&gt;  </span><br><span class=line>struct S &#123;  </span><br><span class=line>    vector&lt;T&gt; v;  </span><br><span class=line>    S(initializer_list&lt;T&gt; L) : v(L) &#123;  </span><br><span class=line>         cout &lt;&lt; &quot;constructed with a &quot; &lt;&lt; L.size() &lt;&lt; &quot;-element list\\n&quot;;  </span><br><span class=line>    &#125;  </span><br><span class=line>    void append(initializer_list&lt;T&gt; L) &#123;  </span><br><span class=line>        v.insert(v.end(), L.begin(), L.end());  </span><br><span class=line>    &#125;  </span><br><span class=line>    pair&lt;const T*, size_t&gt; c_arr() const &#123;  </span><br><span class=line>        return &#123;&amp;v[0], v.size()&#125;;  // 在 return 语句中复制列表初始化  </span><br><span class=line>                                   // 这不使用 std::initializer_list  </span><br><span class=line>    &#125;  </span><br><span class=line>&#125;;  </span><br><span class=line></span><br><span class=line>template &lt;typename T&gt;  </span><br><span class=line>void templated_fn(T) &#123;&#125;  </span><br><span class=line></span><br><span class=line>int main()  </span><br><span class=line>&#123;  </span><br><span class=line>    S&lt;int&gt; s = &#123;1, 2, 3, 4, 5&#125;; // 复制初始化  </span><br><span class=line>    s.append(&#123;6, 7, 8&#125;);      // 函数调用中的列表初始化  </span><br><span class=line></span><br><span class=line>    cout &lt;&lt; &quot;The vector size is now &quot; &lt;&lt; s.c_arr().second &lt;&lt; &quot; ints:\\n&quot;;  </span><br><span class=line></span><br><span class=line>    for (auto n : s.v)  </span><br><span class=line>        cout &lt;&lt; n &lt;&lt; &#x27; &#x27;;  </span><br><span class=line>    cout &lt;&lt; &#x27;\\n&#x27;;  </span><br><span class=line></span><br><span class=line>    cout &lt;&lt; &quot;Range-for over brace-init-list: \\n&quot;;  </span><br><span class=line></span><br><span class=line>    for (int x : &#123;-1, -2, -3&#125;) // auto 的规则令此带范围 for 工作  </span><br><span class=line>        cout &lt;&lt; x &lt;&lt; &#x27; &#x27;;  </span><br><span class=line>    cout &lt;&lt; &#x27;\\n&#x27;;  </span><br><span class=line></span><br><span class=line>    auto al = &#123;10, 11, 12&#125;;   // auto 的特殊规则  </span><br><span class=line></span><br><span class=line>    cout &lt;&lt; &quot;The list bound to auto has size() = &quot; &lt;&lt; al.size() &lt;&lt; &#x27;\\n&#x27;;  </span><br><span class=line></span><br><span class=line>//    templated_fn(&#123;1, 2, 3&#125;); // 编译错误！“ &#123;1, 2, 3&#125; ”不是表达式，  </span><br><span class=line>                             // 它无类型，故 T 无法推导  </span><br><span class=line>    templated_fn&lt;initializer_list&lt;int&gt;&gt;(&#123;1, 2, 3&#125;); // OK  </span><br><span class=line>    templated_fn&lt;vector&lt;int&gt;&gt;(&#123;1, 2, 3&#125;);           // 也 OK  </span><br><span class=line>&#125;</span><br></pre></td></tr></table></figure><h3 id=面向对象-1><a href=#面向对象-1 class=headerlink title=面向对象></a>面向对象</h3><blockquote><p>面向对象程序设计（Object-oriented programming，OOP）是种具有对象概念的程序编程典范，同时也是一种程序开发的抽象方针。</p></blockquote><blockquote><p>面向对象三大特征 —— 封装、继承、多态</p></blockquote><h3 id=封装><a href=#封装 class=headerlink title=封装></a>封装</h3><blockquote><p>把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。关键字：public, protected, private。不写默认为 private。</p></blockquote><ul><li><code>public</code> 成员：可以被任意实体访问</li><li><code>protected</code> 成员：只允许被子类及本类的成员函数访问</li><li><code>private</code> 成员：只允许被本类的成员函数、友元类或友元函数访问</li></ul><h3 id=抽象类、接口类、聚合类><a href=#抽象类、接口类、聚合类 class=headerlink title=抽象类、接口类、聚合类></a>抽象类、接口类、聚合类</h3><ul><li><blockquote><p>抽象类：含有纯虚函数的类</p></blockquote></li><li><blockquote><p>接口类：仅含有纯虚函数的抽象类</p></blockquote></li><li><blockquote><p>聚合类：用户可以直接访问其成员，并且具有特殊的初始化语法形式。满足如下特点：</p></blockquote><ul><li><blockquote><p>所有成员都是 public</p></blockquote></li><li><blockquote><p>没有定义任何构造函数</p></blockquote></li><li><blockquote><p>没有类内初始化</p></blockquote></li><li><blockquote><p>没有基类，也没有 virtual 函数</p></blockquote></li></ul></li></ul><h3 id=仿函数-函数对象><a href=#仿函数-函数对象 class=headerlink title=仿函数(函数对象)></a>仿函数(函数对象)</h3><blockquote><p><code>参考回答</code></p></blockquote><ul><li>重载<code>函数调用操作符</code>的类，其对象常称为<code>函数对象</code></li><li><code>函数对象</code>使用重载的()时，行为类似函数调用，也叫<code>仿函数</code></li></ul><ol><li>仿函数（functor）又称为函数对象（function object）是一个能行使函数功能的<code>类</code>。仿函数的语法几乎和我们普通的函数调用一样，不过作为仿函数的类，都必须重载operator()运算符，举个例子：</li></ol><figure class="highlight plaintext"><table><tr><td class=code><pre><span class=line>class Func&#123;  </span><br><span class=line>public:              //第一个const说明形参不可以改变  </span><br><span class=line>    void operator() (const string&amp; str) const &#123;  </span><br><span class=line>        cout&lt;&lt;str&lt;&lt;endl;         //第二个说明这是常成员函数，不得修改类中任何数据成员  </span><br><span class=line>    &#125;   //重载（）运算符  </span><br><span class=line>&#125;;  </span><br><span class=line></span><br><span class=line>Func myFunc; //myFunc称为函数对象  </span><br><span class=line>myFunc(&quot;helloworld!&quot;);  </span><br><span class=line></span><br><span class=line>&gt;&gt;&gt;helloworld!</span><br></pre></td></tr></table></figure><ol><li><blockquote><p>仿函数既能想普通函数一样传入给定数量的参数，还能存储或者处理更多我们需要的有用信息。我们可以举个例子：</p></blockquote><blockquote><p>假设有一个vector，你的任务是统计长度小于5的string的个数，如果使用count_if函数的话，你的代码可能长成这样：</p></blockquote><figure class="highlight plaintext"><table><tr><td class=code><pre><span class=line>bool LengthIsLessThanFive(const string&amp; str) &#123;  </span><br><span class=line>    return str.length()&lt;5;      </span><br><span class=line>&#125;  </span><br><span class=line>int res=count_if(vec.begin(), vec.end(), LengthIsLessThanFive);</span><br></pre></td></tr></table></figure><blockquote><p>其中count_if函数的第三个参数是一个函数指针，返回一个bool类型的值。一般的，如果需要将特定的阈值长度也传入的话，我们可能将函数写成这样：</p></blockquote><figure class="highlight plaintext"><table><tr><td class=code><pre><span class=line>bool LenthIsLessThan(const string&amp; str, int len) &#123;  </span><br><span class=line>    return str.length()&lt;len;  </span><br><span class=line>&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这个函数看起来比前面一个版本更具有一般性，但是他不能满足count_if函数的参数要求：count_if要求的是unary function（仅带有一个参数）作为它的最后一个参数。如果我们使用仿函数，是不是就豁然开朗了呢：</p></blockquote><figure class="highlight plaintext"><table><tr><td class=code><pre><span class=line>class ShorterThan &#123;  </span><br><span class=line>public:  </span><br><span class=line>    explicit ShorterThan(int maxLength) : length(maxLength) &#123;&#125;  </span><br><span class=line>    bool operator() (const string&amp; str) const &#123;  </span><br><span class=line>        return str.length() &lt; length;  </span><br><span class=line>    &#125;  </span><br><span class=line>private:  </span><br><span class=line>    const int length;  </span><br><span class=line>&#125;;</span><br></pre></td></tr></table></figure></li></ol><h3 id=类模板和模板类的区别><a href=#类模板和模板类的区别 class=headerlink title=类模板和模板类的区别></a>类模板和模板类的区别</h3><blockquote><p><code>参考回答</code></p></blockquote><ol><li>类模板是模板的定义，不是一个实实在在的类，定义中用到通用类型参数</li><li>模板类是实实在在的类定义，是类模板的实例化。类定义中参数被实际类型所代替。</li></ol><blockquote><p><code>答案解析</code></p></blockquote><ol><li><blockquote><p>类模板的类型参数可以有一个或多个，每个类型前面都必须加class，如template &lt;class T1,class T2&gt;class someclass{…};在定义对象时分别代入实际的类型名，如 someclass&lt;int,double&gt; obj;</p></blockquote></li><li><blockquote><p>和使用类一样，使用类模板时要注意其作用域，只能在其有效作用域内用它定义对象。</p></blockquote></li><li><blockquote><p>模板可以有层次，一个类模板可以作为基类，派生出派生模板类。</p></blockquote></li></ol><h2 id=内存相关><a href=#内存相关 class=headerlink title=内存相关></a>内存相关</h2><h3 id=程序section><a href=#程序section class=headerlink title=程序section></a>程序section</h3><blockquote><p><code>参考回答</code></p></blockquote><blockquote><p><img src=https://uploadfiles.nowcoder.com/images/20220225/4107856_1645788015668/798C7A2D023204559B62F88B54E35CBB alt=img></p></blockquote><blockquote><p><code>一个程序有哪些section：</code></p></blockquote><blockquote><p>如上图，<code>从低地址到高地址，一个程序由代码段、数据段、BSS段、堆、共享区、栈等</code>组成。</p></blockquote><ol><li><blockquote><p><code>代码段：</code>存放程序执行代码的一块内存区域。只读，代码段的头部还会包含一些只读的常数变量。</p></blockquote></li><li><blockquote><p><code>数据段：</code>存放程序中已初始化的全局变量和静态变量的一块内存区域。</p></blockquote></li><li><blockquote><p><code>BSS</code> 段：存放程序中未初始化的全局变量和静态变量的一块内存区域。</p></blockquote></li><li><blockquote><p>可执行程序在<code>运行时</code>又会多出两个区域：堆区和栈区。</p></blockquote><blockquote><p><code>堆区：</code>动态申请内存用。堆从低地址向高地址增长。</p></blockquote><blockquote><p><code>栈区：</code>存储局部变量、函数参数值。栈从高地址向低地址增长。是一块连续的空间。</p></blockquote></li><li><blockquote><p>最后还有一个<code>共享区</code>，位于堆和栈之间。</p></blockquote></li></ol><h3 id=内存分区><a href=#内存分区 class=headerlink title=内存分区></a>内存分区</h3><blockquote><p>![](assets&#x2F;截屏2022-04-18 23.58.32.png)</p></blockquote><blockquote><p><img src=/assets/1545017602518.png alt=1545017602518></p></blockquote><ul><li>代码区：存放函数体的二进制代码，由操作系统进行管理的</li><li>全局区：存放全局变量和静态变量以及常量（字符串常量也在这）</li><li>栈区：由编译器自动分配释放, 存放函数的参数值,局部变量等</li><li>堆区：由程序员分配和释放,若程序员不释放,程序结束时由操作系统回收</li></ul><h3 id=栈和堆><a href=#栈和堆 class=headerlink title=栈和堆></a>栈和堆</h3><ul><li>申请方式不同<ul><li>栈由系统自动分配，自动释放堆手动申请，手动释放</li></ul></li><li>申请大小限制不同。<ul><li>栈顶和栈底是之前预设好的，栈是向栈底扩展，是一块连续的内存区域，大小固定，在windows下一般为1M或者2M，可以通过ulimit -a查看，由ulimit -s修改。</li><li>堆向高地址扩展，是不连续的内存区域，大小可以灵活调整。堆申请无限制，取决于虚拟内存的大小，32位系统理论上为4GB</li></ul></li><li>申请效率不同。<ul><li>栈由系统分配，速度快，不会有碎片。</li><li>堆由程序员分配，速度慢，且会有碎片。</li></ul></li><li><code>堆栈缓存方式不同</code>。<ul><li>栈使用的是一级缓存， 它们通常都是被调用时处于存储空间中，调用完毕立即释放；堆则是存放在二级缓存中，速度要慢些。</li></ul></li><li><code>堆栈数据结构不同</code>。<ul><li>堆类似数组结构；栈类似栈结构，先进后出。</li></ul></li></ul><blockquote><p>栈空间默认是4M, 堆区一般是 1G - 4G（取决于虚拟内存的大小）</p></blockquote><h3 id=内存分配和管理><a href=#内存分配和管理 class=headerlink title=内存分配和管理></a>内存分配和管理</h3><blockquote><p>malloc、calloc、realloc、alloca</p></blockquote><ol><li>malloc：申请指定字节数的内存。申请到的内存中的初始值不确定。</li><li>calloc：为指定长度的对象，分配能容纳其指定个数的内存。申请到的内存的每一位（bit）都初始化为 0。</li><li>realloc：更改以前分配的内存长度（增加或减少）。当增加长度时，可能需将以前分配区的内容移到另一个足够大的区域，而新增区域内的初始值则不确定。</li><li>alloca：在栈上申请内存。程序在出栈的时候，会自动释放内存。但是需要注意的是，alloca 不具可移植性, 而且在没有传统堆栈的机器上很难实现。alloca 不宜使用在必须广泛移植的程序中。C99 中支持变长数组 (VLA)，可以用来替代 alloca。</li></ol><h3 id=内存泄露><a href=#内存泄露 class=headerlink title=内存泄露></a>内存泄露</h3><blockquote><p>简单地说就是申请了一块内存空间，使用完毕后没有释放掉。</p></blockquote><ul><li>new和malloc申请资源使用后，没有用delete和free释放；</li><li>子类继承父类时，父类析构函数不是虚函数。</li></ul><blockquote><p><code>如何避免？</code></p></blockquote><blockquote><p>第一：良好的编码习惯，使用了内存分配的函数，一旦使用完毕,要记得使用其相应的函数释放掉。</p></blockquote><blockquote><p>第二：将分配的内存的指针以链表的形式自行管理，使用完毕之后从链表中删除，程序结束时可检查改链表。</p></blockquote><blockquote><p>第三：使用智能指针。</p></blockquote><blockquote><p>第四：一些常见的工具插件，如ccmalloc、Dmalloc、Leaky、Valgrind等等。</p></blockquote><h3 id=C-中内存对齐的使用场景><a href=#C-中内存对齐的使用场景 class=headerlink title=C++中内存对齐的使用场景></a>C++中内存对齐的使用场景</h3><blockquote><p><code>参考回答</code></p></blockquote><blockquote><p>内存对齐应用于三种数据类型中：<code>struct/class/union</code></p></blockquote><blockquote><p>struct&#x2F;class&#x2F;union内存对齐原则有四个：</p></blockquote><ol><li><blockquote><p><code>数据成员对齐规则</code>：结构(struct)或联合(union)的数据成员，第一个数据成员放在offset为0的地方，以后每个数据成员存储的起始位置要从该成员大小或者成员的子成员大小的整数倍开始。</p></blockquote></li><li><blockquote><p><code>结构体作为成员</code>:如果一个结构里有某些结构体成员,则结构体成员要从其内部最宽基本类型成员的整数倍地址开始存储。(struct a里存有struct b,b里有char,int ,double等元素,那b应该从8的整数倍开始存储)。</p></blockquote></li><li><blockquote><p>收尾工作:结构体的总大小，也就是sizeof的结果，必须是其内部最大成员的最宽基本类型成员的整数倍。不足的要补齐。(基本类型不包括struct&#x2F;class&#x2F;uinon)。</p></blockquote></li><li><blockquote><p>sizeof(union)，以结构里面size最大元素为union的size，如联合里面有double，int ，char三种类型，union的大小为8B，因为在某一时刻，union只有一个成员真正存储于该地址。</p></blockquote></li><li><blockquote><p><code>什么是内存对齐？</code></p></blockquote><blockquote><p>那么什么是字节对齐？在C语言中，结构体是一种复合数据类型，其构成元素既可以是基本数据类型（如int、long、float等）的变量，也可以是一些复合数据类型（如数组、结构体、联合体等）的数据单元。在结构体中，<code>编译器为结构体的每个成员按其自然边界（alignment）分配空间。</code>各个成员按照它们被声明的顺序在内存中顺序存储，第一个成员的地址和整个结构体的地址相同。</p></blockquote><blockquote><p>为了使CPU能够对变量进行快速的访问，变量的起始地址应该具有某些特性，<code>即所谓的对齐，比如4字节的int型，其起始地址应该位于4字节的边界上，即起始地址能够被4整除</code>，也即对齐跟数据在内存中的位置有关。如果一个变量的内存地址正好位于它长度的整数倍，他就被称做自然对齐。</p></blockquote><blockquote><p>比如在32位cpu下，假设一个整型变量的地址为0x00000004(为4的倍数)，那它就是自然对齐的，而如果其地址为0x00000002（非4的倍数）则是非对齐的。现代计算机中内存空间都是按照byte划分的，从理论上讲似乎对任何类型的变量的访问可以从任何地址开始，但实际情况是在访问特定类型变量的时候经常在特定的内存地址访问，这就需要各种类型数据按照一定的规则在空间上排列，而不是顺序的一个接一个的排放，这就是对齐。</p></blockquote></li><li><blockquote><p><code>为什么要字节对齐？</code></p></blockquote><blockquote><p>需要字节对齐的根本原因在于CPU访问数据的效率问题。假设上面整型变量的地址不是自然对齐，比如为0x00000002，则CPU如果取它的值的话需要访问两次内存，第一次取从0x00000002-0x00000003的一个short，第二次取从0x00000004-0x00000005的一个short然后组合得到所要的数据，如果变量在0x00000003地址上的话则要访问三次内存，第一次为char，第二次为short，第三次为char，然后组合得到整型数据。</p></blockquote><blockquote><p>而如果变量在自然对齐位置上，则只要一次就可以取出数据。一些系统对对齐要求非常严格，比如sparc系统，如果取未对齐的数据会发生错误，而在x86上就不会出现错误，只是效率下降。</p></blockquote><blockquote><p>各个硬件平台对存储空间的处理上有很大的不同。一些平台对某些特定类型的数据只能从某些特定地址开始存取。比如有些平台每次读都是从偶地址开始，如果一个int型（假设为32位系统）如果存放在偶地址开始的地方，那么一个读周期就可以读出这32bit，而如果存放在奇地址开始的地方，就需要2个读周期，并对两次读出的结果的高低字节进行拼凑才能得到该32bit数据。显然在读取效率上下降很多。</p></blockquote></li><li><blockquote><p><code>字节对齐实例</code></p></blockquote><figure class="highlight plaintext"><table><tr><td class=code><pre><span class=line>union example &#123;  </span><br><span class=line>  int a[5];  //20字节  </span><br><span class=line>  char b; //一字节  </span><br><span class=line>  double c;   //8字节  </span><br><span class=line>&#125;;     </span><br><span class=line></span><br><span class=line>int result = sizeof(example);       </span><br><span class=line>/* 如果以最长20字节为准，内部double占8字节，这段内存的地址0x00000020并不是double的整数倍，只有当最小为0x00000024时可以满足整除double（8Byte）同时又可以容纳int a[5]的大小，所以正确的结果应该是result=24 */    </span><br><span class=line></span><br><span class=line>struct example &#123;      </span><br><span class=line>  int a[5];     //如果改成a[4]，char扩充7字节，结果也为32  </span><br><span class=line>  char b;    </span><br><span class=line>  double c;     </span><br><span class=line>&#125;test_struct;   </span><br><span class=line>int result = sizeof(test_struct);    </span><br><span class=line></span><br><span class=line>/* 如果我们不考虑字节对齐，那么内存地址0x0021不是double（8Byte）的整数倍，所以需要字节对齐，那么此时满足是double（8Byte）的整数倍的最小整数是0x0024，说明此时char b对齐int扩充了三个字节。所以最后的结果是result=32 */    </span><br><span class=line></span><br><span class=line>struct example &#123;    </span><br><span class=line>  char b;     </span><br><span class=line>  double c;      </span><br><span class=line>  int a;    </span><br><span class=line>&#125;test_struct;    </span><br><span class=line>int result = sizeof(test_struct);   </span><br><span class=line></span><br><span class=line>/* 字节对齐除了内存起始地址要是数据类型的整数倍以外，还要满足一个条件，那就是占用的内存空间大小需要是结构体中占用最大内存空间的类型的整数倍，所以20不是double（8Byte）的整数倍，我们还要扩充四个字节，最后的结果是result=24 */  </span><br></pre></td></tr></table></figure></li></ol><h3 id=大端小端><a href=#大端小端 class=headerlink title=大端小端></a>大端小端</h3><ul><li><p>大端，低地址存放数据的高位，高地址存放数据的地位 ，<strong>网络通信</strong>中使用大端</p></li><li><p>小端，低地址存储数据地位，高地址存储数据高位，<strong>计算机内部</strong>一般为小端存储</p><p>如0x12345678;</p><p>大端为12，34，56，78</p><p>小端为78，56，34，12（低地址到高地址）</p></li><li><p>如何判断？</p></li></ul><figure class="highlight c++"><table><tr><td class=code><pre><span class=line><span class=comment>//法一</span></span><br><span class=line><span class=keyword>union</span> <span class="title class_">s</span>&#123;</span><br><span class=line>  <span class=type>int</span> a;</span><br><span class=line>  <span class=type>char</span> b;</span><br><span class=line>&#125;</span><br><span class=line>s.a = <span class=number>0x12345678</span>  </span><br><span class=line><span class=keyword>if</span>(s.b == <span class=number>0x12</span>)&#123;         <span class=comment>//或者用 cout &lt;&lt; hex &lt;&lt; (int)s.b &lt;&lt; endl;</span></span><br><span class=line>  cout &lt;&lt; <span class=string>&quot;大端&quot;</span> &lt;&lt; endl;  <span class=comment>//hex输出16进制，（int）转整型</span></span><br><span class=line>&#125;													<span class=comment>//输出78为小端，输出12为大端</span></span><br><span class=line><span class=keyword>else</span> &#123;</span><br><span class=line>  cout &lt;&lt; <span class=string>&quot;小端&quot;</span> &lt;&lt; endl;</span><br><span class=line>&#125;</span><br><span class=line></span><br><span class=line><span class=comment>//法二，推荐</span></span><br><span class=line><span class=type>int</span> a = <span class=number>48</span>;</span><br><span class=line><span class=type>char</span> * b = (<span class=type>char</span> *)&amp;a <span class=comment>//强制类型转换</span></span><br><span class=line>cout &lt;&lt; *b &lt;&lt;endl; <span class=comment>//如果输出0，说明小端，否则大端</span></span><br><span class=line><span class=comment>//ascii码字符0对应48，即如果存放的为48，输出字符的话对应为0；</span></span><br></pre></td></tr></table></figure><h2 id=基础语法><a href=#基础语法 class=headerlink title=基础语法></a>基础语法</h2><h3 id=双引号””和尖括号-lt-gt-的区别><a href=#双引号””和尖括号-lt-gt-的区别 class=headerlink title=双引号””和尖括号&lt;&gt;的区别></a>双引号””和尖括号&lt;&gt;的区别</h3><blockquote><p><code>参考回答</code></p></blockquote><blockquote><p>（1）尖括号&lt;&gt;的头文件是<code>系统文件</code>，双引号的头文件是<code>自定义文件</code>。</p></blockquote><blockquote><p>（2）&lt;&gt;：编译器设置的头文件路径–&gt;系统变量。</p></blockquote><blockquote><p>（3）双引号 ：当前头文件目录–&gt;编译器设置的头文件路径–&gt;系统变量。</p></blockquote><h3 id=数组名和字符串数组><a href=#数组名和字符串数组 class=headerlink title=数组名和字符串数组></a>数组名和字符串数组</h3><figure class="highlight c++"><table><tr><td class=code><pre><span class=line><span class=meta>#<span class=keyword>include</span> <span class=string>&lt;iostream&gt;</span>  </span></span><br><span class=line><span class=keyword>using</span> <span class=keyword>namespace</span> std;  </span><br><span class=line><span class=comment>/*数组名确实表示指向数组0号元素的地址，但这个指针很特别，  </span></span><br><span class=line><span class=comment>它的值（指针的值指的是指针所指的地址）不能被改写，能改写的仅仅是其指向的内容，  </span></span><br><span class=line><span class=comment>换句话说，数组名只能指向数组的首地址，如果有数组char a[];那么如果出现a = a+1;这是编译都通不过的错误。  </span></span><br><span class=line><span class=comment>而对于一个普通的指针是可以的，再比如有数组char a[];那么再定义一个char *p = a;  </span></span><br><span class=line><span class=comment>然后再用p = p+1是合法的，这表示让指针p指向&amp;a[1]。  </span></span><br><span class=line><span class=comment>它们的第二个区别是：每当用到数组名这个指针的时候，系统都会传入数组的信息，而普通的指针只是一个4字节的整数*/</span>  </span><br><span class=line><span class=function><span class=type>int</span> <span class=title>main</span><span class=params>()</span> </span>&#123;  </span><br><span class=line>	<span class=type>int</span> a[] = &#123; <span class=number>1</span>,<span class=number>2</span>,<span class=number>3</span>,<span class=number>4</span>,<span class=number>5</span> &#125;;  </span><br><span class=line>	cout &lt;&lt; <span class=string>&quot;a:  &quot;</span> &lt;&lt; a &lt;&lt; endl;        <span class=comment>//数组名就是首元素的地址，故输出的就是地址  </span></span><br><span class=line>	cout &lt;&lt; <span class=string>&quot;*a:  &quot;</span> &lt;&lt; *a &lt;&lt; endl;      <span class=comment>//指向首址存放的内容，故输出的是首号元素  </span></span><br><span class=line>	cout &lt;&lt; <span class=string>&quot;&amp;a:  &quot;</span> &lt;&lt; &amp;a &lt;&lt; endl;     <span class=comment>//这里居然不报错，输出的仍然是首地址  </span></span><br><span class=line></span><br><span class=line>```c++  </span><br><span class=line><span class=type>char</span> zct[] = <span class=string>&quot;zctshuai&quot;</span>;  </span><br><span class=line>cout &lt;&lt; <span class=string>&quot;zct:  &quot;</span> &lt;&lt; zct &lt;&lt;endl;    <span class=comment>/*本以为会输出首址，哪知道输出的是字符串。  </span></span><br><span class=line><span class=comment></span></span><br><span class=line><span class=comment>C++的**重载**机制：对于一维字符数组名的输出，编译器会默认你想输出的是数组里的内容，而对于其他类型数组名的输出，如整形数组，编译器默认的输出是数组首元素的地址。  </span></span><br><span class=line><span class=comment></span></span><br><span class=line><span class=comment>注意，对于二维数组又有所不同，如果定义的是二维数组，不管是不是字符数组，输出数组名得到的都是地址。另外，不管字符数组还是别的类型数组，不管是一维还是二维，在C++中都不会进行数组越界检查，所以越界访问数组时编译器不会报错。*/</span>  </span><br><span class=line></span><br><span class=line>cout &lt;&lt; <span class=string>&quot;sizeof(zct):  &quot;</span> &lt;&lt; <span class=built_in>sizeof</span>(zct) &lt;&lt; endl;      <span class=comment>//此时输出的是元素总的个数  </span></span><br><span class=line></span><br><span class=line>cout &lt;&lt; <span class=string>&quot;sizeof(zct[0])&quot;</span> &lt;&lt; <span class=built_in>sizeof</span>(zct[<span class=number>0</span>]) &lt;&lt; endl;   <span class=comment>//输出的长度肯定是1，这不用说了  </span></span><br><span class=line></span><br><span class=line>cout &lt;&lt; <span class=string>&quot;字符数组个数：  &quot;</span> &lt;&lt; <span class=built_in>sizeof</span>(zct) / <span class=built_in>sizeof</span>(zct[<span class=number>0</span>]) &lt;&lt; endl;  <span class=comment>//通常我们求一个数组的元素个数就这样操作  </span></span><br><span class=line></span><br><span class=line>cout &lt;&lt; <span class=string>&quot;*zct:  &quot;</span> &lt;&lt; *zct &lt;&lt; endl;       <span class=comment>/*神奇吧，此时输出的又是第一个元素，再次证明其实数组名称对应的都是首址，只是针对一维字符数组，编译器会默认你想输出的是数组里的内容*/</span>  </span><br><span class=line></span><br><span class=line>cout &lt;&lt; <span class=string>&quot;&amp;zct:  &quot;</span> &lt;&lt; &amp;zct &lt;&lt; endl;       <span class=comment>//尽管“zct”值的还是地址，但是这样加了&amp;输出还是地址  </span></span><br><span class=line></span><br><span class=line><span class=type>char</span> *p = zct;  </span><br><span class=line>cout &lt;&lt; <span class=string>&quot;p:  &quot;</span> &lt;&lt; p &lt;&lt; endl;        <span class=comment>//这个时候p是指针变量，但是p是用一维字符数组来定义的，所以编译器还是默认你想输出数组里的内容  </span></span><br><span class=line></span><br><span class=line>cout &lt;&lt; <span class=string>&quot;sizeof(p):  &quot;</span> &lt;&lt; <span class=built_in>sizeof</span>(p) &lt;&lt; endl;    <span class=comment>//与 sizeof（zct）= 9 区分啊，很重要。原因在代码开头说明  </span></span><br><span class=line></span><br><span class=line><span class=type>int</span> *q = a;  </span><br><span class=line>cout &lt;&lt; <span class=string>&quot;q:  &quot;</span> &lt;&lt; q &lt;&lt; endl;     <span class=comment>//为何输出地址不用我再讲了吧  </span></span><br><span class=line>cout &lt;&lt; <span class=string>&quot;sizeof(q):  &quot;</span> &lt;&lt; <span class=built_in>sizeof</span>(q) &lt;&lt; endl;  </span><br><span class=line></span><br><span class=line><span class=built_in>system</span>(<span class=string>&quot;pause&quot;</span>);  </span><br><span class=line><span class=keyword>return</span> <span class=number>0</span>;  </span><br><span class=line>&#125;</span><br></pre></td></tr></table></figure><h3 id=区别以下指针类型><a href=#区别以下指针类型 class=headerlink title=区别以下指针类型></a>区别以下指针类型</h3><figure class="highlight c++"><table><tr><td class=code><pre><span class=line><span class=type>int</span> *p[<span class=number>10</span>]  <span class=comment>//创建十个int类型得指针，可以写成int * p[10] 为指针数组</span></span><br><span class=line>  </span><br><span class=line><span class=built_in>int</span> (*p)[<span class=number>10</span>] <span class=comment>//（*p）为解引用，表示创建一个int类型的数组（长度为10），p指向数组首地址；等价于 int * p = new int[10];一般不这么用</span></span><br><span class=line>  </span><br><span class=line><span class=function><span class=type>int</span> *<span class=title>p</span><span class=params>(<span class=type>int</span>)</span> <span class=comment>//函数声明，返回值为int * 类型（返回值为int类型的指针）</span></span></span><br><span class=line><span class=function> </span></span><br><span class=line><span class=function><span class=title>int</span> <span class=params>(*p)</span><span class=params>(<span class=type>int</span>)</span> <span class=comment>//函数指针，p为指向参数为int类型的函数的地址</span></span></span><br><span class=line><span class=function><span class=comment>//如 int fun(int a); int (*p)(int) = fun;  </span></span></span><br><span class=line><span class=function><span class=comment>// 特别注意，函数返回值什么类型就用什么类型指针接受，如</span></span></span><br><span class=line><span class=function><span class=comment>// void fun(int a); void (*p)(int) = fun; </span></span></span><br></pre></td></tr></table></figure><h3 id=const><a href=#const class=headerlink title=const></a>const</h3><ol><li>修饰变量，说明该变量不可以被改变；</li><li>修饰指针，分为指向常量的指针（pointer to const）和自身是常量的指针（常量指针，const pointer）；</li><li>修饰引用，指向常量的引用（reference to const），用于形参类型，即避免了拷贝，又避免了函数对值的修改；(引用相当于起别名，所以不需要开辟空间，而且值还不可以修改 )</li><li>修饰普通函数，有三种情况，修饰返回值，说明返回值不可以修改；修饰形参，说明形参不可以改变；在函数最后加const</li><li>修饰成员变量，说明该成员变量的值不可以改变，只能在类内赋值或者初始化列表赋值，构造函数不可以赋值</li><li>修饰成员函数，称为常成员函数，说明该成员函数内不能修改成员变量的值</li><li>修饰对象，称为常对象，常对象只能调用常成员函数</li></ol><figure class="highlight plaintext"><table><tr><td class=code><pre><span class=line>//修饰变量  </span><br><span class=line>    const int a; //报错，定义的时候必须赋值  </span><br><span class=line>    const int b = 10; //正确  </span><br><span class=line>    b = 20; //b的值不可以改变  </span><br><span class=line></span><br><span class=line>    //修饰指针  </span><br><span class=line>    const int * p; //正确，可以先不赋值；p指向的值不可以变，指向的地址可以变  </span><br><span class=line>    int * const p1; //错误，定义的时候必须赋值；且p1指向的地址不可修改  </span><br><span class=line></span><br><span class=line>    //修饰引用  </span><br><span class=line>    const int &amp;c; //报错，需要赋值，如const int &amp;c = a；  </span><br><span class=line>    int d = 10;  </span><br><span class=line>    const int &amp;c1 = d; //正确，和int const &amp;c1 = d 一个意思；  </span><br><span class=line>    //const修饰引用一般用于函数的形参，既避免了拷贝，又能防止对实参的修改；  </span><br><span class=line></span><br><span class=line>    //修饰普通函数  </span><br><span class=line>    const int fun1(); // 修饰返回值，说明返回值不可以修改   </span><br><span class=line>    int fun(const int a);//修饰形参，说明形参不可以改变  </span><br><span class=line>    int fun () const;  //这个是类内成员函数  </span><br><span class=line></span><br><span class=line>// 类  </span><br><span class=line>class A  </span><br><span class=line>&#123;  </span><br><span class=line>private:  </span><br><span class=line>    const int a;                // 常对象成员，只能使用初始化列表或者类内初始化  </span><br><span class=line>public:  </span><br><span class=line>    // 构造函数  </span><br><span class=line>    A() : a(0) &#123; &#125;;	//无参  </span><br><span class=line>    A(int x) : a(x) &#123; &#125;; // 初始化列表，有参  </span><br><span class=line></span><br><span class=line>    // const可用于对重载函数的区分  </span><br><span class=line>    int getValue();             // 普通成员函数，常对象不可以调用  </span><br><span class=line>    int getValue() const;// 常成员函数，不得修改类中的任何数据成员的值  </span><br><span class=line>&#125;;  </span><br><span class=line></span><br><span class=line>void function()  </span><br><span class=line>&#123;  </span><br><span class=line>    // 对象  </span><br><span class=line>    A b;                        // 普通对象，可以调用全部成员函数  </span><br><span class=line>    const A a;                  // 常对象，只能调用常成员函数  </span><br><span class=line>    const A *p = &amp;a;            // 指针变量，指向常对象  </span><br><span class=line>    const A &amp;q = a;             // 指向常对象的引用  </span><br><span class=line></span><br><span class=line>    // 指针  </span><br><span class=line>    char greeting[] = &quot;Hello&quot;;  </span><br><span class=line>    char* p1 = greeting;                // 指针变量，指向字符数组变量  </span><br><span class=line>    const char* p2 = greeting;          // 指针变量，指向字符数组常量（const 后面是 char，说明指向的字符（char）不可改变）  </span><br><span class=line>    char* const p3 = greeting;          // 自身是常量的指针，指向字符数组变量（const 后面是 p3，说明 p3 指针自身不可改变）  </span><br><span class=line></span><br><span class=line>    const char* const p4 = greeting;    // 自身是常量的指针，指向字符数组常量  </span><br><span class=line>&#125;  </span><br><span class=line></span><br><span class=line>// 函数  </span><br><span class=line>void function1(const int Var);           // 传递过来的参数在函数内不可变  </span><br><span class=line>void function2(const char* Var);         // 参数指针所指内容为常量  </span><br><span class=line>void function3(char* const Var);         // 参数指针为常量  </span><br><span class=line>void function4(const int&amp; Var);          // 引用参数在函数内为常量  </span><br><span class=line></span><br><span class=line>// 函数返回值  </span><br><span class=line>const int function5();      // 返回一个常数  </span><br><span class=line>const int* function6();     // 返回一个指向常量的指针变量，使用：const int *p = function6();  </span><br><span class=line>int* const function7();     // 返回一个指向变量的常指针，使用：int* const p = function7();</span><br></pre></td></tr></table></figure><h3 id=const和define><a href=#const和define class=headerlink title=const和define></a>const和define</h3><p>define 宏定义，相当于字符替换 const常量声明<br>define预处理器处理 const编译器处理<br>define无类型安全检查 const有类型安全检查<br>define不分配内存 const要分配内存<br>define存储在代码段 const存储在数据段<br>define可通过 <code>#undef</code> 取消 const不可取消</p><h3 id=static关键字的作用><a href=#static关键字的作用 class=headerlink title=static关键字的作用></a>static关键字的作用</h3><blockquote><p><code>参考回答</code></p></blockquote><ol><li><code>定义全局静态变量和局部静态变量</code>：只不过全局静态变量和局部静态变量的作用域不一样； 局部静态变量只在函数内使用 ，<code>静态全局变量只能在本源文件中使用</code>；</li><li>函数<code>：在函数返回类型前加上static关键字，函数即被定义为静态函数。静态函数只能在</code>本源文件<code>中使用；</code></li><li>定义类中的静态成员变量<code>：使用静态数据成员，它既可以被当成全局变量那样去存储，但又被隐藏在类的内部。类中的static静态数据成员拥有一块单独的存储区，而不管创建了多少个该类的对象。所有这些对象的静态数据成员都</code>共享**这一块静态存储空间。</li><li>静态成员函数：修饰成员函数使得不需要生成对象就可以访问该函数，但是在 static 函数内不能访问非静态成员变量。</li><li>定义静态对象，</li></ol><blockquote><p><code>答案解析</code></p></blockquote><blockquote><p>当调用一个对象的普通成员函数时，系统会把该对象的起始地址赋给成员函数的this指针。而静态成员函数不属于任何一个对象（对象里面没有这个函数，静态函数在全局区）， 因此C++规定静态成员函数没有this指针（划重点，面试题常考）。既然它没有指向某一对象，也就无法对一个对象中的非静态成员变量进行访问（即只能访问静态成员变量）。</p></blockquote><h3 id=野指针，悬空指针><a href=#野指针，悬空指针 class=headerlink title=野指针，悬空指针></a>野指针，悬空指针</h3><ul><li><blockquote><p>野指针，指的是没有被初始化过的指针；因此，为了防止出错，对于指针初始化时都是赋值为 <code>nullptr</code>，这样在使用时编译器就会直接报错，产生非法内存访问。</p></blockquote></li><li><blockquote><p>悬空指针，指针最初指向的内存已经被释放了的一种指针。</p></blockquote></li></ul><h3 id=volatile><a href=#volatile class=headerlink title=volatile></a>volatile</h3><figure class="highlight plaintext"><table><tr><td class=code><pre><span class=line>volatile int i = 10; //精确地说就是，编译器在用到这个变量时必须每次都小心地重新读取这个变量的值，而不是使用保存在[寄存器]里的备份</span><br></pre></td></tr></table></figure><ul><li><blockquote><p>volatile 关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素（操作系统、硬件、其它线程等）更改。所以使用 volatile 告诉编译器不应对这样的对象进行优化。</p></blockquote></li><li><blockquote><p>volatile是一个特征修饰符（type specifier）.<code>volatile</code>的作用是作为指令关键字，确保本条指令不会因编译器的优化而省略，且要求每次直接读值。</p></blockquote><blockquote><p>volatile的变量是说这变量可能会被意想不到地改变，这样，编译器就不会去假设这个变量的值了。</p></blockquote></li><li><blockquote><p>volatile 关键字声明的变量，每次访问时都必须从内存中取出值（没有被 volatile 修饰的变量，可能由于编译器的优化，从 CPU 寄存器中取值）</p></blockquote></li><li><blockquote><p>const 可以是 volatile （如只读的状态寄存器）</p></blockquote></li><li><blockquote><p>指针可以是 volatile</p></blockquote></li></ul><h3 id=assert><a href=#assert class=headerlink title=assert()></a>assert()</h3><blockquote><p>断言，是宏，而非函数。assert 宏的原型定义在 <code>&lt;assert.h&gt;</code>（C）、<code>&lt;cassert&gt;</code>（C++）中，其作用是如果它的条件返回错误，则终止程序执行。可以通过定义 <code>NDEBUG</code> 来关闭 assert，但是需要在源代码的开头，<code>include &lt;assert.h&gt;</code> 之前。</p></blockquote><blockquote><p>assert() 使用</p></blockquote><figure class="highlight plaintext"><table><tr><td class=code><pre><span class=line>#define NDEBUG          // 加上这行，则 assert 不可用  </span><br><span class=line>#include &lt;assert.h&gt;  </span><br><span class=line></span><br><span class=line>assert( p != NULL );    // assert 不可用</span><br></pre></td></tr></table></figure><h3 id=pragma-pack-n><a href=#pragma-pack-n class=headerlink title="#pragma pack(n)"></a>#pragma pack(n)</h3><blockquote><p>设定结构体、联合以及类成员变量以 n 字节方式对齐</p></blockquote><blockquote><p>#pragma pack(n) 使用</p></blockquote><figure class="highlight plaintext"><table><tr><td class=code><pre><span class=line>#pragma pack(push)  // 保存对齐状态  </span><br><span class=line>#pragma pack(4)     // 设定为 4 字节对齐  </span><br><span class=line>#pragma pack(2)  //设定以2字节对齐  </span><br><span class=line>struct test  </span><br><span class=line>&#123;  </span><br><span class=line>    char m1;  </span><br><span class=line>    double m4;  </span><br><span class=line>    int m3;  </span><br><span class=line>&#125;;  </span><br><span class=line></span><br><span class=line>#pragma pack(pop)   // 恢复对齐状态</span><br></pre></td></tr></table></figure><h3 id=位域><a href=#位域 class=headerlink title=位域></a>位域</h3><figure class="highlight plaintext"><table><tr><td class=code><pre><span class=line>Bit mode: 2;    // mode 占 2 位</span><br></pre></td></tr></table></figure><blockquote><p>类可以将其普通数据成员（非静态）定义为位域（bit-field），在一个位域中含有一定数量的二进制位。当一个程序需要向其他程序或硬件设备传递二进制数据时，通常会用到位域。</p></blockquote><ul><li><blockquote><p>位域在内存中的布局是与机器有关的</p></blockquote></li><li><blockquote><p>位域的类型必须是整型或枚举类型，带符号类型中的位域的行为将因具体实现而定</p></blockquote></li><li><blockquote><p>取地址运算符（&amp;）不能作用于位域，任何指针都无法指向类的位域</p></blockquote></li></ul><h3 id=union-联合><a href=#union-联合 class=headerlink title="union 联合"></a>union 联合</h3><blockquote><p>联合（union）是一种节省空间的特殊的类，一个 union 可以有多个数据成员，但是在任意时刻只有一个数据成员可以有值。当某个成员被赋值后其他成员变为未定义状态。联合有如下特点：</p></blockquote><ul><li>默认访问控制符为 public</li><li>可以含有构造函数、析构函数</li><li>不能含有引用类型的成员</li><li>不能继承自其他类，不能作为基类</li><li>不能含有虚函数</li><li>匿名 union 在定义所在作用域可直接访问 union 成员</li><li>匿名 union 不能包含 protected 成员或 private 成员</li><li>全局匿名联合必须是静态（static）的</li></ul><blockquote><p>union 使用</p></blockquote><figure class="highlight plaintext"><table><tr><td class=code><pre><span class=line>#include&lt;iostream&gt;  </span><br><span class=line>union UnionTest &#123;  </span><br><span class=line>    UnionTest() : i(10) &#123;&#125;;  //构造函数  </span><br><span class=line>    int i;  </span><br><span class=line>    double d;  </span><br><span class=line>&#125;;  </span><br><span class=line>static union &#123;   </span><br><span class=line>    int i;  </span><br><span class=line>    double d;  </span><br><span class=line>&#125;;  </span><br><span class=line>int main() &#123;  </span><br><span class=line>    UnionTest u;  </span><br><span class=line>    union &#123;  //匿名联合  </span><br><span class=line>        int i;  </span><br><span class=line>        double d;  </span><br><span class=line>    &#125;;  </span><br><span class=line>    std::cout &lt;&lt; u.i &lt;&lt; std::endl;  // 输出 UnionTest 联合的 10  </span><br><span class=line>    ::i = 20;  </span><br><span class=line>    std::cout &lt;&lt; ::i &lt;&lt; std::endl;  // 输出全局静态匿名联合的 20  </span><br><span class=line>    i = 30;  </span><br><span class=line>    std::cout &lt;&lt; i &lt;&lt; std::endl;    // 输出局部匿名联合的 30  </span><br><span class=line>    return 0;  </span><br><span class=line>&#125;</span><br></pre></td></tr></table></figure><h3 id=enum-枚举类型><a href=#enum-枚举类型 class=headerlink title="enum 枚举类型"></a>enum 枚举类型</h3><blockquote><p>限定作用域的枚举类型</p></blockquote><figure class="highlight plaintext"><table><tr><td class=code><pre><span class=line>enum class open_modes &#123; input, output, append &#125;;</span><br></pre></td></tr></table></figure><blockquote><p>不限定作用域的枚举类型</p></blockquote><figure class="highlight plaintext"><table><tr><td class=code><pre><span class=line>enum color &#123; red, yellow, green &#125;;  </span><br><span class=line>enum &#123; floatPrec = 6, doublePrec = 10 &#125;;</span><br></pre></td></tr></table></figure><h3 id=decltype><a href=#decltype class=headerlink title=decltype></a>decltype</h3><blockquote><p>decltype 关键字用于检查实体的声明类型或表达式的类型及值分类。语法：</p></blockquote><figure class="highlight plaintext"><table><tr><td class=code><pre><span class=line>decltype ( expression )</span><br></pre></td></tr></table></figure><blockquote><p>decltype 使用</p></blockquote><figure class="highlight plaintext"><table><tr><td class=code><pre><span class=line>// 尾置返回允许我们在参数列表之后声明返回类型  </span><br><span class=line>template &lt;typename It&gt;  </span><br><span class=line>auto fcn(It beg, It end) -&gt; decltype(*beg)  </span><br><span class=line>&#123;  </span><br><span class=line>    // 处理序列  </span><br><span class=line>    return *beg;    // 返回序列中一个元素的引用  </span><br><span class=line>&#125;  </span><br><span class=line>// 为了使用模板参数成员，必须用 typename  </span><br><span class=line>template &lt;typename It&gt;  </span><br><span class=line>auto fcn2(It beg, It end) -&gt; typename remove_reference&lt;decltype(*beg)&gt;::type  </span><br><span class=line>&#123;  </span><br><span class=line>    // 处理序列  </span><br><span class=line>    return *beg;    // 返回序列中一个元素的拷贝  </span><br><span class=line>&#125;</span><br></pre></td></tr></table></figure><h3 id=智能指针><a href=#智能指针 class=headerlink title=智能指针></a>智能指针</h3><blockquote><p>C++ 标准库（STL）中</p></blockquote><blockquote><p>头文件：<code>#include &lt;memory&gt;</code></p></blockquote><blockquote><p>C++ 98</p></blockquote><figure class="highlight plaintext"><table><tr><td class=code><pre><span class=line>std::auto_ptr&lt;std::string&gt; ps (new std::string(str))；</span><br></pre></td></tr></table></figure><blockquote><p>C++ 11</p></blockquote><figure class="highlight plaintext"><table><tr><td class=code><pre><span class=line>shared_ptr</span><br><span class=line> unique_ptr</span><br><span class=line> weak_ptr</span><br><span class=line> auto_ptr（被 C++11 弃用）</span><br></pre></td></tr></table></figure><ul><li>Class shared_ptr 实现共享式拥有（shared ownership）概念。多个智能指针指向相同对象，该对象和其相关资源会在 “最后一个 reference（引用） 被销毁” 时被释放。为了在结构较复杂的情景中执行上述工作，标准库提供 weak_ptr、bad_weak_ptr 和 enable_shared_from_this 等辅助类。</li><li>Class unique_ptr 实现独占式拥有（exclusive ownership）或严格拥有（strict ownership）概念，保证同一时间内只有一个智能指针可以指向该对象。你可以移交拥有权。它对于避免内存泄漏（resource leak）——如 new 后忘记 delete ——特别有用。</li></ul><blockquote><p><code>shared_ptr</code></p></blockquote><blockquote><p>多个智能指针可以共享同一个对象，对象的最末一个拥有着有责任销毁对象，并清理与该对象相关的所有资源。</p></blockquote><ul><li>支持定制型删除器（custom deleter），可防范 Cross-DLL 问题（对象在动态链接库（DLL）中被 new 创建，却在另一个 DLL 内被 delete 销毁）、自动解除互斥锁</li></ul><blockquote><p><code>weak_ptr</code></p></blockquote><blockquote><p>weak_ptr 允许你共享但不拥有某对象，一旦最末一个拥有该对象的智能指针失去了所有权，任何 weak_ptr 都会自动成空（empty）。因此，在 default 和 copy 构造函数之外，weak_ptr 只提供 接受一个 shared_ptr 的构造函数。</p></blockquote><ul><li>可打破环状引用（cycles of references，两个其实已经没有被使用的对象彼此互指，使之看似还在 “被使用” 的状态）的问题</li></ul><blockquote><p><code>unique_ptr</code></p></blockquote><blockquote><p>unique_ptr 是 C++11 才开始提供的类型，是一种在异常时可以帮助避免资源泄漏的智能指针。采用独占式拥有，意味着可以确保一个对象和其相应的资源同一时间只被一个 pointer 拥有。一旦拥有着被销毁或编程 empty，或开始拥有另一个对象，先前拥有的那个对象就会被销毁，其任何相应资源亦会被释放。</p></blockquote><ul><li>unique_ptr 用于取代 auto_ptr</li></ul><blockquote><p><code>auto_ptr</code></p></blockquote><blockquote><p>被 c++11 弃用，原因是缺乏语言特性如 针对构造和赋值 的 <code>std::move</code> 语义，以及其他瑕疵。</p></blockquote><blockquote><p><code>auto_ptr 与 unique_ptr 比较</code></p></blockquote><ul><li>auto_ptr 可以赋值拷贝，复制拷贝后所有权转移；unqiue_ptr 无拷贝赋值语义，但实现了<code>move</code> 语义；</li><li>auto_ptr 对象不能管理数组（析构调用 <code>delete</code>），unique_ptr 可以管理数组（析构调用 <code>delete[]</code> ）；</li></ul><h3 id=强制类型转换运算符><a href=#强制类型转换运算符 class=headerlink title=强制类型转换运算符></a>强制类型转换运算符</h3><blockquote><blockquote><p>MSDN . 强制转换运算符</p></blockquote></blockquote><blockquote><p>static_cast</p></blockquote><ul><li>用于非多态类型的转换</li><li>不执行运行时类型检查（转换安全性不如 dynamic_cast）</li><li>通常用于转换数值数据类型（如 float -&gt; int）</li><li>可以在整个类层次结构中移动指针，子类转化为父类安全（向上转换），父类转化为子类不安全（因为子类可能有不在父类的字段或方法）</li></ul><blockquote><blockquote><p>向上转换是一种隐式转换。</p></blockquote></blockquote><blockquote><p>dynamic_cast</p></blockquote><ul><li>用于多态类型的转换</li><li>执行行运行时类型检查</li><li>只适用于指针或引用</li><li>对不明确的指针的转换将失败（返回 nullptr），但不引发异常</li><li>可以在整个类层次结构中移动指针，包括向上转换、向下转换</li></ul><blockquote><p>const_cast</p></blockquote><ul><li>用于删除 const、volatile 和 __unaligned 特性（如将 const int 类型转换为 int 类型 ）</li></ul><blockquote><p>reinterpret_cast</p></blockquote><ul><li>用于位的简单重新解释</li><li>滥用 reinterpret_cast 运算符可能很容易带来风险。 除非所需转换本身是低级别的，否则应使用其他强制转换运算符之一。</li><li>允许将任何指针转换为任何其他指针类型（如 <code>char*</code> 到 <code>int*</code> 或 <code>One_class*</code> 到 <code>Unrelated_class*</code> 之类的转换，但其本身并不安全）</li><li>也允许将任何整数类型转换为任何指针类型以及反向转换。</li><li>reinterpret_cast 运算符不能丢掉 const、volatile 或 __unaligned 特性。</li><li>reinterpret_cast 的一个实际用途是在哈希函数中，即，通过让两个不同的值几乎不以相同的索引结尾的方式将值映射到索引。</li></ul><blockquote><p>bad_cast</p></blockquote><ul><li>由于强制转换为引用类型失败，dynamic_cast 运算符引发 bad_cast 异常。</li></ul><blockquote><p>bad_cast 使用</p></blockquote><figure class="highlight plaintext"><table><tr><td class=code><pre><span class=line>try &#123;    </span><br><span class=line>    Circle&amp; ref_circle = dynamic_cast&lt;Circle&amp;&gt;(ref_shape);     </span><br><span class=line>&#125;    </span><br><span class=line>catch (bad_cast b) &#123;    </span><br><span class=line>    cout &lt;&lt; &quot;Caught: &quot; &lt;&lt; b.what();    </span><br><span class=line>&#125;</span><br></pre></td></tr></table></figure><h4 id=""><a href=# class=headerlink title=""></a></h4><h3 id=运行时类型信息-RTTI><a href=#运行时类型信息-RTTI class=headerlink title="运行时类型信息 (RTTI)"></a>运行时类型信息 (RTTI)</h3><blockquote><p>dynamic_cast</p></blockquote><ul><li>用于多态类型的转换</li></ul><blockquote><p>typeid</p></blockquote><ul><li>typeid 运算符允许在运行时确定对象的类型</li><li>type_id 返回一个 type_info 对象的引用</li><li>如果想通过基类的指针获得派生类的数据类型，基类必须带有虚函数</li><li>只能获取对象的实际类型</li></ul><blockquote><p>type_info</p></blockquote><ul><li>type_info 类描述编译器在程序中生成的类型信息。 此类的对象可以有效存储指向类型的名称的指针。 type_info 类还可存储适合比较两个类型是否相等或比较其排列顺序的编码值。 类型的编码规则和排列顺序是未指定的，并且可能因程序而异。</li><li>头文件：<code>typeinfo</code></li></ul><blockquote><p>typeid、type_info 使用</p></blockquote><figure class="highlight plaintext"><table><tr><td class=code><pre><span class=line>#include &lt;iostream&gt;  </span><br><span class=line>using namespace std;  </span><br><span class=line></span><br><span class=line>class Flyable                       // 能飞的  </span><br><span class=line>&#123;  </span><br><span class=line>public:  </span><br><span class=line>    virtual void takeoff() = 0;     // 起飞  </span><br><span class=line>    virtual void land() = 0;        // 降落  </span><br><span class=line>&#125;;  </span><br><span class=line>class Bird : public Flyable         // 鸟  </span><br><span class=line>&#123;  </span><br><span class=line>public:  </span><br><span class=line>    void foraging() &#123;...&#125;           // 觅食  </span><br><span class=line>    virtual void takeoff() &#123;...&#125;  </span><br><span class=line>    virtual void land() &#123;...&#125;  </span><br><span class=line>    virtual ~Bird()&#123;&#125;  </span><br><span class=line>&#125;;  </span><br><span class=line>class Plane : public Flyable        // 飞机  </span><br><span class=line>&#123;  </span><br><span class=line>public:  </span><br><span class=line>    void carry() &#123;...&#125;              // 运输  </span><br><span class=line>    virtual void takeoff() &#123;...&#125;  </span><br><span class=line>    virtual void land() &#123;...&#125;  </span><br><span class=line>&#125;;  </span><br><span class=line></span><br><span class=line>class type_info  </span><br><span class=line>&#123;  </span><br><span class=line>public:  </span><br><span class=line>    const char* name() const;  </span><br><span class=line>    bool operator == (const type_info &amp; rhs) const;  </span><br><span class=line>    bool operator != (const type_info &amp; rhs) const;  </span><br><span class=line>    int before(const type_info &amp; rhs) const;  </span><br><span class=line>    virtual ~type_info();  </span><br><span class=line>private:  </span><br><span class=line>    ...  </span><br><span class=line>&#125;;  </span><br><span class=line></span><br><span class=line>void doSomething(Flyable *obj)                 // 做些事情  </span><br><span class=line>&#123;  </span><br><span class=line>    obj-&gt;takeoff();  </span><br><span class=line></span><br><span class=line>    cout &lt;&lt; typeid(*obj).name() &lt;&lt; endl;        // 输出传入对象类型（&quot;class Bird&quot; or &quot;class Plane&quot;）  </span><br><span class=line></span><br><span class=line>    if(typeid(*obj) == typeid(Bird))            // 判断对象类型  </span><br><span class=line>    &#123;  </span><br><span class=line>        Bird *bird = dynamic_cast&lt;Bird *&gt;(obj); // 对象转化  </span><br><span class=line>        bird-&gt;foraging();  </span><br><span class=line>    &#125;  </span><br><span class=line></span><br><span class=line>    obj-&gt;land();  </span><br><span class=line>&#125;  </span><br><span class=line></span><br><span class=line>int main()&#123;  </span><br><span class=line>	Bird *b = new Bird();  </span><br><span class=line>	doSomething(b);  </span><br><span class=line>	delete b;  </span><br><span class=line>	b = nullptr;  </span><br><span class=line>	return 0;  </span><br><span class=line>&#125;</span><br></pre></td></tr></table></figure><h4 id=-1><a href=#-1 class=headerlink title=""></a></h4><h3 id=-2><a href=#-2 class=headerlink title=""></a></h3><h3 id=size-、length-、strlen-、sizeof><a href=#size-、length-、strlen-、sizeof class=headerlink title=size()、length()、strlen()、sizeof()></a>size()、length()、strlen()、sizeof()</h3><ul><li><blockquote><p>size()和length()这两个函数是用来计算string类对象或者即STL对象方法。都是计算字符串长度。</p></blockquote></li><li><blockquote><p>strlen()是函数，参数必须是字符型指针（char*），计算从开始到结束（’\0），返回的长度大小不包括’\0’，也是计算字符长度。</p></blockquote></li><li><blockquote><p>sizeof()是运算符，不能计算复杂内存分配空间大小。计算字符所占空间大小。</p></blockquote></li></ul><h3 id=malloc、free><a href=#malloc、free class=headerlink title=malloc、free></a>malloc、free</h3><blockquote><p>用于分配、释放内存</p></blockquote><blockquote><p>malloc、free 使用</p></blockquote><blockquote><p>申请内存，确认是否申请成功</p></blockquote><figure class="highlight c++"><table><tr><td class=code><pre><span class=line><span class=type>char</span> *str = (<span class=type>char</span>*) <span class=built_in>malloc</span>(<span class=number>100</span>);  </span><br><span class=line><span class=built_in>assert</span>(str != <span class=literal>nullptr</span>);</span><br></pre></td></tr></table></figure><blockquote><p>释放内存后指针置空</p></blockquote><figure class="highlight c++"><table><tr><td class=code><pre><span class=line><span class=built_in>free</span>(p);   </span><br><span class=line>p = <span class=literal>nullptr</span>;</span><br></pre></td></tr></table></figure><h3 id=new、delete><a href=#new、delete class=headerlink title=new、delete></a>new、delete</h3><figure class="highlight c++"><table><tr><td class=code><pre><span class=line><span class=keyword>new</span> / <span class=keyword>new</span>[]：完成两件事，先底层调用 malloc 分配了内存，然后调用构造函数（创建对象）。</span><br><span class=line> </span><br><span class=line>  </span><br><span class=line><span class=keyword>delete</span>/<span class=keyword>delete</span>[]：也完成两件事，先调用析构函数（清理资源），然后底层调用 free 释放空间</span><br><span class=line>  </span><br><span class=line><span class=keyword>delete</span>[] 如何确定释放多少空间，会在<span class=keyword>new</span>[]的时候多分配地址（比如多分配一个<span class=type>int</span>类型的空间），记录数组的个数</span><br></pre></td></tr></table></figure><blockquote><p>new、delete 使用</p></blockquote><blockquote><p>申请内存，确认是否申请成功</p></blockquote><figure class="highlight plaintext"><table><tr><td class=code><pre><span class=line>int main()  </span><br><span class=line>&#123;  </span><br><span class=line>    T* t = new T();     // 先内存分配 ，再构造函数  </span><br><span class=line>    delete t;           // 先析构函数，再内存释放  </span><br><span class=line>    return 0;  </span><br><span class=line>&#125;</span><br></pre></td></tr></table></figure><h3 id=new和malloc，delete和free的区别><a href=#new和malloc，delete和free的区别 class=headerlink title=new和malloc，delete和free的区别></a>new和malloc，delete和free的区别</h3><ul><li>new是运算符（new可以重载，重写），malloc是库函数</li><li>new自动计算要分配的大小，malloc需要手动计算</li><li>new是有类型检查的（因此使用new更安全），malloc只是机械的分配内存（存在危险） 如：</li><li>new返回的是对应类型的指针，malloc返回的时void类型，必须强制类型转换</li><li>分配失败时，new抛出bad_alloc，malloc返回空指针（NULL）；</li></ul><figure class="highlight c++"><table><tr><td class=code><pre><span class=line><span class=type>int</span> *p = <span class=keyword>new</span> <span class=type>float</span>[<span class=number>2</span>]; <span class=comment>//编译错误,内存分配不对，报错</span></span><br><span class=line></span><br><span class=line><span class=comment>//malloc返回的是void类型（无类型）的指针，必须进行强制类型转换</span></span><br><span class=line><span class=type>int</span> *p = (<span class=type>int</span>*)<span class=built_in>malloc</span>(<span class=number>2</span> * <span class=built_in>sizeof</span>(<span class=type>double</span>));<span class=comment>//编译无错误</span></span><br></pre></td></tr></table></figure><h3 id=库函数、运算符、系统调用><a href=#库函数、运算符、系统调用 class=headerlink title=库函数、运算符、系统调用></a>库函数、运算符、系统调用</h3><blockquote><p>库函数可以理解为系统调用的一个封装，系统调用就是操作系统提供给应用程序的接口（程序员只需要通过系统调用就能实现相应的功能，从而隐藏内部实现的细节，具体操作由操作系统实现），而库函数可以理解为对系统调用的再次封装（系统调用作为内核提供给用户的接口，执行效率非常高效和精简，但有时我们需要完成更为负责的操作和更人性化的设计），比如fopen为库函数，通过系统调用open来实现。函数可以<strong>自己定义</strong>也可通过头文件的引入使用C&#x2F;C++自带函数称<strong>库函数</strong>（就是人写的函数）。</p><p>运算符，+ - * &#x2F; 这些就是运算符，就是编译器按照指定的要求进行操作。</p></blockquote><h3 id=变量声明、定义><a href=#变量声明、定义 class=headerlink title=变量声明、定义></a>变量声明、定义</h3><ul><li>声明仅仅是把变量的声明的位置及类型提供给编译器，并不分配内存空间；定义要在定义的地方为其分配存储空间。</li><li>相同变量可以在多处声明（外部变量extern），但只能在一处定义。</li></ul><h3 id=C-和C的struct区别><a href=#C-和C的struct区别 class=headerlink title=C++和C的struct区别></a>C++和C的struct区别</h3><ul><li>c中struct没有权限设置，c++有public，protected，private</li><li>c中struct不可以有函数，c++可以有成员函数</li><li>c中struct不可继承，c++有public，protect，private三种继承方式（还可以实现多态）</li><li>c中struct和c++定义时不一样，c取别名要typedef，或者最后加上别名</li></ul><h3 id=定位-new><a href=#定位-new class=headerlink title="定位 new"></a>定位 new</h3><blockquote><p>定位 new（placement new）允许我们向 new 传递额外的地址参数，从而在预先指定的内存区域创建对象。</p></blockquote><figure class="highlight plaintext"><table><tr><td class=code><pre><span class=line>new (place_address) type  </span><br><span class=line>new (place_address) type (initializers)  </span><br><span class=line>new (place_address) type [size]  </span><br><span class=line>new (place_address) type [size] &#123; braced initializer list &#125;</span><br></pre></td></tr></table></figure><ul><li><code>place_address</code> 是个指针</li><li><code>initializers</code> 提供一个（可能为空的）以逗号分隔的初始值列表</li></ul><h3 id=函数指针和指针函数><a href=#函数指针和指针函数 class=headerlink title=函数指针和指针函数></a>函数指针和指针函数</h3><blockquote><p><code>参考回答</code></p></blockquote><ol><li><blockquote><p><code>定义不同</code> 指针函数本质是一个函数，其返回值为指针。 函数指针本质是一个指针，其指向一个函数。</p></blockquote></li><li><blockquote><p><code>写法不同</code></p></blockquote><figure class="highlight plaintext"><table><tr><td class=code><pre><span class=line>指针函数：int *fun(int x,int y);  </span><br><span class=line>函数指针：int (*fun)(int x,int y);</span><br></pre></td></tr></table></figure></li><li><blockquote><p><code>用法不同</code></p></blockquote><blockquote><p>用法参考答案解析</p></blockquote></li></ol><blockquote><p><code>答案解析</code></p></blockquote><figure class="highlight plaintext"><table><tr><td class=code><pre><span class=line>//指针函数示例  </span><br><span class=line>typedef struct _Data&#123;  </span><br><span class=line>    int a;  </span><br><span class=line>    int b;  </span><br><span class=line>&#125;Data;  </span><br><span class=line>//指针函数  </span><br><span class=line>Data* f(int a,int b)&#123;  </span><br><span class=line>    Data * data = new Data;  </span><br><span class=line>    //...  </span><br><span class=line>    return data;  </span><br><span class=line>&#125;  </span><br><span class=line>int main()&#123;  </span><br><span class=line>    //调用指针函数  </span><br><span class=line>    Data * myData = f(4,5);  </span><br><span class=line>    //Data * myData = static_cast&lt;Data*&gt;(f(4,5));  </span><br><span class=line>   //...  </span><br><span class=line>&#125;  </span><br><span class=line></span><br><span class=line>//函数指针示例  </span><br><span class=line>int add(int x,int y)&#123;  </span><br><span class=line>    return x+y;  </span><br><span class=line>&#125;  </span><br><span class=line>//函数指针  </span><br><span class=line>int (*fun)(int x,int y);  </span><br><span class=line>//赋值  </span><br><span class=line>fun = add;  </span><br><span class=line>//调用  </span><br><span class=line>cout &lt;&lt; &quot;(*fun)(1,2) = &quot; &lt;&lt; (*fun)(1,2) ;  </span><br><span class=line>//输出结果  </span><br><span class=line>//(*fun)(1,2) =  3</span><br></pre></td></tr></table></figure><h3 id=引用><a href=#引用 class=headerlink title=引用></a>引用</h3><blockquote><p>左值引用</p></blockquote><blockquote><p>常规引用，一般表示对象的身份。</p></blockquote><blockquote><p>右值引用</p></blockquote><blockquote><p>右值引用就是必须绑定到右值（一个临时对象、将要销毁的对象）的引用，一般表示对象的值。</p></blockquote><blockquote><p>右值引用可实现转移语义（Move Sementics）和精确传递（Perfect Forwarding），它的主要目的有两个方面：</p></blockquote><ul><li>消除两个对象交互时不必要的对象拷贝，节省运算存储资源，提高效率。</li><li>能够更简洁明确地定义泛型函数。</li></ul><blockquote><p>引用折叠</p></blockquote><ul><li><blockquote><p><code>X&amp; &amp;</code>、<code>X&amp; &amp;&amp;</code>、<code>X&amp;&amp; &amp;</code> 可折叠成 <code>X&amp;</code></p></blockquote></li><li><blockquote><p><code>X&amp;&amp; &amp;&amp;</code> 可折叠成 <code>X&amp;&amp;</code></p></blockquote></li></ul><h3 id=using声明和指示><a href=#using声明和指示 class=headerlink title=using声明和指示></a>using声明和指示</h3><blockquote><p><code>using 声明</code></p></blockquote><blockquote><p>一条 <code>using 声明</code> 语句一次只引入命名空间的一个成员。它使得我们可以清楚知道程序中所引用的到底是哪个名字。如：</p></blockquote><figure class="highlight plaintext"><table><tr><td class=code><pre><span class=line>using namespace_name::name;  </span><br><span class=line>//如  </span><br><span class=line>using std::cin;  </span><br><span class=line>using srd::cout;</span><br></pre></td></tr></table></figure><blockquote><p><code>构造函数的 using 声明</code></p></blockquote><blockquote><p>在 C++11 中，派生类能够重用其直接基类定义的构造函数。</p></blockquote><figure class="highlight plaintext"><table><tr><td class=code><pre><span class=line>class Base  </span><br><span class=line>&#123;  </span><br><span class=line>public:  </span><br><span class=line>    Base() &#123;&#125;;                         //  默认、拷贝、移动构造函数不能被继承和覆盖  </span><br><span class=line>    Base(int a) &#123;&#125;;                    //  被派生类中的构造函数覆盖  </span><br><span class=line>    Base(int a, int b) &#123;&#125;;             //  被派生类中的构造函数继承  </span><br><span class=line>    Base(int a, string b) &#123;&#125;;          //  被派生类中的构造函数继承  </span><br><span class=line>&#125;;  </span><br><span class=line></span><br><span class=line>class Derived: public Base  </span><br><span class=line>&#123;  </span><br><span class=line>public:  </span><br><span class=line>    using Base::Base;         // 声明继承基类中的构造函数，若无此声明是不继承构造函数的  </span><br><span class=line>    Derived(int a) &#123;&#125;;        // 覆盖基类中的构造函数  </span><br><span class=line>&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>如上 using 声明，对于基类的每个构造函数，编译器都生成一个与之对应（形参列表完全相同）的派生类构造函数。生成如下类型构造函数：</p></blockquote><figure class="highlight plaintext"><table><tr><td class=code><pre><span class=line>Derived(parms) : Base(args) &#123; &#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>using 指示</code></p></blockquote><blockquote><p><code>using 指示</code> 使得某个特定命名空间中所有名字都可见，这样我们就无需再为它们添加任何前缀限定符了。如：</p></blockquote><figure class="highlight plaintext"><table><tr><td class=code><pre><span class=line>using namespace_name name;  </span><br><span class=line>//如  </span><br><span class=line>using namespace std；</span><br></pre></td></tr></table></figure><blockquote><p><code>尽量少使用</code>using 指示<code>污染命名空间</code></p></blockquote><blockquote><blockquote><p>一般说来，使用 using 命令比使用 using 编译命令更安全，这是由于它<code>只导入了指定的名称</code>。如果该名称与局部名称发生冲突，编译器将<code>发出指示</code>。using编译命令导入所有的名称，包括可能并不需要的名称。如果与局部名称发生冲突，则<code>局部名称将覆盖名称空间版本</code>，而编译器<code>并不会发出警告</code>。另外，名称空间的开放性意味着名称空间的名称可能分散在多个地方，这使得难以准确知道添加了哪些名称。</p></blockquote></blockquote><blockquote><p><code>using 使用</code></p></blockquote><blockquote><p>尽量少使用 <code>using 指示</code></p></blockquote><figure class="highlight plaintext"><table><tr><td class=code><pre><span class=line>using namespace std;</span><br></pre></td></tr></table></figure><blockquote><p>应该多使用 <code>using 声明</code></p></blockquote><figure class="highlight plaintext"><table><tr><td class=code><pre><span class=line>int x;  </span><br><span class=line>std::cin &gt;&gt; x ;  </span><br><span class=line>std::cout &lt;&lt; x &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><blockquote><p>或者</p></blockquote><figure class="highlight plaintext"><table><tr><td class=code><pre><span class=line>using std::cin;  </span><br><span class=line>using std::cout;  </span><br><span class=line>using std::endl;  </span><br><span class=line>int x;  </span><br><span class=line>cin &gt;&gt; x;  </span><br><span class=line>cout &lt;&lt; x &lt;&lt; endl;</span><br></pre></td></tr></table></figure><h3 id=范围解析运算符><a href=#范围解析运算符 class=headerlink title=":: 范围解析运算符"></a>:: 范围解析运算符</h3><blockquote><p>分类</p></blockquote><figure class="highlight plaintext"><table><tr><td class=code><pre><span class=line>全局作用域符（`::name`）：用于类型名称（类、类成员、成员函数、变量等）前，表示作用域为全局命名空间</span><br><span class=line> 类作用域符（`class::name`）：用于表示指定类型的作用域范围是具体某个类的</span><br><span class=line> 命名空间作用域符（`namespace::name`）:用于表示指定类型的作用域范围是具体某个命名空间的</span><br></pre></td></tr></table></figure><blockquote><p>:: 使用</p></blockquote><figure class="highlight plaintext"><table><tr><td class=code><pre><span class=line>int count = 11;         // 全局（::）的 count  </span><br><span class=line></span><br><span class=line>class A &#123;  </span><br><span class=line>public:  </span><br><span class=line>	static int count;   // 类 A 的 count（A::count）  </span><br><span class=line>&#125;;  </span><br><span class=line>int A::count = 21;  </span><br><span class=line></span><br><span class=line>void fun()  </span><br><span class=line>&#123;  </span><br><span class=line>	int count = 31;     // 初始化局部的 count 为 31  </span><br><span class=line>	count = 32;         // 设置局部的 count 的值为 32  </span><br><span class=line>&#125;  </span><br><span class=line></span><br><span class=line>int main() &#123;  </span><br><span class=line>	::count = 12;       // 测试 1：设置全局的 count 的值为 12  </span><br><span class=line></span><br><span class=line>	A::count = 22;      // 测试 2：设置类 A 的 count 为 22  </span><br><span class=line></span><br><span class=line>	fun();		        // 测试 3  </span><br><span class=line></span><br><span class=line>	return 0;  </span><br><span class=line>&#125;</span><br></pre></td></tr></table></figure><h4 id=-3><a href=#-3 class=headerlink title=""></a></h4><h3 id=四类cast转换><a href=#四类cast转换 class=headerlink title=四类cast转换></a>四类cast转换</h3><ul><li><code>cast_const</code> 常量转换，用于将const变量转为非const,需要注意的是cast_const针对的是指针，引用，this指针</li></ul><figure class="highlight plaintext"><table><tr><td class=code><pre><span class=line>int n = 5;  </span><br><span class=line> int *k1 = const_cast&lt;int*&gt;(&amp;n);  //创建k1指针指向n的地址，如果不加cast_const,会报错，要写成const * k1 = &amp;n;才不会报错  </span><br><span class=line> *k1 = 1;        //cast_const转换之和才可以重新赋值  </span><br><span class=line> int &amp;k2 = const_cast&lt;int&amp;&gt;(n);   //针对引用，引用只是给对象起别名  </span><br><span class=line> k2 = 2;  </span><br><span class=line></span><br><span class=line>int n = 5;  </span><br><span class=line>int k1 = const_cast&lt;int&gt;(n);  //编译出错,只针对指针引用，this指针  </span><br><span class=line>k1 = 1;                       //编译出错</span><br></pre></td></tr></table></figure><ul><li><code>static_cast</code> 第一个作用是代替隐式转换 ，比如：</li></ul><blockquote><p>1、void* 转换为任意类型的指针</p></blockquote><blockquote><p>2、任意类型的指针转换为void*</p></blockquote><blockquote><p>3、编译器允许的跨类型转换,比如char类型转换为int类型，double转int型</p></blockquote><figure class="highlight plaintext"><table><tr><td class=code><pre><span class=line>int n = 10;  </span><br><span class=line>char c = &#x27;a&#x27;;  </span><br><span class=line>void *p = nullptr;  </span><br><span class=line>int *k = static_cast&lt;int*&gt;(p); //把p指针转换为int * 类型的指针  </span><br><span class=line></span><br><span class=line>n = static_cast&lt;int&gt;(c); //n就变成了97，ASCLL码中字符a的位置,    相当于int n = (int)c;    //把char c转换成 int 类型</span><br></pre></td></tr></table></figure><blockquote><p>static_cast第二个作用是做基类与派生类的转换，<code>派生类转换成基类是安全的，基类转换成派生类是不安全的，因为往往子类的内容比父类多，</code></p></blockquote><blockquote><p>static_cast可以将子类转换成父类，但是不提供安全性检查</p></blockquote><blockquote><p>复制代码</p></blockquote><figure class="highlight plaintext"><table><tr><td class=code><pre><span class=line>class A&#123;  </span><br><span class=line>public:  </span><br><span class=line>    void m() &#123;  </span><br><span class=line></span><br><span class=line>    &#125;;  </span><br><span class=line>&#125;;  </span><br><span class=line>class B:public A//普通继承   </span><br><span class=line>&#123;  </span><br><span class=line></span><br><span class=line>&#125;;  </span><br><span class=line>int main() &#123;  </span><br><span class=line>    A* aa;  </span><br><span class=line>    B* bb=static_cast&lt;B*&gt; (aa);//基类指针向下转换为派生类指针,不进行类型检查，不安全  </span><br><span class=line>   //如果字类指针转父类就是安全的   </span><br><span class=line>  system(&quot;pause&quot;);       </span><br><span class=line>    return 0;  </span><br><span class=line>&#125;</span><br></pre></td></tr></table></figure><ul><li><code>dynamic_cast</code></li></ul><blockquote><p>dynamic_cast和static_cast的效果是一样的;在进行下行转换时，dynamic_cast具有类型检查的功能，弥补了static_cast类型不安全的缺陷，比static_cast更安全</p></blockquote><blockquote><p>多<code>用于有虚函数的基类与其派生类之间的转换</code>，特点是进行运行时检测转换类型是否安全，如果转换失败返回nullptr，<code>依赖于RTTI技术</code>，但是有额外的函数开销，所以非必要的时候不使用。</p></blockquote><blockquote><p>复制代码</p></blockquote><figure class="highlight plaintext"><table><tr><td class=code><pre><span class=line>class A&#123;  </span><br><span class=line>public:  </span><br><span class=line>    virtual void m() &#123;  </span><br><span class=line></span><br><span class=line>    &#125;;// C现在是 多态  </span><br><span class=line></span><br><span class=line>&#125;;  </span><br><span class=line>class B:public A   </span><br><span class=line>&#123;  </span><br><span class=line></span><br><span class=line>&#125;;  </span><br><span class=line>int main() &#123;  </span><br><span class=line>    A* aa;  </span><br><span class=line>    B* bb=dynamic_cast&lt;B*&gt; (aa);//基类指针向下转换为派生类指针  </span><br><span class=line>    system(&quot;pause&quot;);  </span><br><span class=line>    return 0;  </span><br><span class=line>&#125;</span><br></pre></td></tr></table></figure><blockquote><p>复制代码</p></blockquote><blockquote><p>RTTI是一种意思是运行时类型信息，它提供了运行时确定对象类型的方法，换句话说，RTTI是一种可以获取变量在运行时的实际指向的机制，使用了typeid()函数</p></blockquote><blockquote><p><img src=https://img2020.cnblogs.com/blog/1468919/202009/1468919-20200906183653388-869154319.png alt=img></p></blockquote><ul><li><code>reinterpret_cast</code></li></ul><blockquote><p>reinterpret代替显示转换，用于转换各种高风险的转换（隐式转换无法转换的）</p></blockquote><blockquote><p>它可以把一个指针转换成一个整数，也可以把一个整数转换成一个指针（先把一个指针转换成一个整数，再把该整数转换成原类型的指针，还可以得到原先的指针值）</p></blockquote><blockquote><p>但是不进行检查，只是进行强制的复制，有安全隐患，一般不用</p></blockquote><blockquote><p>reinterpret_cast是四种强制转换中功能最为强大的，它可以暴力完成两个完全无关类型的指针之间或指针和数之间的互转，比如用char类型指针指向double值。<code>它对原始对象的位模式提供较低层次上的重新解释*（即reinterpret）*，完全复制二进制比特位到目标对象，转换后的值与原始对象无关但比特位一致，前后无精度损失。</code></p></blockquote><blockquote><p>复制代码</p></blockquote><figure class="highlight plaintext"><table><tr><td class=code><pre><span class=line>int main() &#123;  </span><br><span class=line>    double d = 1;  </span><br><span class=line>    char* p = reinterpret_cast&lt;char*&gt;(&amp;d); // 将d以二进制（位模式）方式解释为char，并赋给*p  </span><br><span class=line>    double* q = reinterpret_cast&lt;double*&gt;(p);  </span><br><span class=line>    cout &lt;&lt; *q &lt;&lt; endl; // 1  </span><br><span class=line>    system(&quot;pause&quot;);  </span><br><span class=line>    return 0;  </span><br><span class=line>&#125;</span><br></pre></td></tr></table></figure><h4 id=-4><a href=#-4 class=headerlink title=""></a></h4><h2 id=函数相关><a href=#函数相关 class=headerlink title=函数相关></a>函数相关</h2><h3 id=函数指针，指针函数><a href=#函数指针，指针函数 class=headerlink title=函数指针，指针函数></a>函数指针，指针函数</h3><h3 id=传值方式（引用，指针）><a href=#传值方式（引用，指针） class=headerlink title=传值方式（引用，指针）></a>传值方式（引用，指针）</h3><h3 id=内联函数和函数的区别><a href=#内联函数和函数的区别 class=headerlink title=内联函数和函数的区别></a>内联函数和函数的区别</h3><blockquote><p><code>参考回答</code></p></blockquote><ol><li>内联函数比普通函数多了关键字<code>inline</code></li><li>内联函数避免了函数调用的<code>开销</code>；普通函数有调用的开销</li><li>普通函数在被调用的时候，需要<code>寻址（函数入口地址）</code>；内联函数不需要寻址。</li><li>内联函数有一定的限制，内联函数体要求<code>代码简单</code>，不能包含复杂的结构控制语句；普通函数没有这个要求。</li></ol><blockquote><p><code>内联函数的作用</code>：内联函数在调用时，是将调用表达式用内联函数体来替换。避免函数调用的开销。</p></blockquote><blockquote><p><code>答案解析</code></p></blockquote><blockquote><p>在使用内联函数时，应注意如下几点：</p></blockquote><ol><li><blockquote><p>在内联函数内不允许用循环语句和开关语句。 如果内联函数有这些语句，则编译将该函数视同普通函数那样产生函数调用代码,递归函数是不能被用来做内联函数的。内联函数只适合于只有1～5行的小函数。对一个含有许多语句的大函数，函数调用和返回的开销相对来说微不足道，所以也没有必要用内联函数实现。</p></blockquote></li><li><blockquote><p>内联函数的定义必须出现在内联函数第一次被调用之前。</p></blockquote></li><li><blockquote><p>inline 内联函数</p></blockquote></li></ol><blockquote><p>特征</p></blockquote><ul><li>相当于把内联函数里面的内容写在调用内联函数处；</li><li>相当于不用执行进入函数的步骤，直接执行函数体；</li><li>相当于宏，却比宏多了类型检查，真正具有函数特性；</li><li>编译器一般不内联包含循环、递归、switch 等复杂操作的内联函数；</li><li>在类声明中定义的函数，除了虚函数的其他函数都会自动隐式地当成内联函数。</li></ul><blockquote><p>使用</p></blockquote><blockquote><p>inline 使用</p></blockquote><figure class="highlight plaintext"><table><tr><td class=code><pre><span class=line>// 声明1（加 inline，建议使用）  </span><br><span class=line>inline int functionName(int first, int second,...);  </span><br><span class=line></span><br><span class=line>// 声明2（不加 inline）  </span><br><span class=line>int functionName(int first, int second,...);  </span><br><span class=line></span><br><span class=line>// 定义  </span><br><span class=line>inline int functionName(int first, int second,...) &#123;/****/&#125;;  </span><br><span class=line></span><br><span class=line>// 类内定义，隐式内联  </span><br><span class=line>class A &#123;  </span><br><span class=line>    int doA() &#123; return 0; &#125;         // 隐式内联  </span><br><span class=line>&#125;  </span><br><span class=line></span><br><span class=line>// 类外定义，需要显式内联  </span><br><span class=line>class A &#123;  </span><br><span class=line>    int doA();  </span><br><span class=line>&#125;  </span><br><span class=line>inline int A::doA() &#123; return 0; &#125;   // 需要显式内联</span><br></pre></td></tr></table></figure><blockquote><p>编译器对 inline 函数的处理步骤</p></blockquote><ol><li>将 inline 函数体复制到 inline 函数调用点处；</li><li>为所用 inline 函数中的局部变量分配内存空间；</li><li>将 inline 函数的的输入参数和返回值映射到调用方法的局部变量空间中；</li><li>如果 inline 函数有多个返回点，将其转变为 inline 函数代码块末尾的分支（使用 GOTO）。</li></ol><blockquote><p>优缺点</p></blockquote><blockquote><p>优点</p></blockquote><ol><li>内联函数同宏函数一样将在被调用处进行代码展开，省去了参数压栈、栈帧开辟与回收，结果返回等，从而提高程序运行速度。</li><li>内联函数相比宏函数来说，在代码展开时，会做安全检查或自动类型转换（同普通函数），而宏定义则不会。</li><li>在类中声明同时定义的成员函数，自动转化为内联函数，因此内联函数可以访问类的成员变量，宏定义则不能。</li><li>内联函数在运行时可调试，而宏定义不可以。</li></ol><blockquote><p>缺点</p></blockquote><ol><li>代码膨胀。内联是以代码膨胀（复制）为代价，消除函数调用带来的开销。如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率的收获会很少。另一方面，每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间。</li><li>inline 函数无法随着函数库升级而升级。inline函数的改变需要重新编译，不像 non-inline 可以直接链接。</li><li>是否内联，程序员不可控。内联函数只是对编译器的建议，是否对函数内联，决定权在于编译器。</li></ol><blockquote><p>虚函数（virtual）可以是内联函数（inline）吗？</p></blockquote><blockquote><blockquote><p>Are inline virtual member functions ever actually inlined?</p></blockquote></blockquote><ul><li>虚函数可以是内联函数，内联是可以修饰虚函数的，但是当虚函数表现多态性的时候不能内联。</li><li>内联是在编译期建议编译器内联，而虚函数的多态性在运行期，编译器无法知道运行期调用哪个代码，因此虚函数表现为多态性时（运行期）不可以内联。</li><li><code>inline virtual</code> 唯一可以内联的时候是：编译器知道所调用的对象是哪个类（如 <code>Base::who()</code>），这只有在编译器具有实际对象而不是对象的指针或引用时才会发生。</li></ul><blockquote><p>虚函数内联使用</p></blockquote><figure class="highlight plaintext"><table><tr><td class=code><pre><span class=line>#include &lt;iostream&gt;    </span><br><span class=line>using namespace std;  </span><br><span class=line>class Base  </span><br><span class=line>&#123;  </span><br><span class=line>public:  </span><br><span class=line>	inline virtual void who()  </span><br><span class=line>	&#123;  </span><br><span class=line>		cout &lt;&lt; &quot;I am Base\\n&quot;;  </span><br><span class=line>	&#125;  </span><br><span class=line>	virtual ~Base() &#123;&#125;  </span><br><span class=line>&#125;;  </span><br><span class=line>class Derived : public Base  </span><br><span class=line>&#123;  </span><br><span class=line>public:  </span><br><span class=line>	inline void who()  // 不写inline时隐式内联  </span><br><span class=line>	&#123;  </span><br><span class=line>		cout &lt;&lt; &quot;I am Derived\\n&quot;;  </span><br><span class=line>	&#125;  </span><br><span class=line>&#125;;  </span><br><span class=line></span><br><span class=line>int main()  </span><br><span class=line>&#123;  </span><br><span class=line>	// 此处的虚函数 who()，是通过类（Base）的具体对象（b）来调用的，编译期间就能确定了，所以它可以是内联的，但最终是否内联取决于编译器。   </span><br><span class=line>	Base b;  </span><br><span class=line>	b.who();  </span><br><span class=line></span><br><span class=line>	// 此处的虚函数是通过指针调用的，呈现多态性，需要在运行时期间才能确定，所以不能为内联。    </span><br><span class=line>	Base *ptr = new Derived();  </span><br><span class=line>	ptr-&gt;who();  </span><br><span class=line></span><br><span class=line>	// 因为Base有虚析构函数（virtual ~Base() &#123;&#125;），所以 delete 时，会先调用派生类（Derived）析构函数，再调用基类（Base）析构函数，防止内存泄漏。  </span><br><span class=line>	delete ptr;  </span><br><span class=line>	ptr = nullptr;  </span><br><span class=line></span><br><span class=line>	system(&quot;pause&quot;);  </span><br><span class=line>	return 0;  </span><br><span class=line>&#125;</span><br></pre></td></tr></table></figure><h3 id=C-传值方式，区别><a href=#C-传值方式，区别 class=headerlink title=C++传值方式，区别></a>C++传值方式，区别</h3><blockquote><p><code>参考回答</code></p></blockquote><blockquote><p>传参方式有这三种：<code>值传递、引用传递、指针传递</code></p></blockquote><ol><li>值传递：形参即使在函数体内值发生变化，也不会影响实参的值；</li><li>引用传递：形参在函数体内值发生变化，会影响实参的值；</li><li>指针传递：在指针指向没有发生改变的前提下，形参在函数体内值发生变化，会影响实参的值</li><li>在传递函数参数时，什么时候该使用指针，什么时候该使用引用呢<ul><li>需要返回函数内局部变量的内存的时候用指针。使用指针传参需要开辟内存，用完要记得释放指针，不然会内存泄漏。而返回局部变量的引用是没有意义的</li><li>对栈空间大小比较敏感（比如递归）的时候使用引用。使用引用传递不需要创建临时变量，开销要更小</li><li>类对象作为参数传递的时候使用引用，这是C++类对象传递的标准方式</li><li>除了必须使用指针的（如二叉树，链表的操作），一般情况下都用引用</li></ul></li></ol><blockquote><p><code>答案解析</code></p></blockquote><blockquote><p>值传递用于对象时，整个对象会拷贝一个副本，这样效率低；而引用传递用于对象时，不发生拷贝行为，只是绑定对象，更高效；指针传递同理，但不如引用传递安全。</p></blockquote><blockquote><p>代码示例</p></blockquote><figure class="highlight plaintext"><table><tr><td class=code><pre><span class=line>//代码示例  </span><br><span class=line>#include &lt;iostream&gt;  </span><br><span class=line>using namespace std;  </span><br><span class=line></span><br><span class=line>void testfunc(int a, int *b, int &amp;c)&#123;//形参a值发生了改变，但是没有影响实参i的值；但形参*b、c的值发生了改变，影响到了实参*j、k的值  </span><br><span class=line>    a += 1;  </span><br><span class=line>    (*b) += 1;  </span><br><span class=line>    c += 1;  </span><br><span class=line>    printf(&quot;a= %d, b= %d, c= %d\\n&quot;,a,*b,c);//a= 2, b= 2, c= 2  </span><br><span class=line>&#125;  </span><br><span class=line>int main()&#123;  </span><br><span class=line>       int i = 1;  </span><br><span class=line>    int a = 1;  </span><br><span class=line>    int *j = &amp;a;  </span><br><span class=line>    int k = 1;  </span><br><span class=line>    testfunc(i, j, k);  </span><br><span class=line>    printf(&quot;i= %d, j= %d, k= %d\\n&quot;,i,*j,k);//i= 1, j= 2, k= 2  </span><br><span class=line>    return 0;  </span><br><span class=line>&#125;</span><br></pre></td></tr></table></figure><h4 id=-5><a href=#-5 class=headerlink title=""></a></h4><h3 id=C-x2F-C><a href=#C-x2F-C class=headerlink title=C&#x2F;C++></a>C&#x2F;C++</h3><h3 id=导入C函数关键字><a href=#导入C函数关键字 class=headerlink title=导入C函数关键字></a>导入C函数关键字</h3><ol><li><code>关键字：</code>在C++中，导入C函数的关键字是<code>extern</code>，表达形式为<code>extern “C”</code>， extern “C”的主要作用就是为了能够正确实现C++代码调用其他C语言代码。加上extern “C”后，会指示编译器这部分代码按<code>C语言</code>的进行编译，而不是C++的。</li><li><code>编译区别：</code>由于C++支持函数重载，因此编译器编译函数的过程中会将函数的<code>参数类型</code>也加到编译后的代码中，而不仅仅是<code>函数名</code>；而C语言并不支持函数重载，因此编译C语言代码的函数时不会带上函数的参数类型，一般只包括<code>函数名</code>。</li></ol><blockquote><p><code>答案解析</code></p></blockquote><figure class="highlight plaintext"><table><tr><td class=code><pre><span class=line>//extern示例 //在C++程序里边声明该函数，会指示编译器这部分代码按C语言的进行编译 extern &quot;C&quot; int strcmp(const char *s1, const char *s2);  //在C++程序里边声明该函数 extern &quot;C&quot;&#123;     #include &lt;string.h&gt;//string.h里边包含了要调用的C函数的声明 &#125;  //两种不同的语言，有着不同的编译规则，比如一个函数fun，可能C语言编译的时候为_fun，而C++则是__fun__</span><br></pre></td></tr></table></figure><h4 id=-6><a href=#-6 class=headerlink title=""></a></h4><h3 id=C-x2F-C-struct区别><a href=#C-x2F-C-struct区别 class=headerlink title="C&#x2F;C++ struct区别"></a>C&#x2F;C++ struct区别</h3><h2 id=程序执行过程><a href=#程序执行过程 class=headerlink title=程序执行过程></a>程序执行过程</h2><h3 id=main执行之前和之后><a href=#main执行之前和之后 class=headerlink title=main执行之前和之后></a>main执行之前和之后</h3><blockquote><p><code>main函数执行之前</code>，主要就是初始化系统相关资源：</p></blockquote><ul><li>设置栈指针</li><li>初始化静态<code>static</code>变量和<code>global</code>全局变量，即<code>.data</code>段的内容</li><li>将未初始化部分的全局变量赋初值：数值型<code>short</code>，<code>int</code>，<code>long</code>等为<code>0</code>，<code>bool</code>为<code>FALSE</code>，指针为<code>NULL</code>等等，即<code>.bss</code>段的内容</li><li>全局对象初始化，在<code>main</code>之前调用构造函数，这是可能会执行前的一些代码</li><li>将main函数的参数<code>argc</code>，<code>argv</code>等传递给<code>main</code>函数，然后才真正运行<code>main</code>函数</li><li>&#96;&#96;&#96;<br><strong>attribute</strong>((constructor))<figure class="highlight plaintext"><table><tr><td class=code><pre><span class=line></span><br><span class=line>&gt; `main函数执行之后`：</span><br><span class=line></span><br><span class=line>*   全局对象的析构函数会在main函数之后执行；</span><br><span class=line>*   可以用 ``atexit`` 注册一个函数，它会在main 之后执行;</span><br><span class=line>*   ```</span><br><span class=line>    __attribute__((destructor))</span><br></pre></td></tr></table></figure></li></ul><h3 id=C-代码到可执行二进制文件的过程><a href=#C-代码到可执行二进制文件的过程 class=headerlink title=C++代码到可执行二进制文件的过程></a>C++代码到可执行二进制文件的过程</h3><blockquote><p><code>参考回答</code></p></blockquote><blockquote><p><code>预编译、编译、汇编、链接</code>。</p></blockquote><blockquote><p><code>答案解析</code></p></blockquote><ol><li><blockquote><p>预编译：这个过程主要的处理操作如下：</p></blockquote><blockquote><p>（1）处理 # 指令，如 #include，判断条件指令，#ifdef</p></blockquote><blockquote><p>（2） 过滤注释</p></blockquote><blockquote><p>（3） 添加行号和文件名标识，处理空行。</p></blockquote></li><li><blockquote><p>编译：这个过程主要的处理操作如下：（<strong>判断代码是否正确</strong>）</p></blockquote><blockquote><p>（1） 词法分析：将源代码的字符序列分割成一系列的记号。</p></blockquote><blockquote><p>（2） 语法分析：对记号进行语法分析，产生语法树。</p></blockquote><blockquote><p>（3） 语义分析：判断表达式是否有意义。</p></blockquote><blockquote><p>（4） 代码优化：</p></blockquote><blockquote><p>（5） 目标代码生成：生成汇编代码。</p></blockquote><blockquote><p>（6） 目标代码优化：</p></blockquote></li><li><blockquote><p>汇编：将汇编代码转变成机器指令。</p></blockquote></li><li><blockquote><p>链接：将不同的源文件产生的目标文件进行链接，从而形成一个可以执行的程序。</p></blockquote><blockquote><p>链接分为静态链接和动态链接。</p></blockquote><blockquote><p>静态链接，是在链接的时候就已经把要调用的函数或者过程链接到了生成的可执行文件中，就算你在去把静态库删除也不会影响可执行程序的执行；生成的静态链接库，Windows下以.lib为后缀，Linux下以.a为后缀。</p></blockquote><blockquote><p>而动态链接，是在链接的时候没有把调用的函数代码链接进去，而是在执行的过程中，再去找要链接的函数，生成的可执行文件中没有函数代码，只包含函数的重定位信息，所以当你删除动态库时，可执行程序就不能运行。生成的动态链接库，Windows下以.dll为后缀，Linux下以.so为后缀。</p></blockquote></li></ol><h3 id=静态变量初始化><a href=#静态变量初始化 class=headerlink title=静态变量初始化></a>静态变量初始化</h3><blockquote><p><code>参考回答</code></p></blockquote><blockquote><p>c++规定：全局或静态对象当且仅当首次用到时才进行初始化</p></blockquote><blockquote><p><code>答案解析</code></p></blockquote><ol><li><blockquote><p><code>作用域</code>：C++里作用域可分为6种：全局，局部，类，语句，命名空间和文件作用域。</p></blockquote><blockquote><p>静态全局变量 ：全局作用域+文件作用域，所以无法在其他文件中使用。</p></blockquote><blockquote><p>静态局部变量 ：局部作用域</p></blockquote><blockquote><p>类静态成员变量：类作用域。</p></blockquote></li><li><blockquote><p><code>所在空间</code>：都在全局区&#x2F;静态存储区。因为静态变量都在静态存储区，所以下次调用函数的时候还是能取到原来的值。</p></blockquote></li><li><blockquote><p><code>生命周期</code>：静态全局变量、静态局部变量都在静态存储区，直到程序结束才会回收内存。类静态成员变量在静态存储区，当超出类作用域时回收内存。</p></blockquote></li><li><blockquote><p>new和malloc的区别</p></blockquote></li></ol><blockquote><p><code>参考回答</code></p></blockquote><ol><li>new是操作符，而malloc是函数。</li><li>new在调用的时候先分配内存，在调用构造函数，释放的时候调用析构函数；而malloc没有构造函数和析构函数。</li><li>malloc需要给定申请内存的大小，返回的指针需要强转；new会调用构造函数，不用指定内存的大小，返回指针不用强转。</li><li>new可以被重载；malloc不行</li><li>new分配内存更直接和安全。</li><li>new发生错误抛出异常，malloc返回null</li></ol><blockquote><p><code>答案解析</code></p></blockquote><blockquote><p><code>malloc底层实现：</code>当开辟的空间小于 128K 时，调用 brk（）函数；当开辟的空间大于 128K 时，调用mmap（）。malloc采用的是内存池的管理方式，以减少内存碎片。先申请大块内存作为堆区，然后将堆区分为多个内存块。当用户申请内存时，直接从堆区分配一块合适的空闲快。采用隐式链表将所有空闲块，每一个空闲块记录了一个未分配的、连续的内存地址。</p></blockquote><blockquote><p><code>new底层实现：</code>关键字new在调用构造函数的时候实际上进行了如下的几个步骤：</p></blockquote><ol><li><blockquote><p>创建一个新的对象</p></blockquote></li><li><blockquote><p>将构造函数的作用域赋值给这个新的对象（因此this指向了这个新的对象）</p></blockquote></li><li><blockquote><p>执行构造函数中的代码（为这个新对象添加属性）</p></blockquote></li><li><blockquote><p>返回新对象</p></blockquote></li></ol><h2 id=STL><a href=#STL class=headerlink title=STL></a>STL</h2><h3 id=什么是STL？><a href=#什么是STL？ class=headerlink title=什么是STL？></a>什么是STL？</h3><blockquote><p>C++ STL从广义来讲包括了三类：算法，容器和迭代器。</p></blockquote><ul><li><blockquote><p>算法包括排序，复制等常用算法，以及不同容器特定的算法。</p></blockquote></li><li><blockquote><p>容器就是数据的存放形式，包括序列式容器和关联式容器，序列式容器就是list，vector等，关联式容器就是set，map等。</p></blockquote></li><li><blockquote><p>迭代器就是在不暴露容器内部结构的情况下对容器的遍历。</p></blockquote></li></ul><h3 id=STL-索引><a href=#STL-索引 class=headerlink title="STL 索引"></a>STL 索引</h3><blockquote><p>STL 方法含义索引</p></blockquote><h3 id=STL-容器><a href=#STL-容器 class=headerlink title="STL 容器"></a>STL 容器</h3><p>容器 底层数据结构 时间复杂度 有无序 可不可重复 其他</p><hr><p>array 数组 随机读改 O(1)，插入O（n） 无序 可重复 支持随机访问<br>vector 数组 随机读改、尾部插入、尾部删除 O(1) 头部插入、头部删除 O(n) 无序 可重复 支持随机访问<br>deque 双端数组 头尾插入、头尾删除 O(1) 无序 可重复 一个中央控制器 + 多个缓冲区，支持首尾快速增删，支持随机访问<br>forward_list 单向链表 插入、删除 O(1) 无序 可重复 不支持随机访问<br>list 双向链表 插入、删除 O(1) 无序 可重复 不支持随机访问<br>stack deque &#x2F; list 顶部插入、顶部删除 O(1) 无序 可重复 deque 或 list 封闭头端开口，不用 vector 的原因应该是容量大小有限制，扩容耗时<br>queue deque &#x2F; list 尾部插入、头部删除 O(1) 无序 可重复 deque 或 list 封闭头端开口，不用 vector 的原因应该是容量大小有限制，扩容耗时<br>priority_queue vector + max-heap 插入、删除 O(log2n) 有序 可重复 vector容器+heap处理规则<br>set 红黑树 插入、删除、查找 O(log2n) 有序 不可重复<br>multiset 红黑树 插入、删除、查找 O(log2n) 有序 可重复<br>map 红黑树 插入、删除、查找 O(log2n) 有序 不可重复<br>multimap 红黑树 插入、删除、查找 O(log2n) 有序 可重复<br>unordered_set 哈希表 插入、删除、查找 O(1) 最差 O(n) 无序 不可重复<br>unordered_multiset 哈希表 插入、删除、查找 O(1) 最差 O(n) 无序 可重复<br>unordered_map 哈希表 插入、删除、查找 O(1) 最差 O(n) 无序 不可重复<br>unordered_multimap 哈希表 插入、删除、查找 O(1) 最差 O(n) 无序 可重复</p><ul><li><code>deque内部工作原理:</code></li></ul><blockquote><p>deque内部有个<code>中控器</code>，维护每段缓冲区中的内容，缓冲区中存放真实数据</p></blockquote><blockquote><p>中控器维护的是每个缓冲区的地址，使得使用deque时像一片连续的内存空间</p></blockquote><blockquote><p><img src=/Users/apple/Desktop/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%B5%84%E6%96%99/C++/C++%E6%8F%90%E9%AB%98/%E8%AE%B2%E4%B9%89/assets/clip_image002-1547547896341.jpg alt=clip_image002-1547547896341></p></blockquote><ul><li>deque容器的迭代器也是支持随机访问的</li></ul><h3 id=STL-算法><a href=#STL-算法 class=headerlink title="STL 算法"></a>STL 算法</h3><p>算法 底层算法 时间复杂度 可不可重复</p><hr><p>find 顺序查找 O(n) 可重复<br>sort 内省排序 O(n*log2n) 可重复</p><h2 id=数据结构及其算法><a href=#数据结构及其算法 class=headerlink title=数据结构及其算法></a>数据结构及其算法</h2><h2 id=操作系统相关><a href=#操作系统相关 class=headerlink title=操作系统相关></a>操作系统相关</h2><h2 id=计算机网络><a href=#计算机网络 class=headerlink title=计算机网络></a>计算机网络</h2><h2 id=Linux命令><a href=#Linux命令 class=headerlink title=Linux命令></a>Linux命令</h2><ul><li>ps -aux 查看进程，一般配合 ps -aux ｜ grep ；</li><li>tar -zvx 目标文件 解压；</li><li>tar -zcx</li></ul></div><div class=post-copyright><div class=post-copyright-icon></div><div class=post-copyright-author><span class=post-copyright-meta>文章作者: </span><span class=post-copyright-info><a href=mailto:me@imlete.cn>MengD(萌典)</a></span></div><div class=post-copyright-type><span class=post-copyright-meta>文章链接: </span><span class=post-copyright-info><a href=http://example.com/2022/04/23/面试八股文/ >http://example.com/2022/04/23/面试八股文/</a></span></div><div class=post-copyright-notice><span class=post-copyright-meta>版权声明: </span><span class=post-copyright-info>本博客所有文章除特别声明外，均采用 <a href=https://creativecommons.org/licenses/by-nc-sa/4.0/ target=_blank>CC BY-NC-SA 4.0 </a>许可协议。转载请注明来自 <a href=http://example.com/2022/04/23/面试八股文/ target=_blank>Hexo-Theme-MengD(萌典)</a> ！</span></div></div><div class=pagination-post><a href=/2022/04/24/hello-world/ ><div class=prev-title><i class="fas fa-chevron-left"></i>Hello World</div><div class=prev-desc>Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any ...</div></a></div><div class=comment-head id=直达评论><hr><div class=comment-headline><i class="fas fa-comments fa-fw"></i> <span>评论</span></div><div id=Discuss-Comments></div><script>function LoadDiscuss(){getScript("https://cdn.jsdelivr.net/npm/discuss@latest/dist/Discuss.js",function(){let s={el:"#Discuss-Comments",serverURLs:""};Discuss.init(s)})}LoadDiscuss()</script></div></article><div id=toc-wrap><div id=toc><div class=toc-title><div>目录 <span class=num>0%</span></div><progress class=progress value=0 max=100></progress></div><div class=toc-list><ol class=toc><li class="toc-item toc-level-2"><a class=toc-link href=#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1><span class=toc-text>面向对象</span></a><ol class=toc-child><li class="toc-item toc-level-3"><a class=toc-link href=#%E5%A4%9A%E6%80%81%E5%88%86%E7%B1%BB%E5%8F%8A%E5%AE%9E%E7%8E%B0><span class=toc-text>多态分类及实现</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E5%8A%A8%E6%80%81%E5%A4%9A%E6%80%81%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86><span class=toc-text>动态多态实现原理</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E5%88%86%E7%B1%BB%E5%8F%8A%E8%B0%83%E7%94%A8><span class=toc-text>构造函数的分类及调用</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E3%80%81%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E9%A1%BA%E5%BA%8F><span class=toc-text>构造函数、析构函数调用顺序</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E8%99%9A%E5%87%BD%E6%95%B0><span class=toc-text>构造函数为什么不能虚函数</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%E6%96%B9%E5%BC%8F><span class=toc-text>拷贝构造函数的参数传递方式</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E6%8B%B7%E8%B4%9D%E8%B5%8B%E5%80%BC%E5%92%8C%E7%A7%BB%E5%8A%A8%E8%B5%8B%E5%80%BC%EF%BC%9F><span class=toc-text>拷贝赋值和移动赋值？</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D><span class=toc-text>深拷贝与浅拷贝</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E8%99%9A%E6%9E%90%E6%9E%84><span class=toc-text>虚析构</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E8%99%9A%E5%87%BD%E6%95%B0%E3%80%81%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0><span class=toc-text>虚函数、纯虚函数</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E8%99%9A%E7%BB%A7%E6%89%BF%EF%BC%88%E8%8F%B1%E5%BD%A2%E7%BB%A7%E6%89%BF%EF%BC%89><span class=toc-text>虚继承（菱形继承）</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E8%99%9A%E7%BB%A7%E6%89%BF%E3%80%81%E8%99%9A%E5%87%BD%E6%95%B0%E5%AF%B9%E6%AF%94><span class=toc-text>虚继承、虚函数对比</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E5%93%AA%E4%BA%9B%E5%87%BD%E6%95%B0%E4%B8%8D%E8%83%BD%E8%A2%AB%E5%A3%B0%E6%98%8E%E4%B8%BA%E8%99%9A%E5%87%BD%E6%95%B0><span class=toc-text>哪些函数不能被声明为虚函数</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8%E9%87%8C%E5%AD%98%E6%94%BE%E7%9A%84%E5%86%85%E5%AE%B9%E6%98%AF%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%86%99%E8%BF%9B%E5%8E%BB%E7%9A%84><span class=toc-text>虚函数表里存放的内容是什么时候写进去的</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E9%87%8D%E5%86%99%E3%80%81%E9%87%8D%E8%BD%BD%E3%80%81%E9%9A%90%E8%97%8F><span class=toc-text>重写、重载、隐藏</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#struct-class-%E5%8C%BA%E5%88%AB><span class=toc-text>struct class 区别</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#this-%E6%8C%87%E9%92%88><span class=toc-text>this 指针</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#delete-this-%E5%90%88%E6%B3%95%E5%90%97%EF%BC%9F><span class=toc-text>delete this 合法吗？</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E5%A6%82%E4%BD%95%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AA%E5%8F%AA%E8%83%BD%E5%9C%A8%E5%A0%86%E4%B8%8A%EF%BC%88%E6%A0%88%E4%B8%8A%EF%BC%89%E7%94%9F%E6%88%90%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%B1%BB%EF%BC%9F><span class=toc-text>如何定义一个只能在堆上（栈上）生成对象的类？</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#nullptr%E8%B0%83%E7%94%A8%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E5%8F%AF%E4%BB%A5%E5%90%97%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F><span class=toc-text>nullptr调用成员函数可以吗？为什么？</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#friend-%E5%8F%8B%E5%85%83%E7%B1%BB%E5%92%8C%E5%8F%8B%E5%85%83%E5%87%BD%E6%95%B0><span class=toc-text>friend 友元类和友元函数</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E6%88%90%E5%91%98%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8><span class=toc-text>成员初始化列表</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#initializer-list-%E5%88%97%E8%A1%A8%E5%88%9D%E5%A7%8B%E5%8C%96%EF%BC%88c-11%EF%BC%89><span class=toc-text>initializer_list 列表初始化（c++11）</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-1><span class=toc-text>面向对象</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E5%B0%81%E8%A3%85><span class=toc-text>封装</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E6%8A%BD%E8%B1%A1%E7%B1%BB%E3%80%81%E6%8E%A5%E5%8F%A3%E7%B1%BB%E3%80%81%E8%81%9A%E5%90%88%E7%B1%BB><span class=toc-text>抽象类、接口类、聚合类</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E4%BB%BF%E5%87%BD%E6%95%B0-%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1><span class=toc-text>仿函数(函数对象)</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E7%B1%BB%E6%A8%A1%E6%9D%BF%E5%92%8C%E6%A8%A1%E6%9D%BF%E7%B1%BB%E7%9A%84%E5%8C%BA%E5%88%AB><span class=toc-text>类模板和模板类的区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class=toc-link href=#%E5%86%85%E5%AD%98%E7%9B%B8%E5%85%B3><span class=toc-text>内存相关</span></a><ol class=toc-child><li class="toc-item toc-level-3"><a class=toc-link href=#%E7%A8%8B%E5%BA%8Fsection><span class=toc-text>程序section</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E5%86%85%E5%AD%98%E5%88%86%E5%8C%BA><span class=toc-text>内存分区</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E6%A0%88%E5%92%8C%E5%A0%86><span class=toc-text>栈和堆</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%92%8C%E7%AE%A1%E7%90%86><span class=toc-text>内存分配和管理</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2><span class=toc-text>内存泄露</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#C-%E4%B8%AD%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF><span class=toc-text>C++中内存对齐的使用场景</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E5%A4%A7%E7%AB%AF%E5%B0%8F%E7%AB%AF><span class=toc-text>大端小端</span></a></li></ol></li><li class="toc-item toc-level-2"><a class=toc-link href=#%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95><span class=toc-text>基础语法</span></a><ol class=toc-child><li class="toc-item toc-level-3"><a class=toc-link href=#%E5%8F%8C%E5%BC%95%E5%8F%B7%E2%80%9D%E2%80%9D%E5%92%8C%E5%B0%96%E6%8B%AC%E5%8F%B7-lt-gt-%E7%9A%84%E5%8C%BA%E5%88%AB><span class=toc-text>双引号””和尖括号&lt;&gt;的区别</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E6%95%B0%E7%BB%84%E5%90%8D%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%95%B0%E7%BB%84><span class=toc-text>数组名和字符串数组</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E5%8C%BA%E5%88%AB%E4%BB%A5%E4%B8%8B%E6%8C%87%E9%92%88%E7%B1%BB%E5%9E%8B><span class=toc-text>区别以下指针类型</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#const><span class=toc-text>const</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#const%E5%92%8Cdefine><span class=toc-text>const和define</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#static%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%BD%9C%E7%94%A8><span class=toc-text>static关键字的作用</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E9%87%8E%E6%8C%87%E9%92%88%EF%BC%8C%E6%82%AC%E7%A9%BA%E6%8C%87%E9%92%88><span class=toc-text>野指针，悬空指针</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#volatile><span class=toc-text>volatile</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#assert><span class=toc-text>assert()</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#pragma-pack-n><span class=toc-text>#pragma pack(n)</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E4%BD%8D%E5%9F%9F><span class=toc-text>位域</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#union-%E8%81%94%E5%90%88><span class=toc-text>union 联合</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#enum-%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B><span class=toc-text>enum 枚举类型</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#decltype><span class=toc-text>decltype</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88><span class=toc-text>智能指针</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E8%BF%90%E7%AE%97%E7%AC%A6><span class=toc-text>强制类型转换运算符</span></a><ol class=toc-child><li class="toc-item toc-level-4"><a class=toc-link><span class=toc-text></span></a></li></ol></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E8%BF%90%E8%A1%8C%E6%97%B6%E7%B1%BB%E5%9E%8B%E4%BF%A1%E6%81%AF-RTTI><span class=toc-text>运行时类型信息 (RTTI)</span></a><ol class=toc-child><li class="toc-item toc-level-4"><a class=toc-link href=#-1><span class=toc-text></span></a></li></ol></li><li class="toc-item toc-level-3"><a class=toc-link href=#-2><span class=toc-text></span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#size-%E3%80%81length-%E3%80%81strlen-%E3%80%81sizeof><span class=toc-text>size()、length()、strlen()、sizeof()</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#malloc%E3%80%81free><span class=toc-text>malloc、free</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#new%E3%80%81delete><span class=toc-text>new、delete</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#new%E5%92%8Cmalloc%EF%BC%8Cdelete%E5%92%8Cfree%E7%9A%84%E5%8C%BA%E5%88%AB><span class=toc-text>new和malloc，delete和free的区别</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E5%BA%93%E5%87%BD%E6%95%B0%E3%80%81%E8%BF%90%E7%AE%97%E7%AC%A6%E3%80%81%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8><span class=toc-text>库函数、运算符、系统调用</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E%E3%80%81%E5%AE%9A%E4%B9%89><span class=toc-text>变量声明、定义</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#C-%E5%92%8CC%E7%9A%84struct%E5%8C%BA%E5%88%AB><span class=toc-text>C++和C的struct区别</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E5%AE%9A%E4%BD%8D-new><span class=toc-text>定位 new</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%E5%92%8C%E6%8C%87%E9%92%88%E5%87%BD%E6%95%B0><span class=toc-text>函数指针和指针函数</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E5%BC%95%E7%94%A8><span class=toc-text>引用</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#using%E5%A3%B0%E6%98%8E%E5%92%8C%E6%8C%87%E7%A4%BA><span class=toc-text>using声明和指示</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E8%8C%83%E5%9B%B4%E8%A7%A3%E6%9E%90%E8%BF%90%E7%AE%97%E7%AC%A6><span class=toc-text>:: 范围解析运算符</span></a><ol class=toc-child><li class="toc-item toc-level-4"><a class=toc-link href=#-3><span class=toc-text></span></a></li></ol></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E5%9B%9B%E7%B1%BBcast%E8%BD%AC%E6%8D%A2><span class=toc-text>四类cast转换</span></a><ol class=toc-child><li class="toc-item toc-level-4"><a class=toc-link href=#-4><span class=toc-text></span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class=toc-link href=#%E5%87%BD%E6%95%B0%E7%9B%B8%E5%85%B3><span class=toc-text>函数相关</span></a><ol class=toc-child><li class="toc-item toc-level-3"><a class=toc-link href=#%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%EF%BC%8C%E6%8C%87%E9%92%88%E5%87%BD%E6%95%B0><span class=toc-text>函数指针，指针函数</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E4%BC%A0%E5%80%BC%E6%96%B9%E5%BC%8F%EF%BC%88%E5%BC%95%E7%94%A8%EF%BC%8C%E6%8C%87%E9%92%88%EF%BC%89><span class=toc-text>传值方式（引用，指针）</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0%E5%92%8C%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB><span class=toc-text>内联函数和函数的区别</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#C-%E4%BC%A0%E5%80%BC%E6%96%B9%E5%BC%8F%EF%BC%8C%E5%8C%BA%E5%88%AB><span class=toc-text>C++传值方式，区别</span></a><ol class=toc-child><li class="toc-item toc-level-4"><a class=toc-link href=#-5><span class=toc-text></span></a></li></ol></li><li class="toc-item toc-level-3"><a class=toc-link href=#C-x2F-C><span class=toc-text>C&#x2F;C++</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E5%AF%BC%E5%85%A5C%E5%87%BD%E6%95%B0%E5%85%B3%E9%94%AE%E5%AD%97><span class=toc-text>导入C函数关键字</span></a><ol class=toc-child><li class="toc-item toc-level-4"><a class=toc-link href=#-6><span class=toc-text></span></a></li></ol></li><li class="toc-item toc-level-3"><a class=toc-link href=#C-x2F-C-struct%E5%8C%BA%E5%88%AB><span class=toc-text>C&#x2F;C++ struct区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class=toc-link href=#%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B><span class=toc-text>程序执行过程</span></a><ol class=toc-child><li class="toc-item toc-level-3"><a class=toc-link href=#main%E6%89%A7%E8%A1%8C%E4%B9%8B%E5%89%8D%E5%92%8C%E4%B9%8B%E5%90%8E><span class=toc-text>main执行之前和之后</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#C-%E4%BB%A3%E7%A0%81%E5%88%B0%E5%8F%AF%E6%89%A7%E8%A1%8C%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6%E7%9A%84%E8%BF%87%E7%A8%8B><span class=toc-text>C++代码到可执行二进制文件的过程</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%E5%88%9D%E5%A7%8B%E5%8C%96><span class=toc-text>静态变量初始化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class=toc-link href=#STL><span class=toc-text>STL</span></a><ol class=toc-child><li class="toc-item toc-level-3"><a class=toc-link href=#%E4%BB%80%E4%B9%88%E6%98%AFSTL%EF%BC%9F><span class=toc-text>什么是STL？</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#STL-%E7%B4%A2%E5%BC%95><span class=toc-text>STL 索引</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#STL-%E5%AE%B9%E5%99%A8><span class=toc-text>STL 容器</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#STL-%E7%AE%97%E6%B3%95><span class=toc-text>STL 算法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class=toc-link href=#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8F%8A%E5%85%B6%E7%AE%97%E6%B3%95><span class=toc-text>数据结构及其算法</span></a></li><li class="toc-item toc-level-2"><a class=toc-link href=#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%85%B3><span class=toc-text>操作系统相关</span></a></li><li class="toc-item toc-level-2"><a class=toc-link href=#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C><span class=toc-text>计算机网络</span></a></li><li class="toc-item toc-level-2"><a class=toc-link href=#Linux%E5%91%BD%E4%BB%A4><span class=toc-text>Linux命令</span></a></li></ol></div></div></div></main><section id=rightside><div class=rightside-item><a id=open-toc title=目录><i class="fas fa-list-ul"></i> </a><a href=javascript:void(0); id=darkmode title="深色/浅色 "><i class="fas fa-moon"></i> </a><a href=#直达评论 title=直达评论><i class="fas fa-comments"></i> </a><a href=# title=回到顶部><i class="fas fa-arrow-up"></i></a></div></section><footer class=footer id=footer><div class=copyright>&copy; 2020 - 2022 <i class="fas fa-fan"></i> 森森</div><div class=framework-info><span>框架</span> <a href=https://hexo.io target=_blank>Hexo</a> <span class=footer-separator>|</span> <span>主题 </span><a href=https://github.com/lete114/hexo-theme-MengD target=_blank>MengD.(萌典)</a></div><div class=custom-text>我相信我可以，但我一直在路上，所以我有无限的可能！！</div></footer></div><div id=mask onclick=closeAll()></div><div class=script><script src=/js/main.js></script><script>var titleTime,originTitle=document.title;document.addEventListener("visibilitychange",function(){document.hidden?(document.title="(つェ⊂) 我藏好了哦~ "+originTitle,clearTimeout(titleTime)):(document.title="(*´∇｀*) 被你发现啦~ "+originTitle,titleTime=setTimeout(function(){document.title=originTitle},2e3))})</script><script>function LoadPjax(){window.pjax=new Pjax({selectors:["head title",'head meta[name="keywords"]','head meta[name="description"]',"main","#rightside"],cacheBust:!1})}getScript("https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js",LoadPjax);var timer=null;function ProgressStart(){var e="pjax-progress",t=$query("."+e),r=10;t||((t=document.createElement("div")).className=e,document.body.prepend(t));clearInterval(timer),timer=setInterval(function(){var e=parseInt(7*Math.random());95<(r+=e+3)&&(r=95),t.style.width=r+"%"},500)}function ProgressFinish(){clearInterval(timer);var e=$query(".pjax-progress");e.style.width="100%",timer=setTimeout(function(){e.parentNode.removeChild(e)},700)}document.addEventListener("pjax:send",function(){ProgressStart()}),document.addEventListener("pjax:complete",function(){ProgressFinish(),exeAllFn(),document.querySelectorAll("script[data-pjax]").forEach(e=>{const t=document.createElement("script");var r=e.text||e.textContent||e.innerHTML||"";Array.from(e.attributes).forEach(e=>t.setAttribute(e.name,e.value)),t.appendChild(document.createTextNode(r)),e.parentNode.replaceChild(t,e)})}),document.addEventListener("pjax:error",e=>{404===e.request.status&&pjax.loadUrl("/404.html")})</script></div></body></html>