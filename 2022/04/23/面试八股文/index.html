<!DOCTYPE html><html><head><meta charset=UTF-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=0"><title>C++面试八股文 | 森森成长日记</title><meta name=author content=森森><meta name=copyright content=森森><link rel="shortcut icon" href=http://example.com/img/favicon.png><meta name=description content="面向对象多态分类及实现 静态多态：函数重载，运算符重载，函数模版（函数模版的代码会经过两次编译，第一次在申明的位置编译函数代码本身，仅生成函数头，第二次在调用的地方对参数替换后的代码进行编译，实际上就是编译器替我们写对应数据类型的函数）  &#x2F;&#x2F;函数重载    void fun(int a)&amp;#123;  &#x2F;&#x2F;参数类型不同        cout&lt;&lt;&quot;this is int&amp;q"><meta property=og:type content=article><meta property=og:title content=C++面试八股文><meta property=og:url content=http://example.com/2022/04/23/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1%E6%96%87/ ><meta property=og:site_name content=森森成长日记><meta property=og:description content="面向对象多态分类及实现 静态多态：函数重载，运算符重载，函数模版（函数模版的代码会经过两次编译，第一次在申明的位置编译函数代码本身，仅生成函数头，第二次在调用的地方对参数替换后的代码进行编译，实际上就是编译器替我们写对应数据类型的函数）  &#x2F;&#x2F;函数重载    void fun(int a)&amp;#123;  &#x2F;&#x2F;参数类型不同        cout&lt;&lt;&quot;this is int&amp;q"><meta property=og:locale content=zh_CN><meta property=og:image content=http://example.com/img/logo.gif><meta property=article:published_time content=2022-04-23T11:08:41.079Z><meta property=article:modified_time content=2022-04-25T03:59:05.926Z><meta property=article:author content=森森><meta name=twitter:card content=summary><meta name=twitter:image content=http://example.com/img/logo.gif><meta http-equiv=Cache-Control content=no-siteapp><link href=https://cdn.jsdelivr.net rel=preconnect><link href=http://example.com rel=prefetch><link href=https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css rel=stylesheet><link href=/css/main.css rel=stylesheet><script src=/js/utlis.js></script><script>!function(){var t=$query("html");"true"===localStorage.isDark?t.setAttribute("theme","dark"):t.removeAttribute("theme")}()</script><meta name=generator content="Hexo 6.1.0"></head><body><script>var $config={CDN:{fancyboxJs:"https://cdn.jsdelivr.net/npm/@fancyapps/ui@4.0.26/dist/fancybox.umd.js",fancyboxCss:"https://cdn.jsdelivr.net/npm/@fancyapps/ui@4.0.26/dist/fancybox.css"},codeBlockExpand:{enable:!0,height:400,scrollTop:200}}</script><div id=body-wrap><nav id=nav-wrap><div class=navbar><div class=bar><a href=/ class=title>森森成长日记</a><ul class=menu></ul><i class="fas fa-bars open-nav"></i></div></div><div id=mobile-nav><ul></ul></div></nav><header id=header><div class=header-author><a href=/ class=author><img src=/img/logo.gif alt=森森 class=author-avatar><div class=author-name>森森</div></a></div><div class=header-description><p></p><div class=header-icon></div></div></header><main id=main><article id=post><div class=post-info><div class=post-title><h1>C++面试八股文</h1></div><div class=post-meta><div class=post-date><i class="far fa-calendar-alt fa-fw post-meta-icon"></i> <span class=post-meta-label>发表于 2022-04-23 | </span><i class="fas fa-history fa-fw post-meta-icon"></i> <span class=post-meta-label>更新于 2022-04-25</span></div><div class=post-meta-wordcount><i class="far fa-file-word fa-fw post-meta-icon"></i> <span class=post-meta-label>总字数:</span> <span class=word-count>38k | </span><i class="far fa-clock fa-fw post-meta-icon"></i> <span class=post-meta-label>阅读时长:</span> <span>149分钟</span> | <i class="far fa-eye fa-fw post-meta-icon"></i> <span class=post-meta-label>阅读量:</span> <span id=Discuss-Visitors>0</span></div></div></div><div class=post-content><h2 id=面向对象><a href=#面向对象 class=headerlink title=面向对象></a>面向对象</h2><h3 id=多态分类及实现><a href=#多态分类及实现 class=headerlink title=多态分类及实现></a>多态分类及实现</h3><blockquote><p><code>静态多态：函数重载，运算符重载，函数模版</code>（函数模版的代码会经过两次编译，第一次在申明的位置编译函数代码本身，仅生成函数头，第二次在调用的地方对参数替换后的代码进行编译，实际上就是编译器替我们写对应数据类型的函数）</p></blockquote><figure class="highlight c++"><table><tr><td class=code><pre><span class=line><span class=comment>//函数重载    </span></span><br><span class=line><span class=function><span class=type>void</span> <span class=title>fun</span><span class=params>(<span class=type>int</span> a)</span></span>&#123;  <span class=comment>//参数类型不同  </span></span><br><span class=line>      cout&lt;&lt;<span class=string>&quot;this is int&quot;</span>&lt;&lt;endl;  </span><br><span class=line>  &#125;  </span><br><span class=line></span><br><span class=line>  <span class=function><span class=type>void</span> <span class=title>fun</span><span class=params>(<span class=type>int</span> a,<span class=type>int</span> b)</span></span>&#123;  </span><br><span class=line>      cout&lt;&lt;<span class=string>&quot;this is int int&quot;</span>;  </span><br><span class=line>  &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class=code><pre><span class=line>//运算符重载，对于两个int类型，编译器知道怎么相加，但是对于自定义的数据类型，编译器就不知道了  </span><br><span class=line>//可以自定义+号，进行自定义的数据类型相加，这就是运算符重载  </span><br><span class=line>class Person &#123;  </span><br><span class=line>public:  </span><br><span class=line>	Person() &#123;&#125;;   </span><br><span class=line>	Person(int a, int b)  </span><br><span class=line>	&#123;  </span><br><span class=line>		this-&gt;m_A = a;  </span><br><span class=line>		this-&gt;m_B = b;  </span><br><span class=line>	&#125;  </span><br><span class=line>	//成员函数实现 + 号运算符重载   </span><br><span class=line>	Person operator+(const Person&amp; p) &#123;   //在类内定义运算符重载  </span><br><span class=line>		Person temp;					// 实际调用为 Person p3;  </span><br><span class=line>		temp.m_A = this-&gt;m_A + p.m_A;   // p3 = poperator+(p2);  这个是本质  </span><br><span class=line>		temp.m_B = this-&gt;m_B + p.m_B;   //但是编辑器简化为  </span><br><span class=line>		return temp;		// p3 = p1 + p2;   实际运行的时候编译器会把这个转化为上面这个  </span><br><span class=line>	&#125;  </span><br><span class=line>public:  </span><br><span class=line>	int m_A;  </span><br><span class=line>	int m_B;  </span><br><span class=line>&#125;;  </span><br><span class=line>//全局函数实现 + 号运算符重载  </span><br><span class=line>//Person operator+(const Person&amp; p1, const Person&amp; p2) &#123;  </span><br><span class=line>//	Person temp(0, 0);          //本质上是Person p3 = operator+(p1,p2);  </span><br><span class=line>//	temp.m_A = pm_A + pm_A;	//但是有编译器存在，可以写成  </span><br><span class=line>//	temp.m_B = pm_B + pm_B;//Person p3 = p1 + p2 ;编译器会自动转化为上面的  </span><br><span class=line>//	return temp;  </span><br><span class=line>//&#125;  </span><br><span class=line>//运算符重载 可以发生函数重载   </span><br><span class=line>Person operator+(const Person&amp; p2, int val)    </span><br><span class=line>&#123;  </span><br><span class=line>	Person temp;            //Person p2 = p1 + 10;  </span><br><span class=line>	temp.m_A = pm_A + val;// 运算符重载的函数重载，第一次重载+号，第二次传入不同的数据类型重载  </span><br><span class=line>	temp.m_B = pm_B + val;  </span><br><span class=line>	return temp;  </span><br><span class=line>&#125;  </span><br><span class=line>void test() &#123;  </span><br><span class=line>	Person p1(10, 10);  </span><br><span class=line>	Person p2(20, 20);  </span><br><span class=line>	//成员函数方式  </span><br><span class=line>	Person p3 = p2 + p1;  //相当于 poperaor+(p1)  </span><br><span class=line>	cout &lt;&lt; &quot;mA:&quot; &lt;&lt; pm_A &lt;&lt; &quot; mB:&quot; &lt;&lt; pm_B &lt;&lt; endl;  </span><br><span class=line></span><br><span class=line>	Person p4 = p3 + 10; //相当于 operator+(p3,10)  </span><br><span class=line>	cout &lt;&lt; &quot;mA:&quot; &lt;&lt; pm_A &lt;&lt; &quot; mB:&quot; &lt;&lt; pm_B &lt;&lt; endl;  </span><br><span class=line>&#125;  </span><br><span class=line>int main() &#123;  </span><br><span class=line>	test();  </span><br><span class=line>	system(&quot;pause&quot;);  </span><br><span class=line>	return 0;  </span><br><span class=line>&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class=code><pre><span class=line><span class=comment>//交换整型函数  </span></span><br><span class=line><span class=function><span class=type>void</span> <span class=title>swapInt</span><span class=params>(<span class=type>int</span>&amp; a, <span class=type>int</span>&amp; b)</span> </span>&#123;  </span><br><span class=line>	<span class=type>int</span> temp = a;  </span><br><span class=line>	a = b;  </span><br><span class=line>	b = temp;  </span><br><span class=line>&#125;  </span><br><span class=line><span class=comment>//交换浮点型函数  </span></span><br><span class=line><span class=function><span class=type>void</span> <span class=title>swapDouble</span><span class=params>(<span class=type>double</span>&amp; a, <span class=type>double</span>&amp; b)</span> </span>&#123;  </span><br><span class=line>	<span class=type>double</span> temp = a;  </span><br><span class=line>	a = b;  </span><br><span class=line>	b = temp;  </span><br><span class=line>&#125;  </span><br><span class=line><span class=comment>//利用模板提供通用的交换函数  </span></span><br><span class=line><span class=keyword>template</span>&lt;<span class=keyword>typename</span> T&gt; <span class=comment>//typename可以用class替代  </span></span><br><span class=line><span class=function><span class=type>void</span> <span class=title>mySwap</span><span class=params>(T&amp; a, T&amp; b)</span> <span class=comment>//也可以定义多个数据类型  </span></span></span><br><span class=line><span class=function></span>&#123;						<span class=comment>//如 template&lt;class T1,class T2&gt;  </span></span><br><span class=line>	T temp = a;  </span><br><span class=line>	a = b;  </span><br><span class=line>	b = temp;  </span><br><span class=line>&#125;  </span><br><span class=line><span class=function><span class=type>void</span> <span class=title>test01</span><span class=params>()</span>  </span></span><br><span class=line><span class=function></span>&#123;  </span><br><span class=line>	<span class=type>int</span> a = <span class=number>10</span>;  </span><br><span class=line>	<span class=type>int</span> b = <span class=number>20</span>;  </span><br><span class=line>	<span class=comment>//swapInt(a, b);  </span></span><br><span class=line>	<span class=comment>//利用模板实现交换  </span></span><br><span class=line>	<span class=comment>//1、自动类型推导  </span></span><br><span class=line>	<span class=built_in>mySwap</span>(a, b);  </span><br><span class=line>	<span class=comment>//2、显示指定类型  </span></span><br><span class=line>	<span class=built_in>mySwap</span>&lt;<span class=type>int</span>&gt;(a, b); <span class=comment>//多个类型，mySwap&lt;int,double&gt;(a,b);  </span></span><br><span class=line>	cout &lt;&lt; <span class=string>&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;  </span><br><span class=line>	cout &lt;&lt; <span class=string>&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl;  </span><br><span class=line>&#125;  </span><br><span class=line><span class=function><span class=type>int</span> <span class=title>main</span><span class=params>()</span> </span>&#123;  </span><br><span class=line>	<span class=built_in>test01</span>();  </span><br><span class=line>	<span class=built_in>system</span>(<span class=string>&quot;pause&quot;</span>);  </span><br><span class=line>	<span class=keyword>return</span> <span class=number>0</span>;  </span><br><span class=line>&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>动态多态（运行期/晚绑定）</code></p></blockquote><figure class="highlight c++"><table><tr><td class=code><pre><span class=line><span class=keyword>class</span> <span class="title class_">Animal</span>  </span><br><span class=line>&#123;  </span><br><span class=line><span class=keyword>public</span>:  </span><br><span class=line>	<span class=comment>//Speak函数就是虚函数  </span></span><br><span class=line>	<span class=comment>//函数前面加上virtual关键字，变成虚函数，那么编译器在编译的时候就不能确定函数调用了。  </span></span><br><span class=line>	<span class=function><span class=keyword>virtual</span> <span class=type>void</span> <span class=title>speak</span><span class=params>()</span>  </span></span><br><span class=line><span class=function>	</span>&#123;  </span><br><span class=line>		cout &lt;&lt; <span class=string>&quot;动物在说话&quot;</span> &lt;&lt; endl;  </span><br><span class=line>	&#125;  </span><br><span class=line>&#125;;  </span><br><span class=line><span class=keyword>class</span> <span class="title class_">Cat</span> :<span class=keyword>public</span> Animal  </span><br><span class=line>&#123;  </span><br><span class=line><span class=keyword>public</span>:  </span><br><span class=line>	<span class=function><span class=type>void</span> <span class=title>speak</span><span class=params>()</span>  </span></span><br><span class=line><span class=function>	</span>&#123;  </span><br><span class=line>		cout &lt;&lt; <span class=string>&quot;小猫在说话&quot;</span> &lt;&lt; endl;  </span><br><span class=line>	&#125;  </span><br><span class=line>&#125;;  </span><br><span class=line><span class=keyword>class</span> <span class="title class_">Dog</span> :<span class=keyword>public</span> Animal  </span><br><span class=line>&#123;  </span><br><span class=line><span class=keyword>public</span>:  </span><br><span class=line>	<span class=function><span class=type>void</span> <span class=title>speak</span><span class=params>()</span>  </span></span><br><span class=line><span class=function>	</span>&#123;  </span><br><span class=line>		cout &lt;&lt; <span class=string>&quot;小狗在说话&quot;</span> &lt;&lt; endl;  </span><br><span class=line>	&#125;  </span><br><span class=line>&#125;;  </span><br><span class=line><span class=comment>//我们希望传入什么对象，那么就调用什么对象的函数  </span></span><br><span class=line><span class=comment>//如果函数地址在编译阶段就能确定，那么静态联编  </span></span><br><span class=line><span class=comment>//如果函数地址在运行阶段才能确定，就是动态联编  </span></span><br><span class=line><span class=function><span class=type>void</span> <span class=title>DoSpeak</span><span class=params>(Animal &amp; animal)</span>  </span></span><br><span class=line><span class=function></span>&#123;  </span><br><span class=line>	animal.<span class=built_in>speak</span>();  </span><br><span class=line>&#125;  </span><br><span class=line><span class=comment>//多态满足条件：   </span></span><br><span class=line><span class=comment>//1、有继承关系  </span></span><br><span class=line><span class=comment>//2、子类重写父类中的虚函数  </span></span><br><span class=line><span class=comment>//多态使用：  </span></span><br><span class=line><span class=comment>//父类指针或引用指向子类对象  </span></span><br><span class=line><span class=function><span class=type>void</span> <span class=title>test01</span><span class=params>()</span>  </span></span><br><span class=line><span class=function></span>&#123;  </span><br><span class=line>	Cat cat;  </span><br><span class=line>	<span class=built_in>DoSpeak</span>(cat);  </span><br><span class=line>	Dog dog;  </span><br><span class=line>	<span class=built_in>DoSpeak</span>(dog);  </span><br><span class=line>&#125;  </span><br><span class=line><span class=function><span class=type>int</span> <span class=title>main</span><span class=params>()</span> </span>&#123;  </span><br><span class=line>	<span class=built_in>test01</span>();  </span><br><span class=line>	<span class=built_in>system</span>(<span class=string>&quot;pause&quot;</span>);  </span><br><span class=line>	<span class=keyword>return</span> <span class=number>0</span>;  </span><br><span class=line>&#125;</span><br></pre></td></tr></table></figure><h3 id=动态多态实现原理><a href=#动态多态实现原理 class=headerlink title=动态多态实现原理></a>动态多态实现原理</h3><ul><li>虚函数指针：在含有虚函数类的对象中，是对象所有，指向虚函数表，在运行时确定。（64位系统8字节）</li><li>虚函数表：在含有虚函数的类中，为类所有，如果派生类实现了基类的某个虚函数，则在虚表中覆盖原本基类的那个虚函数指针，在编译时根据类的声明创建。</li><li>创建对象的时候，会根据这个对象的类型给这个对象的虚函数指针进行赋值，即是什么类型的对象虚指针就指向该对象下的虚表，如果是创建子类对象，会先调用父类的构造函数，在调用子类的构造函数，所以虚指针指向子类的虚表</li><li>如果子类没有对父类的虚函数重写，则子类的虚表的内容还是和父类的虚表的内容一样；如果重写了，替换重写之后的虚函数；如果自己还有增加的虚函数，则把虚函数的地址也存放到虚表的后面</li><li>当父类的指针指向子类的对象时，根据虚指针就能访问子类的虚函数；</li></ul><h3 id=构造函数的分类及调用><a href=#构造函数的分类及调用 class=headerlink title=构造函数的分类及调用></a>构造函数的分类及调用</h3><blockquote><p>两种分类方式：</p></blockquote><blockquote><p>按参数分为： <code>有参构造和无参构造</code></p></blockquote><blockquote><p>按类型分为： <code>普通构造和拷贝构造，移动构造函数</code></p></blockquote><blockquote><p>三种调用方式：<code>括号法，显示法隐式转换法</code></p></blockquote><blockquote><p><code>示例：</code></p></blockquote><figure class="highlight plaintext"><table><tr><td class=code><pre><span class=line>//1、构造函数分类  </span><br><span class=line>// 按照参数分类分为 有参和无参构造   无参又称为默认构造函数  </span><br><span class=line>// 按照类型分类分为 普通构造和拷贝构造  </span><br><span class=line>class Person &#123;  </span><br><span class=line>public:  </span><br><span class=line>	//无参（默认）构造函数  </span><br><span class=line>	Person() &#123;  </span><br><span class=line>		cout &lt;&lt; &quot;无参构造函数!&quot; &lt;&lt; endl;  </span><br><span class=line>	&#125;  </span><br><span class=line>	//有参构造函数  </span><br><span class=line>	Person(int a) &#123;  </span><br><span class=line>		age = a;  </span><br><span class=line>		cout &lt;&lt; &quot;有参构造函数!&quot; &lt;&lt; endl;  </span><br><span class=line>	&#125;  </span><br><span class=line>	//拷贝构造函数  </span><br><span class=line>	Person(const Person&amp; p) &#123;  </span><br><span class=line>		age = p.age;  </span><br><span class=line>		cout &lt;&lt; &quot;拷贝构造函数!&quot; &lt;&lt; endl;  </span><br><span class=line>	&#125;  </span><br><span class=line>	//析构函数  </span><br><span class=line>	~Person() &#123;  </span><br><span class=line>		cout &lt;&lt; &quot;析构函数!&quot; &lt;&lt; endl;  </span><br><span class=line>	&#125;  </span><br><span class=line>public:  </span><br><span class=line>	int age;  </span><br><span class=line>&#125;;  </span><br><span class=line>//2、构造函数的调用  </span><br><span class=line>//调用无参构造函数  </span><br><span class=line>void test01() &#123;  </span><br><span class=line>	Person p; //调用无参构造函数  </span><br><span class=line>    //注意1：调用无参构造函数不能加括号，如果加了编译器认为这是一个函数声明  </span><br><span class=line>	//Person p2(); //函数声明  </span><br><span class=line>&#125;  </span><br><span class=line>//调用有参的构造函数  </span><br><span class=line>void test02() &#123;  </span><br><span class=line>	//1  括号法，常用  </span><br><span class=line>	Person p1(10);  </span><br><span class=line>	//2 显式法  </span><br><span class=line>	Person p2 = Person(10); //拷贝构造  </span><br><span class=line>	Person p3 = Person(p2); //拷贝构造  </span><br><span class=line>	//Person(10)单独写就是匿名对象  当前行结束之后，马上析构  </span><br><span class=line>	//3 隐式转换法  </span><br><span class=line>	Person p4 = 10; // Person p4 = Person(10);   //拷贝构造  </span><br><span class=line>	Person p5 = p4; // Person p5 = Person(p4);  //拷贝构造  </span><br><span class=line>	//注意2：不能利用 拷贝构造函数 初始化匿名对象 编译器认为是对象声明  </span><br><span class=line>	//Person p5(p4); //函数声明  </span><br><span class=line>&#125;  </span><br><span class=line>int main() &#123;  </span><br><span class=line>	test01();  </span><br><span class=line>	//test02();  </span><br><span class=line>	system(&quot;pause&quot;);  </span><br><span class=line>	return 0;  </span><br><span class=line>&#125;</span><br></pre></td></tr></table></figure><ul><li>移动构造函数。用于将其他类型的变量，隐式转换为本类对象。下面的转换构造函数，将int类型的r转换为Student类型的对象，对象的age为r，num为1004.</li></ul><figure class="highlight plaintext"><table><tr><td class=code><pre><span class=line>Student(int r) &#123;   </span><br><span class=line>int num=1004;   </span><br><span class=line>int age= r;   </span><br><span class=line>&#125;</span><br></pre></td></tr></table></figure><ul><li><blockquote><p><code>有了有参的构造了，编译器就不提供默认的构造函数。所以写了有参构造，一定要写无参构造</code></p></blockquote></li><li><blockquote><p><code>如果没有属性要求在堆区开辟，深浅拷贝无所谓,深拷贝针对有属性在堆区开辟</code></p></blockquote></li><li><blockquote><p><code>只定义了析构函数，编译器将自动为我们生成拷贝构造函数和默认构造函数。</code></p></blockquote></li></ul><h3 id=构造函数、析构函数调用顺序><a href=#构造函数、析构函数调用顺序 class=headerlink title=构造函数、析构函数调用顺序></a>构造函数、析构函数调用顺序</h3><ul><li>子类继承了父类，子类构造的时候，会先调用父类的构造函数对其初始化，再调用子类的构造函数（如果子类重写了构造函数，将覆盖父类构造函数初始化的值，如果子类有新的成员变量，则会调用子类构造函数阶段赋值）</li><li>子类析构的时候，会先调用自身的析构函数，然后调用父类的析构函数</li><li>**父类指针析构的时候，会调用自身的析构函数，不会调用子类的析构函数，当实现多态的时候（父类指针指向子类对象），将父类析构函数设置为虚函数，这样父类析构的时候会先调用子类的析构函数，再调用父类的析构函数 **</li></ul><h3 id=构造函数为什么不能虚函数><a href=#构造函数为什么不能虚函数 class=headerlink title=构造函数为什么不能虚函数></a>构造函数为什么不能虚函数</h3><ol><li>从存储空间角度：调用虚函数需要虚指针，而对象还没有构造，显然没有虚指针（悖论）</li><li>从使用角度：虚函数主要是为了实现多态，而构造函数没有这方面的必要。</li><li>从实现上看，vtable 在构造函数调用后才建立，因而构造函数不可能成为虚函数。</li></ol><h3 id=拷贝构造函数的参数传递方式><a href=#拷贝构造函数的参数传递方式 class=headerlink title=拷贝构造函数的参数传递方式></a>拷贝构造函数的参数传递方式</h3><blockquote><p><code>参考回答</code></p></blockquote><ol><li><blockquote><p>拷贝构造函数的参数必须使用引用传递</p></blockquote></li><li><blockquote><p>如果拷贝构造函数中的参数不是一个引用，那么就相当于采用了传值的方式(pass-by-value)，而<code>传值的方式会调用该类的拷贝构造函数</code>，从而造成无穷递归地调用拷贝构造函数。因此拷贝构造函数的参数必须是一个引用。</p></blockquote><blockquote><p>需要澄清的是，<em><em>传指针其实也是传值，如果上面的拷贝构造函数写成CClass(const CClass</em> c_class)，也是不行的</em>*。事实上，只有传引用不是传值外，其他所有的传递方式都是传值。</p></blockquote></li></ol><h3 id=拷贝赋值和移动赋值？><a href=#拷贝赋值和移动赋值？ class=headerlink title=拷贝赋值和移动赋值？></a>拷贝赋值和移动赋值？</h3><blockquote><p><code>参考回答</code></p></blockquote><ol><li><blockquote><p>拷贝赋值是通过拷贝构造函数来赋值，在创建对象时，使用同一类中之前创建的对象来初始化新创建的对象。</p></blockquote></li><li><blockquote><p>移动赋值是通过移动构造函数来赋值，二者的主要区别在于</p></blockquote><blockquote><p>1）拷贝构造函数的形参是一个左值引用，而移动构造函数的形参是一个右值引用；</p></blockquote><blockquote><p>2）拷贝构造函数完成的是整个对象或变量的拷贝，而移动构造函数是生成一个指针指向源对象或变量的地址，接管源对象的内存，相对于大量数据的拷贝节省时间和内存空间。</p></blockquote></li></ol><h3 id=深拷贝与浅拷贝><a href=#深拷贝与浅拷贝 class=headerlink title=深拷贝与浅拷贝></a>深拷贝与浅拷贝</h3><blockquote><p><code>特别注意，深拷贝与浅拷贝如果不涉及到指针，则无区别</code></p></blockquote><blockquote><p><code>一般说的深拷贝与浅拷贝，涉及到指针的操作</code></p></blockquote><blockquote><p>浅拷贝：简单的赋值拷贝操作，<code>增加一个指针指向原来的区域</code></p></blockquote><blockquote><p>深拷贝：在堆区重新申请空间，进行拷贝操作<code>重新申请空间，拷贝值到所申请的空间</code></p></blockquote><blockquote><p><code>为什么需要深拷贝？ 因为如果重新增加一个指针指向原来的区域（浅拷贝），如果其中一个指针释放，那么其他的指针依然指向该空间，这些指针就会变成悬空指针</code></p></blockquote><blockquote><p><code>示例：</code></p></blockquote><figure class="highlight c++"><table><tr><td class=code><pre><span class=line><span class=keyword>class</span> <span class="title class_">Person</span> &#123;  </span><br><span class=line><span class=keyword>public</span>:  </span><br><span class=line>	<span class=comment>//无参（默认）构造函数  </span></span><br><span class=line>	<span class=built_in>Person</span>() &#123;  </span><br><span class=line>		cout &lt;&lt; <span class=string>&quot;无参构造函数!&quot;</span> &lt;&lt; endl;  </span><br><span class=line>	&#125;  </span><br><span class=line>	<span class=comment>//有参构造函数  </span></span><br><span class=line>	<span class=built_in>Person</span>(<span class=type>int</span> age ,<span class=type>int</span> height) &#123;  </span><br><span class=line>		cout &lt;&lt; <span class=string>&quot;有参构造函数!&quot;</span> &lt;&lt; endl;  </span><br><span class=line>		m_age = age;  </span><br><span class=line>		m_height = <span class=keyword>new</span> <span class=built_in>int</span>(height);  </span><br><span class=line>	&#125;  </span><br><span class=line>	<span class=comment>//拷贝构造函数    </span></span><br><span class=line>	<span class=built_in>Person</span>(<span class=type>const</span> Person&amp; p) &#123;  </span><br><span class=line>		cout &lt;&lt; <span class=string>&quot;拷贝构造函数!&quot;</span> &lt;&lt; endl;  </span><br><span class=line>		<span class=comment>//如果不利用深拷贝在堆区创建新内存，会导致浅拷贝带来的重复释放堆区问题  </span></span><br><span class=line>		m_age = p.m_age;  </span><br><span class=line>		m_height = <span class=keyword>new</span> <span class=built_in>int</span>(*p.m_height);  </span><br><span class=line>	&#125;  </span><br><span class=line>	<span class=comment>//析构函数  </span></span><br><span class=line>	~<span class=built_in>Person</span>() &#123;  </span><br><span class=line>		cout &lt;&lt; <span class=string>&quot;析构函数!&quot;</span> &lt;&lt; endl;  </span><br><span class=line>		<span class=keyword>if</span> (m_height != <span class=literal>NULL</span>)  </span><br><span class=line>		&#123;  </span><br><span class=line>			<span class=keyword>delete</span> m_height;  </span><br><span class=line>		&#125;  </span><br><span class=line>	&#125;  </span><br><span class=line><span class=keyword>public</span>:  </span><br><span class=line>	<span class=type>int</span> m_age;  </span><br><span class=line>	<span class=type>int</span>* m_height;  </span><br><span class=line>&#125;;  </span><br><span class=line><span class=function><span class=type>void</span> <span class=title>test01</span><span class=params>()</span>  </span></span><br><span class=line><span class=function></span>&#123;  </span><br><span class=line>	<span class=function>Person <span class=title>p1</span><span class=params>(<span class=number>18</span>, <span class=number>180</span>)</span></span>;  </span><br><span class=line>	<span class=function>Person <span class=title>p2</span><span class=params>(p1)</span></span>;  </span><br><span class=line>	cout &lt;&lt; <span class=string>&quot;p1的年龄： &quot;</span> &lt;&lt; pm_age &lt;&lt; <span class=string>&quot; 身高： &quot;</span> &lt;&lt; *pm_height &lt;&lt; endl;  </span><br><span class=line>	cout &lt;&lt; <span class=string>&quot;p2的年龄： &quot;</span> &lt;&lt; pm_age &lt;&lt; <span class=string>&quot; 身高： &quot;</span> &lt;&lt; *pm_height &lt;&lt; endl;  </span><br><span class=line>&#125;  </span><br><span class=line><span class=function><span class=type>int</span> <span class=title>main</span><span class=params>()</span> </span>&#123;  </span><br><span class=line>	<span class=built_in>test01</span>();  </span><br><span class=line>	<span class=built_in>system</span>(<span class=string>&quot;pause&quot;</span>);  </span><br><span class=line>	<span class=keyword>return</span> <span class=number>0</span>;  </span><br><span class=line>&#125;</span><br></pre></td></tr></table></figure><blockquote><blockquote><p>总结：如果属性有在堆区开辟的，一定要自己提供拷贝构造函数，防止浅拷贝带来的问题</p></blockquote></blockquote><h3 id=虚析构><a href=#虚析构 class=headerlink title=虚析构></a>虚析构</h3><ol><li><blockquote><p>虚析构：将可能会被继承的父类的析构函数设置为虚函数，可以保证当我们new一个子类，然后使用基类指针指向该子类对象，释放基类指针时可以释放掉子类的空间，防止内存泄漏。如果基类的析构函数不是虚函数，在特定情况下会导致派生来无法被析构。</p></blockquote><ol><li>用派生类类型指针绑定派生类实例，析构的时候，不管基类析构函数是不是虚函数，都会正常析构</li><li>用基类类型指针绑定派生类实例，析构的时候，如果基类析构函数不是虚函数，则只会析构基类，不会析构派生类对象，从而造成内存泄漏。</li></ol><blockquote><p>C++默认的析构函数不是虚函数是因为虚函数需要额外的虚函数表和虚表指针，占用额外的内存。而对于不会被继承的类来说，其析构函数如果是虚函数，就会浪费内存。<code>因此C++默认的析构函数不是虚函数，而是只有当需要当作父类时，设置为虚函数。</code></p></blockquote></li></ol><figure class="highlight plaintext"><table><tr><td class=code><pre><span class=line>class Shape  </span><br><span class=line>&#123;  </span><br><span class=line>public:  </span><br><span class=line>  Shape();                    // 构造函数不能是虚函数  </span><br><span class=line>  virtual double calcArea();  </span><br><span class=line>  virtual ~Shape();           // 虚析构函数  </span><br><span class=line>&#125;;  </span><br><span class=line>class Circle : public Shape     // 圆形类  </span><br><span class=line>&#123;  </span><br><span class=line>public:  </span><br><span class=line>  virtual double calcArea();  </span><br><span class=line>  ...  </span><br><span class=line>&#125;;  </span><br><span class=line>int main()  </span><br><span class=line>&#123;  </span><br><span class=line>  Shape * shape1 = new Circle(0);  </span><br><span class=line>  shape1-&gt;calcArea();      </span><br><span class=line>  delete shape1;  // 因为Shape有虚析构函数，所以delete释放内存时，先调用子类析构函数，再调用基类析构函数，防止内存泄漏。  </span><br><span class=line>  shape1 = NULL;  </span><br><span class=line>  return 0；  </span><br><span class=line>&#125;</span><br></pre></td></tr></table></figure><h3 id=虚函数、纯虚函数><a href=#虚函数、纯虚函数 class=headerlink title=虚函数、纯虚函数></a>虚函数、纯虚函数</h3><ul><li>纯虚函数只是一个接口，是个函数的声明而已，它要留到子类里去实现。</li><li>虚函数有具体实现，哪怕是空实现，在子类里面可以不重写；但纯虚函数必须在子类实现才可以实例化子类。</li><li>虚函数的类用于 “实作继承”，继承接口的同时也继承了父类的实现。纯虚函数关注的是接口的统一性，实现由子类完成。</li><li>带纯虚函数的类叫抽象类，这种类不能直接生成对象，而只有被继承，并重写其虚函数后，才能使用。抽象类被继承后，子类可以继续是抽象类，也可以是普通类。</li></ul><h3 id=虚继承（菱形继承）><a href=#虚继承（菱形继承） class=headerlink title=虚继承（菱形继承）></a>虚继承（菱形继承）</h3><blockquote><p>虚继承用于解决多继承条件下的菱形继承问题（浪费存储空间、存在二义性）。</p></blockquote><blockquote><p>底层实现原理与编译器相关，一般通过<code>虚基类指针</code>和<code>虚基类表</code>实现，每个虚继承的子类都有一个虚基类指针（占用一个指针的存储空间，4字节）和虚基类表（不占用类对象的存储空间）（需要强调的是，虚基类依旧会在子类里面存在拷贝，只是仅仅最多存在一份而已，并不是不在子类里面了）；当虚继承的子类被当做父类继承时，虚基类指针也会被继承。</p></blockquote><blockquote><p>实际上，vbptr 指的是虚基类表指针（virtual base table pointer），该指针指向了一个虚基类表（virtual table），虚表中记录了虚基类与本类的偏移地址；通过偏移地址，这样就找到了虚基类成员，而虚继承也不用像普通多继承那样维持着公共基类（虚基类）的两份同样的拷贝，节省了存储空间。</p></blockquote><blockquote><p>![image-20220413172857263](&#x2F;Users&#x2F;apple&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20220413172857263.png)</p></blockquote><h3 id=虚继承、虚函数对比><a href=#虚继承、虚函数对比 class=headerlink title=虚继承、虚函数对比></a>虚继承、虚函数对比</h3><ul><li>相同之处：都利用了虚指针（均占用类的存储空间）和虚表（均不占用类的存储空间）</li><li>不同之处：<ul><li>虚继承<ul><li>虚基类依旧存在继承类中，只占用存储空间</li><li>虚基类表存储的是虚基类相对直接继承类的偏移</li></ul></li><li>虚函数<ul><li>虚函数不占用存储空间</li><li>虚函数表存储的是虚函数地址</li></ul></li></ul></li></ul><h3 id=哪些函数不能被声明为虚函数><a href=#哪些函数不能被声明为虚函数 class=headerlink title=哪些函数不能被声明为虚函数></a>哪些函数不能被声明为虚函数</h3><blockquote><p><code>参考回答</code></p></blockquote><blockquote><p>常见的不不能声明为虚函数的有：<code>普通函数（非成员函数），静态成员函数，内联成员函数，构造函数，友元函数。</code></p></blockquote><ol><li><blockquote><p>为什么C++不支持普通函数为虚函数？</p></blockquote><blockquote><p>普通函数（非成员函数）只能被overload，不能被override，<code>声明为虚函数也没有什么意思，</code>因此编译器会在编译时绑定函数。</p></blockquote></li><li><blockquote><p>为什么C++不支持构造函数为虚函数？</p></blockquote><blockquote><p>这个原因很简单，主要是从语义上考虑，所以不支持。因为构造函数本来就是为了明确初始化对象成员才产生的，然而virtual function主要是为了再不完全了解细节的情况下也能正确处理对象。另外，virtual函数是在不同类型的对象产生不同的动作，现在对象还没有产生，如何使用virtual函数来完成你想完成的动作。（这不就是典型的悖论）</p></blockquote><blockquote><p>构造函数用来创建一个新的对象,而虚函数的运行是建立在对象的基础上,在构造函数执行时,对象尚未形成,所以不能将构造函数定义为虚函数</p></blockquote></li><li><blockquote><p>为什么C++不支持内联成员函数为虚函数？</p></blockquote><blockquote><p>其实很简单，那内联函数就是为了在代码中直接展开，减少函数调用花费的代价，虚函数是为了在继承后对象能够准确的执行自己的动作，这是不可能统一的。（再说了，<code>inline函数在编译时被展开，虚函数在运行时才能动态的绑定函数</code>）</p></blockquote><blockquote><p><code>内联函数是在编译时期展开,而虚函数的特性是运行时才动态联编,所以两者矛盾,不能定义内联函数为虚函数</code></p></blockquote></li><li><blockquote><p>为什么C++不支持静态成员函数为虚函数？</p></blockquote><blockquote><p>这也很简单，<code>静态成员函数对于每个类来说只有一份代码，所有的对象都共享这一份代码，他也没有要动态绑定的必要性。</code></p></blockquote><blockquote><p><code>静态成员函数属于一个类而非某一对象,没有this指针,它无法进行对象的判别</code></p></blockquote></li><li><blockquote><p>为什么C++不支持友元函数为虚函数？</p></blockquote><blockquote><p><code>因为C++不支持友元函数的继承，</code>对于没有继承特性的函数没有虚函数的说法。</p></blockquote></li></ol><h3 id=虚函数表里存放的内容是什么时候写进去的><a href=#虚函数表里存放的内容是什么时候写进去的 class=headerlink title=虚函数表里存放的内容是什么时候写进去的></a>虚函数表里存放的内容是什么时候写进去的</h3><blockquote><p><code>参考回答</code></p></blockquote><ol><li>虚函数表是一个存储虚函数地址的数组,以NULL结尾。<code>虚表（vftable）在编译阶段生成，对象内存空间开辟以后，写入对象中的 vfptr，然后调用构造函数。即：虚表在构造函数之前写入</code></li><li>除了在构造函数之前写入之外，我们还需要考虑到虚表的二次写入机制，通过此机制让每个对象的虚表指针都能准确的指向到自己类的虚表，为实现动多态提供支持。</li></ol><h3 id=override、final><a href=#override、final class=headerlink title=override、final></a>override、final</h3><p>当在父类中使用了虚函数时候，你可能需要在某个子类中对这个虚函数进行重写，以下方法都可以：如果不使用override，当你手一抖，将**foo()<strong>写成了</strong>f00()**会怎么样呢？结果是编译器并不会报错，因为它并不知道你的目的是重写虚函数，而是把它当成了新的函数。如果这个虚函数很重要的话，那就会对整个程序不利。所以，override的作用就出来了，它指定了子类的这个虚函数是重写的父类的，如果你名字不小心打错了的话，编译器是不会编译通过的：</p><p><strong>final</strong></p><p>当不希望某个类被继承，或不希望某个虚函数被重写，可以在类名和虚函数后添加final关键字，添加final关键字后被继承或重写，编译器会报错。例子如下：</p><h3 id=重写、重载、隐藏><a href=#重写、重载、隐藏 class=headerlink title=重写、重载、隐藏></a>重写、重载、隐藏</h3><p>1）重载（overload）</p><p>重载是指在同一范围定义中的同名成员函数才存在重载关系。主要特点是函数名相同，参数类型和数目有所不同，不能出现参数个数和类型均相同，仅仅依靠返回值不同来区分的函数。重载和函数成员是否是虚函数无关</p><figure class="highlight c++"><table><tr><td class=code><pre><span class=line><span class=keyword>class</span> <span class="title class_">A</span>&#123;</span><br><span class=line>    ... <span class=comment>//函数重载（参数类型不同或者个数不同）</span></span><br><span class=line>    <span class=function><span class=keyword>virtual</span> <span class=type>int</span> <span class=title>fun</span><span class=params>()</span></span>; </span><br><span class=line>    <span class=function><span class=type>void</span> <span class=title>fun</span><span class=params>(<span class=type>int</span>)</span></span>;</span><br><span class=line>    <span class=function><span class=type>void</span> <span class=title>fun</span><span class=params>(<span class=type>double</span>, <span class=type>double</span>)</span></span>;</span><br><span class=line>    <span class=function><span class=type>static</span> <span class=type>int</span> <span class=title>fun</span><span class=params>(<span class=type>char</span>)</span></span>;</span><br><span class=line>    ...</span><br><span class=line>&#125;</span><br></pre></td></tr></table></figure><p>2）重写（覆盖）（override）</p><p>重写指的是在派生类中覆盖基类中的同名函数，<strong>重写就是重写函数体</strong>，<strong>要求基类函数必须是虚函数</strong>且：</p><ul><li>与基类的虚函数有相同的参数个数</li><li>与基类的虚函数有相同的参数类型</li><li>与基类的虚函数有相同的返回值类型</li></ul><p>重载与重写的区别：</p><ul><li>重写是父类和子类之间的垂直关系，重载是不同函数之间的水平关系</li><li>重写要求参数列表相同，重载则要求参数列表不同，返回值不要求</li><li>重写关系中，调用方法根据对象类型决定，重载根据调用时实参表与形参表的对应关系来选择函数体</li></ul><figure class="highlight c++"><table><tr><td class=code><pre><span class=line><span class=comment>//父类</span></span><br><span class=line><span class=keyword>class</span> <span class="title class_">A</span>&#123;</span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>    <span class=function><span class=keyword>virtual</span> <span class=type>int</span> <span class=title>fun</span><span class=params>(<span class=type>int</span> a)</span></span>&#123;&#125;</span><br><span class=line>&#125;</span><br><span class=line><span class=comment>//子类</span></span><br><span class=line><span class=keyword>class</span> <span class="title class_">B</span> : <span class=keyword>public</span> A&#123;</span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>    <span class=comment>//重写,一般加override可以确保是重写父类的函数</span></span><br><span class=line>    <span class=function><span class=keyword>virtual</span> <span class=type>int</span> <span class=title>fun</span><span class=params>(<span class=type>int</span> a)</span> <span class=keyword>override</span></span>&#123;&#125;</span><br><span class=line>&#125;</span><br></pre></td></tr></table></figure><p>3)隐藏指的是某些情况下，派生类中的函数屏蔽了基类中的同名函数，包括以下情况：</p><ul><li>两个函数参数相同，但是基类函数不是虚函数。<strong>和重写的区别在于基类函数是否是虚函数。</strong>举个例子：</li></ul><figure class="highlight c++"><table><tr><td class=code><pre><span class=line><span class=comment>//父类</span></span><br><span class=line><span class=keyword>class</span> <span class="title class_">A</span>&#123;</span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>    <span class=function><span class=type>void</span> <span class=title>fun</span><span class=params>(<span class=type>int</span> a)</span></span>&#123;</span><br><span class=line>        cout &lt;&lt; <span class=string>&quot;A中的fun函数&quot;</span> &lt;&lt; endl;</span><br><span class=line>    &#125;</span><br><span class=line>&#125;;</span><br><span class=line><span class=comment>//子类</span></span><br><span class=line><span class=keyword>class</span> <span class="title class_">B</span> : <span class=keyword>public</span> A&#123;</span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>    <span class=comment>//隐藏父类的fun函数</span></span><br><span class=line>    <span class=function><span class=type>void</span> <span class=title>fun</span><span class=params>(<span class=type>int</span> a)</span></span>&#123;</span><br><span class=line>        cout &lt;&lt; <span class=string>&quot;B中的fun函数&quot;</span> &lt;&lt; endl;</span><br><span class=line>    &#125;</span><br><span class=line>&#125;;</span><br><span class=line><span class=function><span class=type>int</span> <span class=title>main</span><span class=params>()</span></span>&#123;</span><br><span class=line>    B b;</span><br><span class=line>    b.<span class=built_in>fun</span>(<span class=number>2</span>); <span class=comment>//调用的是B中的fun函数</span></span><br><span class=line>    b.A::<span class=built_in>fun</span>(<span class=number>2</span>); <span class=comment>//调用A中fun函数</span></span><br><span class=line>    <span class=keyword>return</span> <span class=number>0</span>;</span><br><span class=line>&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class=code><pre><span class=line>两个函数参数不同，无论基类函数是不是虚函数，都会被隐藏。和重载的区别在于两个函数不在同一个类中。举个例子：</span><br><span class=line><span class=comment>//父类</span></span><br><span class=line><span class=keyword>class</span> <span class="title class_">A</span>&#123;</span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>    <span class=function><span class=keyword>virtual</span> <span class=type>void</span> <span class=title>fun</span><span class=params>(<span class=type>int</span> a)</span></span>&#123;</span><br><span class=line>        cout &lt;&lt; <span class=string>&quot;A中的fun函数&quot;</span> &lt;&lt; endl;</span><br><span class=line>    &#125;</span><br><span class=line>&#125;;</span><br><span class=line><span class=comment>//子类</span></span><br><span class=line><span class=keyword>class</span> <span class="title class_">B</span> : <span class=keyword>public</span> A&#123;</span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>    <span class=comment>//隐藏父类的fun函数</span></span><br><span class=line>   <span class=function><span class=keyword>virtual</span> <span class=type>void</span> <span class=title>fun</span><span class=params>(<span class=type>char</span>* a)</span></span>&#123;</span><br><span class=line>       cout &lt;&lt; <span class=string>&quot;A中的fun函数&quot;</span> &lt;&lt; endl;</span><br><span class=line>   &#125;</span><br><span class=line>&#125;;</span><br><span class=line><span class=function><span class=type>int</span> <span class=title>main</span><span class=params>()</span></span>&#123;</span><br><span class=line>    B b;</span><br><span class=line>    b.<span class=built_in>fun</span>(<span class=number>2</span>); <span class=comment>//报错，调用的是B中的fun函数，参数类型不对</span></span><br><span class=line>    b.A::<span class=built_in>fun</span>(<span class=number>2</span>); <span class=comment>//调用A中fun函数</span></span><br><span class=line>    <span class=keyword>return</span> <span class=number>0</span>;</span><br><span class=line>&#125;</span><br><span class=line>Copy to clipboardErrorCopied</span><br><span class=line>补充：</span><br><span class=line></span><br><span class=line><span class=comment>// 父类</span></span><br><span class=line><span class=keyword>class</span> <span class="title class_">A</span> &#123;</span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>    <span class=function><span class=keyword>virtual</span> <span class=type>void</span> <span class=title>fun</span><span class=params>(<span class=type>int</span> a)</span> </span>&#123; <span class=comment>// 虚函数</span></span><br><span class=line>        cout &lt;&lt; <span class=string>&quot;This is A fun &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class=line>    &#125;  </span><br><span class=line>    <span class=function><span class=type>void</span> <span class=title>add</span><span class=params>(<span class=type>int</span> a, <span class=type>int</span> b)</span> </span>&#123;</span><br><span class=line>        cout &lt;&lt; <span class=string>&quot;This is A add &quot;</span> &lt;&lt; a + b &lt;&lt; endl;</span><br><span class=line>    &#125;</span><br><span class=line>&#125;;</span><br><span class=line></span><br><span class=line><span class=comment>// 子类</span></span><br><span class=line><span class=keyword>class</span> <span class="title class_">B</span>: <span class=keyword>public</span> A &#123;</span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>    <span class=function><span class=type>void</span> <span class=title>fun</span><span class=params>(<span class=type>int</span> a)</span> <span class=keyword>override</span> </span>&#123;  <span class=comment>// 覆盖</span></span><br><span class=line>        cout &lt;&lt; <span class=string>&quot;this is B fun &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class=line>    &#125;</span><br><span class=line>    <span class=function><span class=type>void</span> <span class=title>add</span><span class=params>(<span class=type>int</span> a)</span> </span>&#123;   <span class=comment>// 隐藏</span></span><br><span class=line>        cout &lt;&lt; <span class=string>&quot;This is B add &quot;</span> &lt;&lt; a + a &lt;&lt; endl;</span><br><span class=line>    &#125;</span><br><span class=line>&#125;;</span><br><span class=line></span><br><span class=line><span class=function><span class=type>int</span> <span class=title>main</span><span class=params>()</span> </span>&#123;</span><br><span class=line>    <span class=comment>// 基类指针指向派生类对象时，基类指针可以直接调用到派生类的覆盖函数，也可以通过 :: 调用到基类被覆盖</span></span><br><span class=line>    <span class=comment>// 的虚函数；而基类指针只能调用基类的被隐藏函数，无法识别派生类中的隐藏函数。</span></span><br><span class=line></span><br><span class=line>    A *p = <span class=keyword>new</span> <span class=built_in>B</span>();</span><br><span class=line>    p-&gt;<span class=built_in>fun</span>(<span class=number>1</span>);      <span class=comment>// 调用子类 fun 覆盖函数</span></span><br><span class=line>    p-&gt;A::<span class=built_in>fun</span>(<span class=number>1</span>);   <span class=comment>// 调用父类 fun</span></span><br><span class=line>    p-&gt;<span class=built_in>add</span>(<span class=number>1</span>, <span class=number>2</span>);</span><br><span class=line>    <span class=comment>// p-&gt;add(1);      // 错误，识别的是 A 类中的 add 函数，参数不匹配</span></span><br><span class=line>    <span class=comment>// p-&gt;B::add(1);   // 错误，无法识别子类 add 函数</span></span><br><span class=line>    <span class=keyword>return</span> <span class=number>0</span>;</span><br><span class=line>&#125;</span><br></pre></td></tr></table></figure><h3 id=struct-class-区别><a href=#struct-class-区别 class=headerlink title="struct class 区别"></a>struct class 区别</h3><ul><li><blockquote><p>struct 用于描述数据结构集合， class 是对一个对象数据的封装；</p></blockquote></li><li><blockquote><p>struct 中默认 public 的，而 class 中默认 private</p></blockquote></li></ul><figure class="highlight plaintext"><table><tr><td class=code><pre><span class=line>struct person&#123;  </span><br><span class=line>    int a;  </span><br><span class=line>&#125;;  </span><br><span class=line> class student&#123;  </span><br><span class=line>     int b ;  </span><br><span class=line> &#125;;  </span><br><span class=line>int main() &#123;  </span><br><span class=line>    person p1;  </span><br><span class=line>    student s;  </span><br><span class=line>    pa = 10; //默认属性public  </span><br><span class=line>//    s.b = 10; 报错，默认private属性不可以访问；  </span><br><span class=line>    return 0;  </span><br><span class=line>&#125;</span><br></pre></td></tr></table></figure><ol><li><blockquote><p>在继承关系中，struct 默认是公有继承，而 class 是私有继承；</p></blockquote><blockquote><p>clsaa继承图：</p></blockquote><blockquote><p>![截屏2022-03-15 19.07.26](&#x2F;Users&#x2F;apple&#x2F;Desktop&#x2F;计算机资料&#x2F;图片&#x2F;截屏2022-03-15 19.07.26.png)</p></blockquote></li><li><blockquote><p>class 可以定义模板参数，就像 typename，而 struct 不能</p></blockquote><figure class="highlight plaintext"><table><tr><td class=code><pre><span class=line>template&lt;typename T, typename Y&gt;  </span><br><span class=line>// 可以把typename 换成 class    </span><br><span class=line>int Func(const T&amp; t, const Y&amp; y)</span><br></pre></td></tr></table></figure></li></ol><h3 id=this-指针><a href=#this-指针 class=headerlink title="this 指针"></a>this 指针</h3><ol><li><blockquote><p>当对一个对象调用成员函数时，编译程序先将对象的地址赋给 <code>this</code> 指针，然后调用成员函数，每次成员函数存取数据成员时，都隐式使用 <code>this</code> 指针。</p></blockquote></li><li><blockquote><p><code>this</code> 指针被隐含地声明为:</p></blockquote><figure class="highlight plaintext"><table><tr><td class=code><pre><span class=line>ClassName *const this</span><br></pre></td></tr></table></figure><p>，这意味着不能给 <code>this</code> 指针赋值；在 <code>ClassName</code> 类的 <code>const</code> 成员函数中，<code>this</code> 指针的类型为：</p><figure class="highlight plaintext"><table><tr><td class=code><pre><span class=line>const ClassName* const</span><br></pre></td></tr></table></figure><p>，这说明不能对 <code>this</code> 指针所指向的这种对象是不可修改的（即不能对这种对象的数据成员进行赋值操作）；</p></li><li><blockquote><p><code>this</code> 并不是一个常规变量，而是个右值，所以不能取得 <code>this</code> 的地址（不能 <code>&amp;this</code>）。</p></blockquote></li><li><blockquote><p>在以下场景中，经常需要显式引用this指针：</p></blockquote><ul><li><blockquote><p>为实现对象的链式引用；</p></blockquote></li><li><blockquote><p>为避免对同一对象进行赋值操作；</p></blockquote></li><li><blockquote><p>在实现一些数据结构时，如 <code>list</code>。</p></blockquote></li></ul></li></ol><h3 id=delete-this-合法吗？><a href=#delete-this-合法吗？ class=headerlink title="delete this 合法吗？"></a>delete this 合法吗？</h3><blockquote><blockquote><p>Is it legal (and moral) for a member function to say delete this?</p></blockquote></blockquote><blockquote><p>合法，但：</p></blockquote><ol><li>必须保证 this 对象是通过 <code>new</code>（不是 <code>new[]</code>、不是 placement new、不是栈上、不是全局、不是其他对象成员）分配的</li><li>必须保证成员函数的 <code>delete this</code>后面没有调用 this 了</li></ol><h3 id=如何定义一个只能在堆上（栈上）生成对象的类？><a href=#如何定义一个只能在堆上（栈上）生成对象的类？ class=headerlink title=如何定义一个只能在堆上（栈上）生成对象的类？></a>如何定义一个只能在堆上（栈上）生成对象的类？</h3><blockquote><blockquote><p>如何定义一个只能在堆上（栈上）生成对象的类?</p></blockquote></blockquote><blockquote><p>只能在堆上</p></blockquote><blockquote><p>方法：将析构函数设置为私有</p></blockquote><blockquote><p>原因：C++ 是静态绑定语言，编译器管理栈上对象的生命周期，编译器在为类对象分配栈空间时，会先检查类的析构函数的访问性。若析构函数不可访问，则不能在栈上创建对象。</p></blockquote><blockquote><p>只能在栈上</p></blockquote><blockquote><p>方法：将 new 和 delete 重载为私有</p></blockquote><blockquote><p>原因：在堆上生成对象，使用 new 关键词操作，其过程分为两阶段：第一阶段，使用 new 在堆上寻找可用内存，分配给对象；第二阶段，调用构造函数生成对象。将 new 操作设置为私有，那么第一阶段就无法完成，就不能够在堆上生成对象。</p></blockquote><h3 id=nullptr调用成员函数可以吗？为什么？><a href=#nullptr调用成员函数可以吗？为什么？ class=headerlink title=nullptr调用成员函数可以吗？为什么？></a>nullptr调用成员函数可以吗？为什么？</h3><blockquote><p>能调用<code>不涉及访问成员变量的函数</code>，若该函数访问了成员变量，则报错。</p></blockquote><blockquote><p>原因：因为在<code>编译时对象</code>就绑定了<code>函数地址</code>，和指针空不空没关系。</p></blockquote><blockquote><p><code>答案解析</code></p></blockquote><figure class="highlight plaintext"><table><tr><td class=code><pre><span class=line>//给出实例  </span><br><span class=line>class animal&#123;  </span><br><span class=line>public:  </span><br><span class=line>    void sleep()&#123; cout &lt;&lt; &quot;animal sleep&quot; &lt;&lt; endl; &#125;  </span><br><span class=line>    void breathe()&#123; cout &lt;&lt; &quot;animal breathe haha&quot; &lt;&lt; endl; &#125;  </span><br><span class=line>&#125;;  </span><br><span class=line>class fish :public animal&#123;  </span><br><span class=line>public:  </span><br><span class=line>    void breathe()&#123; cout &lt;&lt; &quot;fish bubble&quot; &lt;&lt; endl; &#125;  </span><br><span class=line>&#125;;  </span><br><span class=line>int main()&#123;  </span><br><span class=line>    animal *pAn=nullptr; //不是虚函数，编译期间就绑定了函数地址，这个一个animal类型的指针，不管指向哪里。调用成员函数的时候都能找到函数地址  </span><br><span class=line>    pAn-&gt;breathe();   // 输出：animal breathe haha  </span><br><span class=line>    fish *pFish = nullptr;//同理，编译器就绑定了地址  </span><br><span class=line>    pFish-&gt;breathe(); // 输出：fish bubble  </span><br><span class=line>    return 0;  </span><br><span class=line>&#125;</span><br></pre></td></tr></table></figure><blockquote><p>原因：因为在<code>编译时对象</code>就绑定了<code>函数地址</code>，和指针空不空没关系。</p></blockquote><h3 id=friend-友元类和友元函数><a href=#friend-友元类和友元函数 class=headerlink title="friend 友元类和友元函数"></a>friend 友元类和友元函数</h3><ul><li>能访问私有成员</li><li>破坏封装性</li><li>友元关系不可传递</li><li>友元关系的单向性</li><li>友元声明的形式及数量不受限制</li></ul><h3 id=成员初始化列表><a href=#成员初始化列表 class=headerlink title=成员初始化列表></a>成员初始化列表</h3><blockquote><p>好处</p></blockquote><ul><li>更高效：少了一次调用默认构造函数的过程。</li><li>有些场合必须要用初始化列表：<ol><li>常量成员，因为常量只能初始化不能赋值，所以必须放在初始化列表里面</li><li>引用类型，引用必须在定义的时候初始化，并且不能重新赋值，所以也要写在初始化列表里面</li><li>没有默认构造函数的类类型，因为使用初始化列表可以不必调用默认构造函数来初始化</li></ol></li></ul><h3 id=initializer-list-列表初始化（c-11）><a href=#initializer-list-列表初始化（c-11） class=headerlink title="initializer_list 列表初始化（c++11）"></a>initializer_list 列表初始化（c++11）</h3><blockquote><p>用花括号初始化器列表初始化一个对象，其中对应构造函数接受一个</p></blockquote><figure class="highlight plaintext"><table><tr><td class=code><pre><span class=line>std::initializer_list</span><br></pre></td></tr></table></figure><p>参数.</p><blockquote><p>initializer_list 使用</p></blockquote><figure class="highlight plaintext"><table><tr><td class=code><pre><span class=line>#include &lt;iostream&gt;  </span><br><span class=line>#include &lt;vector&gt;  </span><br><span class=line>#include &lt;initializer_list&gt;  </span><br><span class=line></span><br><span class=line>template &lt;class T&gt;  </span><br><span class=line>struct S &#123;  </span><br><span class=line>    vector&lt;T&gt; v;  </span><br><span class=line>    S(initializer_list&lt;T&gt; L) : v(L) &#123;  </span><br><span class=line>         cout &lt;&lt; &quot;constructed with a &quot; &lt;&lt; L.size() &lt;&lt; &quot;-element list\\n&quot;;  </span><br><span class=line>    &#125;  </span><br><span class=line>    void append(initializer_list&lt;T&gt; L) &#123;  </span><br><span class=line>        v.insert(v.end(), L.begin(), L.end());  </span><br><span class=line>    &#125;  </span><br><span class=line>    pair&lt;const T*, size_t&gt; c_arr() const &#123;  </span><br><span class=line>        return &#123;&amp;v[0], v.size()&#125;;  // 在 return 语句中复制列表初始化  </span><br><span class=line>                                   // 这不使用 std::initializer_list  </span><br><span class=line>    &#125;  </span><br><span class=line>&#125;;  </span><br><span class=line></span><br><span class=line>template &lt;typename T&gt;  </span><br><span class=line>void templated_fn(T) &#123;&#125;  </span><br><span class=line></span><br><span class=line>int main()  </span><br><span class=line>&#123;  </span><br><span class=line>    S&lt;int&gt; s = &#123;1, 2, 3, 4, 5&#125;; // 复制初始化  </span><br><span class=line>    s.append(&#123;6, 7, 8&#125;);      // 函数调用中的列表初始化  </span><br><span class=line></span><br><span class=line>    cout &lt;&lt; &quot;The vector size is now &quot; &lt;&lt; s.c_arr().second &lt;&lt; &quot; ints:\\n&quot;;  </span><br><span class=line></span><br><span class=line>    for (auto n : s.v)  </span><br><span class=line>        cout &lt;&lt; n &lt;&lt; &#x27; &#x27;;  </span><br><span class=line>    cout &lt;&lt; &#x27;\\n&#x27;;  </span><br><span class=line></span><br><span class=line>    cout &lt;&lt; &quot;Range-for over brace-init-list: \\n&quot;;  </span><br><span class=line></span><br><span class=line>    for (int x : &#123;-1, -2, -3&#125;) // auto 的规则令此带范围 for 工作  </span><br><span class=line>        cout &lt;&lt; x &lt;&lt; &#x27; &#x27;;  </span><br><span class=line>    cout &lt;&lt; &#x27;\\n&#x27;;  </span><br><span class=line></span><br><span class=line>    auto al = &#123;10, 11, 12&#125;;   // auto 的特殊规则  </span><br><span class=line></span><br><span class=line>    cout &lt;&lt; &quot;The list bound to auto has size() = &quot; &lt;&lt; al.size() &lt;&lt; &#x27;\\n&#x27;;  </span><br><span class=line></span><br><span class=line>//    templated_fn(&#123;1, 2, 3&#125;); // 编译错误！“ &#123;1, 2, 3&#125; ”不是表达式，  </span><br><span class=line>                             // 它无类型，故 T 无法推导  </span><br><span class=line>    templated_fn&lt;initializer_list&lt;int&gt;&gt;(&#123;1, 2, 3&#125;); // OK  </span><br><span class=line>    templated_fn&lt;vector&lt;int&gt;&gt;(&#123;1, 2, 3&#125;);           // 也 OK  </span><br><span class=line>&#125;</span><br></pre></td></tr></table></figure><h3 id=面向对象-1><a href=#面向对象-1 class=headerlink title=面向对象></a>面向对象</h3><blockquote><p>面向对象程序设计（Object-oriented programming，OOP）是种具有对象概念的程序编程典范，同时也是一种程序开发的抽象方针。</p></blockquote><blockquote><p>面向对象三大特征 —— 封装、继承、多态</p></blockquote><h3 id=封装><a href=#封装 class=headerlink title=封装></a>封装</h3><blockquote><p>把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。关键字：public, protected, private。不写默认为 private。</p></blockquote><ul><li><code>public</code> 成员：可以被任意实体访问</li><li><code>protected</code> 成员：只允许被子类及本类的成员函数访问</li><li><code>private</code> 成员：只允许被本类的成员函数、友元类或友元函数访问</li></ul><h3 id=抽象类、接口类、聚合类><a href=#抽象类、接口类、聚合类 class=headerlink title=抽象类、接口类、聚合类></a>抽象类、接口类、聚合类</h3><ul><li><blockquote><p>抽象类：含有纯虚函数的类</p></blockquote></li><li><blockquote><p>接口类：仅含有纯虚函数的抽象类</p></blockquote></li><li><blockquote><p>聚合类：用户可以直接访问其成员，并且具有特殊的初始化语法形式。满足如下特点：</p></blockquote><ul><li><blockquote><p>所有成员都是 public</p></blockquote></li><li><blockquote><p>没有定义任何构造函数</p></blockquote></li><li><blockquote><p>没有类内初始化</p></blockquote></li><li><blockquote><p>没有基类，也没有 virtual 函数</p></blockquote></li></ul></li></ul><h3 id=仿函数-函数对象><a href=#仿函数-函数对象 class=headerlink title=仿函数(函数对象)></a>仿函数(函数对象)</h3><blockquote><p><code>参考回答</code></p></blockquote><ul><li>重载<code>函数调用操作符</code>的类，其对象常称为<code>函数对象</code></li><li><code>函数对象</code>使用重载的()时，行为类似函数调用，也叫<code>仿函数</code></li></ul><ol><li>仿函数（functor）又称为函数对象（function object）是一个能行使函数功能的<code>类</code>。仿函数的语法几乎和我们普通的函数调用一样，不过作为仿函数的类，都必须重载operator()运算符，举个例子：</li></ol><figure class="highlight plaintext"><table><tr><td class=code><pre><span class=line>class Func&#123;  </span><br><span class=line>public:              //第一个const说明形参不可以改变  </span><br><span class=line>    void operator() (const string&amp; str) const &#123;  </span><br><span class=line>        cout&lt;&lt;str&lt;&lt;endl;         //第二个说明这是常成员函数，不得修改类中任何数据成员  </span><br><span class=line>    &#125;   //重载（）运算符  </span><br><span class=line>&#125;;  </span><br><span class=line></span><br><span class=line>Func myFunc; //myFunc称为函数对象  </span><br><span class=line>myFunc(&quot;helloworld!&quot;);  </span><br><span class=line></span><br><span class=line>&gt;&gt;&gt;helloworld!</span><br></pre></td></tr></table></figure><ol><li><blockquote><p>仿函数既能想普通函数一样传入给定数量的参数，还能存储或者处理更多我们需要的有用信息。我们可以举个例子：</p></blockquote><blockquote><p>假设有一个vector，你的任务是统计长度小于5的string的个数，如果使用count_if函数的话，你的代码可能长成这样：</p></blockquote><figure class="highlight plaintext"><table><tr><td class=code><pre><span class=line>bool LengthIsLessThanFive(const string&amp; str) &#123;  </span><br><span class=line>    return str.length()&lt;5;      </span><br><span class=line>&#125;  </span><br><span class=line>int res=count_if(vec.begin(), vec.end(), LengthIsLessThanFive);</span><br></pre></td></tr></table></figure><blockquote><p>其中count_if函数的第三个参数是一个函数指针，返回一个bool类型的值。一般的，如果需要将特定的阈值长度也传入的话，我们可能将函数写成这样：</p></blockquote><figure class="highlight plaintext"><table><tr><td class=code><pre><span class=line>bool LenthIsLessThan(const string&amp; str, int len) &#123;  </span><br><span class=line>    return str.length()&lt;len;  </span><br><span class=line>&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这个函数看起来比前面一个版本更具有一般性，但是他不能满足count_if函数的参数要求：count_if要求的是unary function（仅带有一个参数）作为它的最后一个参数。如果我们使用仿函数，是不是就豁然开朗了呢：</p></blockquote><figure class="highlight plaintext"><table><tr><td class=code><pre><span class=line>class ShorterThan &#123;  </span><br><span class=line>public:  </span><br><span class=line>    explicit ShorterThan(int maxLength) : length(maxLength) &#123;&#125;  </span><br><span class=line>    bool operator() (const string&amp; str) const &#123;  </span><br><span class=line>        return str.length() &lt; length;  </span><br><span class=line>    &#125;  </span><br><span class=line>private:  </span><br><span class=line>    const int length;  </span><br><span class=line>&#125;;</span><br></pre></td></tr></table></figure></li></ol><h3 id=类模板和模板类的区别><a href=#类模板和模板类的区别 class=headerlink title=类模板和模板类的区别></a>类模板和模板类的区别</h3><blockquote><p><code>参考回答</code></p></blockquote><ol><li>类模板是模板的定义，不是一个实实在在的类，定义中用到通用类型参数</li><li>模板类是实实在在的类定义，是类模板的实例化。类定义中参数被实际类型所代替。</li></ol><blockquote><p><code>答案解析</code></p></blockquote><ol><li><blockquote><p>类模板的类型参数可以有一个或多个，每个类型前面都必须加class，如template &lt;class T1,class T2&gt;class someclass{…};在定义对象时分别代入实际的类型名，如 someclass&lt;int,double&gt; obj;</p></blockquote></li><li><blockquote><p>和使用类一样，使用类模板时要注意其作用域，只能在其有效作用域内用它定义对象。</p></blockquote></li><li><blockquote><p>模板可以有层次，一个类模板可以作为基类，派生出派生模板类。</p></blockquote></li></ol><h2 id=内存相关><a href=#内存相关 class=headerlink title=内存相关></a>内存相关</h2><h3 id=程序section><a href=#程序section class=headerlink title=程序section></a>程序section</h3><blockquote><p><code>参考回答</code></p></blockquote><blockquote><p><img src=https://uploadfiles.nowcoder.com/images/20220225/4107856_1645788015668/798C7A2D023204559B62F88B54E35CBB alt=img></p></blockquote><blockquote><p><code>一个程序有哪些section：</code></p></blockquote><blockquote><p>如上图，<code>从低地址到高地址，一个程序由代码段、数据段、BSS段、堆、共享区、栈等</code>组成。</p></blockquote><ol><li><blockquote><p><code>代码段：</code>存放程序执行代码的一块内存区域。只读，代码段的头部还会包含一些只读的常数变量。</p></blockquote></li><li><blockquote><p><code>数据段：</code>存放程序中已初始化的全局变量和静态变量的一块内存区域。</p></blockquote></li><li><blockquote><p><code>BSS</code> 段：存放程序中未初始化的全局变量和静态变量的一块内存区域。</p></blockquote></li><li><blockquote><p>可执行程序在<code>运行时</code>又会多出两个区域：堆区和栈区。</p></blockquote><blockquote><p><code>堆区：</code>动态申请内存用。堆从低地址向高地址增长。</p></blockquote><blockquote><p><code>栈区：</code>存储局部变量、函数参数值。栈从高地址向低地址增长。是一块连续的空间。</p></blockquote></li><li><blockquote><p>最后还有一个<code>共享区</code>，位于堆和栈之间。</p></blockquote></li></ol><h3 id=内存分区><a href=#内存分区 class=headerlink title=内存分区></a>内存分区</h3><blockquote><p>![](assets&#x2F;截屏2022-04-18 23.58.32.png)</p></blockquote><blockquote><p><img src=/assets/1545017602518.png alt=1545017602518></p></blockquote><ul><li>代码区：存放函数体的二进制代码，由操作系统进行管理的</li><li>全局区：存放全局变量和静态变量以及常量（字符串常量也在这）</li><li>栈区：由编译器自动分配释放, 存放函数的参数值,局部变量等</li><li>堆区：由程序员分配和释放,若程序员不释放,程序结束时由操作系统回收</li></ul><h3 id=栈和堆><a href=#栈和堆 class=headerlink title=栈和堆></a>栈和堆</h3><ul><li>申请方式不同<ul><li>栈由系统自动分配，自动释放堆手动申请，手动释放</li></ul></li><li>申请大小限制不同。<ul><li>栈顶和栈底是之前预设好的，栈是向栈底扩展，是一块连续的内存区域，大小固定，在windows下一般为1M或者2M，可以通过ulimit -a查看，由ulimit -s修改。</li><li>堆向高地址扩展，是不连续的内存区域，大小可以灵活调整。堆申请无限制，取决于虚拟内存的大小，32位系统理论上为4GB</li></ul></li><li>申请效率不同。<ul><li>栈由系统分配，速度快，不会有碎片。</li><li>堆由程序员分配，速度慢，且会有碎片。</li></ul></li><li><code>堆栈缓存方式不同</code>。<ul><li>栈使用的是一级缓存， 它们通常都是被调用时处于存储空间中，调用完毕立即释放；堆则是存放在二级缓存中，速度要慢些。</li></ul></li><li><code>堆栈数据结构不同</code>。<ul><li>堆类似数组结构；栈类似栈结构，先进后出。</li></ul></li></ul><blockquote><p>栈空间默认是4M, 堆区一般是 1G - 4G（取决于虚拟内存的大小）</p></blockquote><h3 id=内存分配和管理><a href=#内存分配和管理 class=headerlink title=内存分配和管理></a>内存分配和管理</h3><blockquote><p>malloc、calloc、realloc、alloca</p></blockquote><ol><li>malloc：申请指定字节数的内存。申请到的内存中的初始值不确定。</li><li>calloc：为指定长度的对象，分配能容纳其指定个数的内存。申请到的内存的每一位（bit）都初始化为 0。</li><li>realloc：更改以前分配的内存长度（增加或减少）。当增加长度时，可能需将以前分配区的内容移到另一个足够大的区域，而新增区域内的初始值则不确定。</li><li>alloca：在栈上申请内存。程序在出栈的时候，会自动释放内存。但是需要注意的是，alloca 不具可移植性, 而且在没有传统堆栈的机器上很难实现。alloca 不宜使用在必须广泛移植的程序中。C99 中支持变长数组 (VLA)，可以用来替代 alloca。</li></ol><h3 id=内存泄露><a href=#内存泄露 class=headerlink title=内存泄露></a>内存泄露</h3><blockquote><p>简单地说就是申请了一块内存空间，使用完毕后没有释放掉。</p></blockquote><ul><li>new和malloc申请资源使用后，没有用delete和free释放；</li><li>子类继承父类时，父类析构函数不是虚函数。</li></ul><blockquote><p><code>如何避免？</code></p></blockquote><blockquote><p>第一：良好的编码习惯，使用了内存分配的函数，一旦使用完毕,要记得使用其相应的函数释放掉。</p></blockquote><blockquote><p>第二：将分配的内存的指针以链表的形式自行管理，使用完毕之后从链表中删除，程序结束时可检查改链表。</p></blockquote><blockquote><p>第三：使用智能指针。</p></blockquote><blockquote><p>第四：一些常见的工具插件，如ccmalloc、Dmalloc、Leaky、Valgrind等等。</p></blockquote><h3 id=C-中内存对齐的使用场景><a href=#C-中内存对齐的使用场景 class=headerlink title=C++中内存对齐的使用场景></a>C++中内存对齐的使用场景</h3><blockquote><p><code>参考回答</code></p></blockquote><blockquote><p>内存对齐应用于三种数据类型中：<code>struct/class/union</code></p></blockquote><blockquote><p>struct&#x2F;class&#x2F;union内存对齐原则有四个：</p></blockquote><ol><li><blockquote><p><code>数据成员对齐规则</code>：结构(struct)或联合(union)的数据成员，第一个数据成员放在offset为0的地方，以后每个数据成员存储的起始位置要从该成员大小或者成员的子成员大小的整数倍开始。</p></blockquote></li><li><blockquote><p><code>结构体作为成员</code>:如果一个结构里有某些结构体成员,则结构体成员要从其内部最宽基本类型成员的整数倍地址开始存储。(struct a里存有struct b,b里有char,int ,double等元素,那b应该从8的整数倍开始存储)。</p></blockquote></li><li><blockquote><p>收尾工作:结构体的总大小，也就是sizeof的结果，必须是其内部最大成员的最宽基本类型成员的整数倍。不足的要补齐。(基本类型不包括struct&#x2F;class&#x2F;uinon)。</p></blockquote></li><li><blockquote><p>sizeof(union)，以结构里面size最大元素为union的size，如联合里面有double，int ，char三种类型，union的大小为8B，因为在某一时刻，union只有一个成员真正存储于该地址。</p></blockquote></li><li><blockquote><p><code>什么是内存对齐？</code></p></blockquote><blockquote><p>那么什么是字节对齐？在C语言中，结构体是一种复合数据类型，其构成元素既可以是基本数据类型（如int、long、float等）的变量，也可以是一些复合数据类型（如数组、结构体、联合体等）的数据单元。在结构体中，<code>编译器为结构体的每个成员按其自然边界（alignment）分配空间。</code>各个成员按照它们被声明的顺序在内存中顺序存储，第一个成员的地址和整个结构体的地址相同。</p></blockquote><blockquote><p>为了使CPU能够对变量进行快速的访问，变量的起始地址应该具有某些特性，<code>即所谓的对齐，比如4字节的int型，其起始地址应该位于4字节的边界上，即起始地址能够被4整除</code>，也即对齐跟数据在内存中的位置有关。如果一个变量的内存地址正好位于它长度的整数倍，他就被称做自然对齐。</p></blockquote><blockquote><p>比如在32位cpu下，假设一个整型变量的地址为0x00000004(为4的倍数)，那它就是自然对齐的，而如果其地址为0x00000002（非4的倍数）则是非对齐的。现代计算机中内存空间都是按照byte划分的，从理论上讲似乎对任何类型的变量的访问可以从任何地址开始，但实际情况是在访问特定类型变量的时候经常在特定的内存地址访问，这就需要各种类型数据按照一定的规则在空间上排列，而不是顺序的一个接一个的排放，这就是对齐。</p></blockquote></li><li><blockquote><p><code>为什么要字节对齐？</code></p></blockquote><blockquote><p>需要字节对齐的根本原因在于CPU访问数据的效率问题。假设上面整型变量的地址不是自然对齐，比如为0x00000002，则CPU如果取它的值的话需要访问两次内存，第一次取从0x00000002-0x00000003的一个short，第二次取从0x00000004-0x00000005的一个short然后组合得到所要的数据，如果变量在0x00000003地址上的话则要访问三次内存，第一次为char，第二次为short，第三次为char，然后组合得到整型数据。</p></blockquote><blockquote><p>而如果变量在自然对齐位置上，则只要一次就可以取出数据。一些系统对对齐要求非常严格，比如sparc系统，如果取未对齐的数据会发生错误，而在x86上就不会出现错误，只是效率下降。</p></blockquote><blockquote><p>各个硬件平台对存储空间的处理上有很大的不同。一些平台对某些特定类型的数据只能从某些特定地址开始存取。比如有些平台每次读都是从偶地址开始，如果一个int型（假设为32位系统）如果存放在偶地址开始的地方，那么一个读周期就可以读出这32bit，而如果存放在奇地址开始的地方，就需要2个读周期，并对两次读出的结果的高低字节进行拼凑才能得到该32bit数据。显然在读取效率上下降很多。</p></blockquote></li><li><blockquote><p><code>字节对齐实例</code></p></blockquote><figure class="highlight plaintext"><table><tr><td class=code><pre><span class=line>union example &#123;  </span><br><span class=line>  int a[5];  //20字节  </span><br><span class=line>  char b; //一字节  </span><br><span class=line>  double c;   //8字节  </span><br><span class=line>&#125;;     </span><br><span class=line></span><br><span class=line>int result = sizeof(example);       </span><br><span class=line>/* 如果以最长20字节为准，内部double占8字节，这段内存的地址0x00000020并不是double的整数倍，只有当最小为0x00000024时可以满足整除double（8Byte）同时又可以容纳int a[5]的大小，所以正确的结果应该是result=24 */    </span><br><span class=line></span><br><span class=line>struct example &#123;      </span><br><span class=line>  int a[5];     //如果改成a[4]，char扩充7字节，结果也为32  </span><br><span class=line>  char b;    </span><br><span class=line>  double c;     </span><br><span class=line>&#125;test_struct;   </span><br><span class=line>int result = sizeof(test_struct);    </span><br><span class=line></span><br><span class=line>/* 如果我们不考虑字节对齐，那么内存地址0x0021不是double（8Byte）的整数倍，所以需要字节对齐，那么此时满足是double（8Byte）的整数倍的最小整数是0x0024，说明此时char b对齐int扩充了三个字节。所以最后的结果是result=32 */    </span><br><span class=line></span><br><span class=line>struct example &#123;    </span><br><span class=line>  char b;     </span><br><span class=line>  double c;      </span><br><span class=line>  int a;    </span><br><span class=line>&#125;test_struct;    </span><br><span class=line>int result = sizeof(test_struct);   </span><br><span class=line></span><br><span class=line>/* 字节对齐除了内存起始地址要是数据类型的整数倍以外，还要满足一个条件，那就是占用的内存空间大小需要是结构体中占用最大内存空间的类型的整数倍，所以20不是double（8Byte）的整数倍，我们还要扩充四个字节，最后的结果是result=24 */  </span><br></pre></td></tr></table></figure></li></ol><h3 id=大端小端><a href=#大端小端 class=headerlink title=大端小端></a>大端小端</h3><ul><li><p>大端，低地址存放数据的高位，高地址存放数据的地位 ，<strong>网络通信</strong>中使用大端</p></li><li><p>小端，低地址存储数据地位，高地址存储数据高位，<strong>计算机内部</strong>一般为小端存储</p><p>如0x12345678;</p><p>大端为12，34，56，78</p><p>小端为78，56，34，12（低地址到高地址）</p></li><li><p>如何判断？</p></li></ul><figure class="highlight c++"><table><tr><td class=code><pre><span class=line><span class=comment>//法一</span></span><br><span class=line><span class=keyword>union</span> <span class="title class_">s</span>&#123;</span><br><span class=line>  <span class=type>int</span> a;</span><br><span class=line>  <span class=type>char</span> b;</span><br><span class=line>&#125;</span><br><span class=line>s.a = <span class=number>0x12345678</span>  </span><br><span class=line><span class=keyword>if</span>(s.b == <span class=number>0x12</span>)&#123;         <span class=comment>//或者用 cout &lt;&lt; hex &lt;&lt; (int)s.b &lt;&lt; endl;</span></span><br><span class=line>  cout &lt;&lt; <span class=string>&quot;大端&quot;</span> &lt;&lt; endl;  <span class=comment>//hex输出16进制，（int）转整型</span></span><br><span class=line>&#125;													<span class=comment>//输出78为小端，输出12为大端</span></span><br><span class=line><span class=keyword>else</span> &#123;</span><br><span class=line>  cout &lt;&lt; <span class=string>&quot;小端&quot;</span> &lt;&lt; endl;</span><br><span class=line>&#125;</span><br><span class=line></span><br><span class=line><span class=comment>//法二，推荐</span></span><br><span class=line><span class=type>int</span> a = <span class=number>48</span>;</span><br><span class=line><span class=type>char</span> * b = (<span class=type>char</span> *)&amp;a <span class=comment>//强制类型转换</span></span><br><span class=line>cout &lt;&lt; *b &lt;&lt;endl; <span class=comment>//如果输出0，说明小端，否则大端</span></span><br><span class=line><span class=comment>//ascii码字符0对应48，即如果存放的为48，输出字符的话对应为0；</span></span><br></pre></td></tr></table></figure><h2 id=基础语法><a href=#基础语法 class=headerlink title=基础语法></a>基础语法</h2><h3 id=双引号””和尖括号-lt-gt-的区别><a href=#双引号””和尖括号-lt-gt-的区别 class=headerlink title=双引号””和尖括号&lt;&gt;的区别></a>双引号””和尖括号&lt;&gt;的区别</h3><blockquote><p><code>参考回答</code></p></blockquote><blockquote><p>（1）尖括号&lt;&gt;的头文件是<code>系统文件</code>，双引号的头文件是<code>自定义文件</code>。</p></blockquote><blockquote><p>（2）&lt;&gt;：编译器设置的头文件路径–&gt;系统变量。</p></blockquote><blockquote><p>（3）双引号 ：当前头文件目录–&gt;编译器设置的头文件路径–&gt;系统变量。</p></blockquote><h3 id=数组名和字符串数组><a href=#数组名和字符串数组 class=headerlink title=数组名和字符串数组></a>数组名和字符串数组</h3><figure class="highlight c++"><table><tr><td class=code><pre><span class=line><span class=meta>#<span class=keyword>include</span> <span class=string>&lt;iostream&gt;</span>  </span></span><br><span class=line><span class=keyword>using</span> <span class=keyword>namespace</span> std;  </span><br><span class=line><span class=comment>/*数组名确实表示指向数组0号元素的地址，但这个指针很特别，  </span></span><br><span class=line><span class=comment>它的值（指针的值指的是指针所指的地址）不能被改写，能改写的仅仅是其指向的内容，  </span></span><br><span class=line><span class=comment>换句话说，数组名只能指向数组的首地址，如果有数组char a[];那么如果出现a = a+1;这是编译都通不过的错误。  </span></span><br><span class=line><span class=comment>而对于一个普通的指针是可以的，再比如有数组char a[];那么再定义一个char *p = a;  </span></span><br><span class=line><span class=comment>然后再用p = p+1是合法的，这表示让指针p指向&amp;a[1]。  </span></span><br><span class=line><span class=comment>它们的第二个区别是：每当用到数组名这个指针的时候，系统都会传入数组的信息，而普通的指针只是一个4字节的整数*/</span>  </span><br><span class=line><span class=function><span class=type>int</span> <span class=title>main</span><span class=params>()</span> </span>&#123;  </span><br><span class=line>	<span class=type>int</span> a[] = &#123; <span class=number>1</span>,<span class=number>2</span>,<span class=number>3</span>,<span class=number>4</span>,<span class=number>5</span> &#125;;  </span><br><span class=line>	cout &lt;&lt; <span class=string>&quot;a:  &quot;</span> &lt;&lt; a &lt;&lt; endl;        <span class=comment>//数组名就是首元素的地址，故输出的就是地址  </span></span><br><span class=line>	cout &lt;&lt; <span class=string>&quot;*a:  &quot;</span> &lt;&lt; *a &lt;&lt; endl;      <span class=comment>//指向首址存放的内容，故输出的是首号元素  </span></span><br><span class=line>	cout &lt;&lt; <span class=string>&quot;&amp;a:  &quot;</span> &lt;&lt; &amp;a &lt;&lt; endl;     <span class=comment>//这里居然不报错，输出的仍然是首地址  </span></span><br><span class=line></span><br><span class=line>```c++  </span><br><span class=line><span class=type>char</span> zct[] = <span class=string>&quot;zctshuai&quot;</span>;  </span><br><span class=line>cout &lt;&lt; <span class=string>&quot;zct:  &quot;</span> &lt;&lt; zct &lt;&lt;endl;    <span class=comment>/*本以为会输出首址，哪知道输出的是字符串。  </span></span><br><span class=line><span class=comment></span></span><br><span class=line><span class=comment>C++的**重载**机制：对于一维字符数组名的输出，编译器会默认你想输出的是数组里的内容，而对于其他类型数组名的输出，如整形数组，编译器默认的输出是数组首元素的地址。  </span></span><br><span class=line><span class=comment></span></span><br><span class=line><span class=comment>注意，对于二维数组又有所不同，如果定义的是二维数组，不管是不是字符数组，输出数组名得到的都是地址。另外，不管字符数组还是别的类型数组，不管是一维还是二维，在C++中都不会进行数组越界检查，所以越界访问数组时编译器不会报错。*/</span>  </span><br><span class=line></span><br><span class=line>cout &lt;&lt; <span class=string>&quot;sizeof(zct):  &quot;</span> &lt;&lt; <span class=built_in>sizeof</span>(zct) &lt;&lt; endl;      <span class=comment>//此时输出的是元素总的个数  </span></span><br><span class=line></span><br><span class=line>cout &lt;&lt; <span class=string>&quot;sizeof(zct[0])&quot;</span> &lt;&lt; <span class=built_in>sizeof</span>(zct[<span class=number>0</span>]) &lt;&lt; endl;   <span class=comment>//输出的长度肯定是1，这不用说了  </span></span><br><span class=line></span><br><span class=line>cout &lt;&lt; <span class=string>&quot;字符数组个数：  &quot;</span> &lt;&lt; <span class=built_in>sizeof</span>(zct) / <span class=built_in>sizeof</span>(zct[<span class=number>0</span>]) &lt;&lt; endl;  <span class=comment>//通常我们求一个数组的元素个数就这样操作  </span></span><br><span class=line></span><br><span class=line>cout &lt;&lt; <span class=string>&quot;*zct:  &quot;</span> &lt;&lt; *zct &lt;&lt; endl;       <span class=comment>/*神奇吧，此时输出的又是第一个元素，再次证明其实数组名称对应的都是首址，只是针对一维字符数组，编译器会默认你想输出的是数组里的内容*/</span>  </span><br><span class=line></span><br><span class=line>cout &lt;&lt; <span class=string>&quot;&amp;zct:  &quot;</span> &lt;&lt; &amp;zct &lt;&lt; endl;       <span class=comment>//尽管“zct”值的还是地址，但是这样加了&amp;输出还是地址  </span></span><br><span class=line></span><br><span class=line><span class=type>char</span> *p = zct;  </span><br><span class=line>cout &lt;&lt; <span class=string>&quot;p:  &quot;</span> &lt;&lt; p &lt;&lt; endl;        <span class=comment>//这个时候p是指针变量，但是p是用一维字符数组来定义的，所以编译器还是默认你想输出数组里的内容  </span></span><br><span class=line></span><br><span class=line>cout &lt;&lt; <span class=string>&quot;sizeof(p):  &quot;</span> &lt;&lt; <span class=built_in>sizeof</span>(p) &lt;&lt; endl;    <span class=comment>//与 sizeof（zct）= 9 区分啊，很重要。原因在代码开头说明  </span></span><br><span class=line></span><br><span class=line><span class=type>int</span> *q = a;  </span><br><span class=line>cout &lt;&lt; <span class=string>&quot;q:  &quot;</span> &lt;&lt; q &lt;&lt; endl;     <span class=comment>//为何输出地址不用我再讲了吧  </span></span><br><span class=line>cout &lt;&lt; <span class=string>&quot;sizeof(q):  &quot;</span> &lt;&lt; <span class=built_in>sizeof</span>(q) &lt;&lt; endl;  </span><br><span class=line></span><br><span class=line><span class=built_in>system</span>(<span class=string>&quot;pause&quot;</span>);  </span><br><span class=line><span class=keyword>return</span> <span class=number>0</span>;  </span><br><span class=line>&#125;</span><br></pre></td></tr></table></figure><h3 id=区别以下指针类型><a href=#区别以下指针类型 class=headerlink title=区别以下指针类型></a>区别以下指针类型</h3><figure class="highlight c++"><table><tr><td class=code><pre><span class=line><span class=type>int</span> *p[<span class=number>10</span>]  <span class=comment>//创建十个int类型得指针，可以写成int * p[10] 为指针数组</span></span><br><span class=line>  </span><br><span class=line><span class=built_in>int</span> (*p)[<span class=number>10</span>] <span class=comment>//（*p）为解引用，表示创建一个int类型的数组（长度为10），p指向数组首地址；等价于 int * p = new int[10];一般不这么用</span></span><br><span class=line>  </span><br><span class=line><span class=function><span class=type>int</span> *<span class=title>p</span><span class=params>(<span class=type>int</span>)</span> <span class=comment>//函数声明，返回值为int * 类型（返回值为int类型的指针）</span></span></span><br><span class=line><span class=function> </span></span><br><span class=line><span class=function><span class=title>int</span> <span class=params>(*p)</span><span class=params>(<span class=type>int</span>)</span> <span class=comment>//函数指针，p为指向参数为int类型的函数的地址</span></span></span><br><span class=line><span class=function><span class=comment>//如 int fun(int a); int (*p)(int) = fun;  </span></span></span><br><span class=line><span class=function><span class=comment>// 特别注意，函数返回值什么类型就用什么类型指针接受，如</span></span></span><br><span class=line><span class=function><span class=comment>// void fun(int a); void (*p)(int) = fun; </span></span></span><br></pre></td></tr></table></figure><h3 id=const><a href=#const class=headerlink title=const></a>const</h3><ol><li>修饰变量，说明该变量不可以被改变；</li><li>修饰指针，分为指向常量的指针（pointer to const）和自身是常量的指针（常量指针，const pointer）；</li><li>修饰引用，指向常量的引用（reference to const），用于形参类型，即避免了拷贝，又避免了函数对值的修改；(引用相当于起别名，所以不需要开辟空间，而且值还不可以修改 )</li><li>修饰普通函数，有三种情况，修饰返回值，说明返回值不可以修改；修饰形参，说明形参不可以改变；在函数最后加const</li><li>修饰成员变量，说明该成员变量的值不可以改变，只能在类内赋值或者初始化列表赋值，构造函数不可以赋值</li><li>修饰成员函数，称为常成员函数，说明该成员函数内不能修改成员变量的值</li><li>修饰对象，称为常对象，常对象只能调用常成员函数</li></ol><figure class="highlight plaintext"><table><tr><td class=code><pre><span class=line>//修饰变量  </span><br><span class=line>    const int a; //报错，定义的时候必须赋值  </span><br><span class=line>    const int b = 10; //正确  </span><br><span class=line>    b = 20; //b的值不可以改变  </span><br><span class=line></span><br><span class=line>    //修饰指针  </span><br><span class=line>    const int * p; //正确，可以先不赋值；p指向的值不可以变，指向的地址可以变  </span><br><span class=line>    int * const p1; //错误，定义的时候必须赋值；且p1指向的地址不可修改  </span><br><span class=line></span><br><span class=line>    //修饰引用  </span><br><span class=line>    const int &amp;c; //报错，需要赋值，如const int &amp;c = a；  </span><br><span class=line>    int d = 10;  </span><br><span class=line>    const int &amp;c1 = d; //正确，和int const &amp;c1 = d 一个意思；  </span><br><span class=line>    //const修饰引用一般用于函数的形参，既避免了拷贝，又能防止对实参的修改；  </span><br><span class=line></span><br><span class=line>    //修饰普通函数  </span><br><span class=line>    const int fun1(); // 修饰返回值，说明返回值不可以修改   </span><br><span class=line>    int fun(const int a);//修饰形参，说明形参不可以改变  </span><br><span class=line>    int fun () const;  //这个是类内成员函数  </span><br><span class=line></span><br><span class=line>// 类  </span><br><span class=line>class A  </span><br><span class=line>&#123;  </span><br><span class=line>private:  </span><br><span class=line>    const int a;                // 常对象成员，只能使用初始化列表或者类内初始化  </span><br><span class=line>public:  </span><br><span class=line>    // 构造函数  </span><br><span class=line>    A() : a(0) &#123; &#125;;	//无参  </span><br><span class=line>    A(int x) : a(x) &#123; &#125;; // 初始化列表，有参  </span><br><span class=line></span><br><span class=line>    // const可用于对重载函数的区分  </span><br><span class=line>    int getValue();             // 普通成员函数，常对象不可以调用  </span><br><span class=line>    int getValue() const;// 常成员函数，不得修改类中的任何数据成员的值  </span><br><span class=line>&#125;;  </span><br><span class=line></span><br><span class=line>void function()  </span><br><span class=line>&#123;  </span><br><span class=line>    // 对象  </span><br><span class=line>    A b;                        // 普通对象，可以调用全部成员函数  </span><br><span class=line>    const A a;                  // 常对象，只能调用常成员函数  </span><br><span class=line>    const A *p = &amp;a;            // 指针变量，指向常对象  </span><br><span class=line>    const A &amp;q = a;             // 指向常对象的引用  </span><br><span class=line></span><br><span class=line>    // 指针  </span><br><span class=line>    char greeting[] = &quot;Hello&quot;;  </span><br><span class=line>    char* p1 = greeting;                // 指针变量，指向字符数组变量  </span><br><span class=line>    const char* p2 = greeting;          // 指针变量，指向字符数组常量（const 后面是 char，说明指向的字符（char）不可改变）  </span><br><span class=line>    char* const p3 = greeting;          // 自身是常量的指针，指向字符数组变量（const 后面是 p3，说明 p3 指针自身不可改变）  </span><br><span class=line></span><br><span class=line>    const char* const p4 = greeting;    // 自身是常量的指针，指向字符数组常量  </span><br><span class=line>&#125;  </span><br><span class=line></span><br><span class=line>// 函数  </span><br><span class=line>void function1(const int Var);           // 传递过来的参数在函数内不可变  </span><br><span class=line>void function2(const char* Var);         // 参数指针所指内容为常量  </span><br><span class=line>void function3(char* const Var);         // 参数指针为常量  </span><br><span class=line>void function4(const int&amp; Var);          // 引用参数在函数内为常量  </span><br><span class=line></span><br><span class=line>// 函数返回值  </span><br><span class=line>const int function5();      // 返回一个常数  </span><br><span class=line>const int* function6();     // 返回一个指向常量的指针变量，使用：const int *p = function6();  </span><br><span class=line>int* const function7();     // 返回一个指向变量的常指针，使用：int* const p = function7();</span><br></pre></td></tr></table></figure><h3 id=const和define><a href=#const和define class=headerlink title=const和define></a>const和define</h3><p>define 宏定义，相当于字符替换 const常量声明<br>define预处理器处理 const编译器处理<br>define无类型安全检查 const有类型安全检查<br>define不分配内存 const要分配内存<br>define存储在代码段 const存储在数据段<br>define可通过 <code>#undef</code> 取消 const不可取消</p><h3 id=static关键字的作用><a href=#static关键字的作用 class=headerlink title=static关键字的作用></a>static关键字的作用</h3><blockquote><p><code>参考回答</code></p></blockquote><ol><li><code>定义全局静态变量和局部静态变量</code>：只不过全局静态变量和局部静态变量的作用域不一样； 局部静态变量只在函数内使用 ，<code>静态全局变量只能在本源文件中使用</code>；</li><li>函数<code>：在函数返回类型前加上static关键字，函数即被定义为静态函数。静态函数只能在</code>本源文件<code>中使用；</code></li><li>定义类中的静态成员变量<code>：使用静态数据成员，它既可以被当成全局变量那样去存储，但又被隐藏在类的内部。类中的static静态数据成员拥有一块单独的存储区，而不管创建了多少个该类的对象。所有这些对象的静态数据成员都</code>共享**这一块静态存储空间。</li><li>静态成员函数：修饰成员函数使得不需要生成对象就可以访问该函数，但是在 static 函数内不能访问非静态成员变量。</li><li>定义静态对象，</li></ol><blockquote><p><code>答案解析</code></p></blockquote><blockquote><p>当调用一个对象的普通成员函数时，系统会把该对象的起始地址赋给成员函数的this指针。而静态成员函数不属于任何一个对象（对象里面没有这个函数，静态函数在全局区）， 因此C++规定静态成员函数没有this指针（划重点，面试题常考）。既然它没有指向某一对象，也就无法对一个对象中的非静态成员变量进行访问（即只能访问静态成员变量）。</p></blockquote><h3 id=野指针，悬空指针><a href=#野指针，悬空指针 class=headerlink title=野指针，悬空指针></a>野指针，悬空指针</h3><ul><li><blockquote><p>野指针，指的是没有被初始化过的指针；因此，为了防止出错，对于指针初始化时都是赋值为 <code>nullptr</code>，这样在使用时编译器就会直接报错，产生非法内存访问。</p></blockquote></li><li><blockquote><p>悬空指针，指针最初指向的内存已经被释放了的一种指针。</p></blockquote></li></ul><h3 id=volatile><a href=#volatile class=headerlink title=volatile></a>volatile</h3><figure class="highlight plaintext"><table><tr><td class=code><pre><span class=line>volatile int i = 10; //精确地说就是，编译器在用到这个变量时必须每次都小心地重新读取这个变量的值，而不是使用保存在[寄存器]里的备份</span><br></pre></td></tr></table></figure><ul><li><blockquote><p>volatile 关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素（操作系统、硬件、其它线程等）更改。所以使用 volatile 告诉编译器不应对这样的对象进行优化。</p></blockquote></li><li><blockquote><p>volatile是一个特征修饰符（type specifier）.<code>volatile</code>的作用是作为指令关键字，确保本条指令不会因编译器的优化而省略，且要求每次直接读值。</p></blockquote><blockquote><p>volatile的变量是说这变量可能会被意想不到地改变，这样，编译器就不会去假设这个变量的值了。</p></blockquote></li><li><blockquote><p>volatile 关键字声明的变量，每次访问时都必须从内存中取出值（没有被 volatile 修饰的变量，可能由于编译器的优化，从 CPU 寄存器中取值）</p></blockquote></li><li><blockquote><p>const 可以是 volatile （如只读的状态寄存器）</p></blockquote></li><li><blockquote><p>指针可以是 volatile</p></blockquote></li></ul><h3 id=assert><a href=#assert class=headerlink title=assert()></a>assert()</h3><blockquote><p>断言，是宏，而非函数。assert 宏的原型定义在 <code>&lt;assert.h&gt;</code>（C）、<code>&lt;cassert&gt;</code>（C++）中，其作用是如果它的条件返回错误，则终止程序执行。可以通过定义 <code>NDEBUG</code> 来关闭 assert，但是需要在源代码的开头，<code>include &lt;assert.h&gt;</code> 之前。</p></blockquote><blockquote><p>assert() 使用</p></blockquote><figure class="highlight c++"><table><tr><td class=code><pre><span class=line><span class=meta>#<span class=keyword>define</span> NDEBUG          <span class=comment>// 加上这行，则 assert 不可用  </span></span></span><br><span class=line><span class=meta>#<span class=keyword>include</span> <span class=string>&lt;assert.h&gt;</span>  </span></span><br><span class=line></span><br><span class=line><span class=built_in>assert</span>( p != <span class=literal>NULL</span> );    <span class=comment>// assert 不可用</span></span><br></pre></td></tr></table></figure><h3 id=explicit><a href=#explicit class=headerlink title=explicit></a>explicit</h3><ul><li><p>c++类型转换分为两种，一种是显示转换，一种是隐式转换</p><figure class="highlight c++"><table><tr><td class=code><pre><span class=line><span class=type>int</span> n = <span class=number>10</span>;</span><br><span class=line><span class=type>float</span> f = n;<span class=comment>//隐式转换，编译器不会报错</span></span><br><span class=line>常见的隐式转换 <span class=type>char</span>-&gt;<span class=type>int</span>-&gt;<span class=type>long</span>-&gt;<span class=type>double</span></span><br><span class=line>						<span class=type>float</span>-&gt;<span class=type>double</span></span><br><span class=line><span class=comment>//当然 double转int也不会报错 double d = 10; int s = d;通过，但是警告</span></span><br><span class=line><span class=comment>//还有其他的隐式转换</span></span><br><span class=line>  </span><br><span class=line><span class=comment>//explicit作用是声明为显示转换，不允许使用隐式转换</span></span><br><span class=line><span class=keyword>struct</span> <span class="title class_">test1</span></span><br><span class=line>&#123;</span><br><span class=line>    <span class=comment>//explicit</span></span><br><span class=line>    <span class=built_in>test1</span>(<span class=type>int</span> a, <span class=type>int</span> b = <span class=number>0</span>) : <span class=built_in>x</span>(a), <span class=built_in>y</span>(b)&#123;&#125;</span><br><span class=line>    test1 <span class=keyword>operator</span>+(<span class=type>const</span> test1 &amp;t) <span class=comment>//运算符重载，重载 + 号</span></span><br><span class=line>    &#123;</span><br><span class=line>        <span class=keyword>return</span> <span class=built_in>test1</span>(x + t.x, y + t.y);</span><br><span class=line>    &#125;</span><br><span class=line></span><br><span class=line>    <span class=type>int</span> x, y;</span><br><span class=line>&#125;;</span><br><span class=line></span><br><span class=line><span class=function><span class=type>int</span> <span class=title>main</span><span class=params>()</span></span></span><br><span class=line><span class=function></span>&#123;</span><br><span class=line>    <span class=function>test1 <span class=title>x</span><span class=params>(<span class=number>5</span>, <span class=number>6</span>)</span></span>;  <span class=comment>//调用初始化列表</span></span><br><span class=line>    test1 x1 = x + <span class=number>1</span>; <span class=comment>//这里编译是可以通过的，因为初始化列表可以传入一个参数，想当于test1 x1 = x + test(1) 隐式调用构造函数 ，如果加上exolicit，则编译不通过，报错</span></span><br><span class=line>    cout &lt;&lt; x1.x &lt;&lt; <span class=string>&#x27; &#x27;</span> &lt;&lt; x1.y &lt;&lt; endl;</span><br><span class=line>    <span class=keyword>return</span> <span class=number>0</span>;</span><br><span class=line>&#125;</span><br><span class=line></span><br></pre></td></tr></table></figure></li><li><p>为什么需要explicit</p><ul><li>编译器非常智能，他已经会把能匹配到的构造函数自动调用起来，但是有些时候，我们设计的类可能并不希望其隐式调用，那怎么办呢？就需要用到C++中一个关键字：explicit。<br>当我们将上面代码中explicit取消掉注释的时候，这段代码编译时就会报错，这样就防止了编译器太过智能，隐式调用构造函数的问题了。</li></ul></li></ul><h3 id=""><a href=# class=headerlink title=""></a></h3><h3 id=pragma-pack-n><a href=#pragma-pack-n class=headerlink title="#pragma pack(n)"></a>#pragma pack(n)</h3><blockquote><p>设定结构体、联合以及类成员变量以 n 字节方式对齐</p></blockquote><blockquote><p>#pragma pack(n) 使用</p></blockquote><figure class="highlight plaintext"><table><tr><td class=code><pre><span class=line>#pragma pack(push)  // 保存对齐状态  </span><br><span class=line>#pragma pack(4)     // 设定为 4 字节对齐  </span><br><span class=line>#pragma pack(2)  //设定以2字节对齐  </span><br><span class=line>struct test  </span><br><span class=line>&#123;  </span><br><span class=line>    char m1;  </span><br><span class=line>    double m4;  </span><br><span class=line>    int m3;  </span><br><span class=line>&#125;;  </span><br><span class=line></span><br><span class=line>#pragma pack(pop)   // 恢复对齐状态</span><br></pre></td></tr></table></figure><h3 id=位域><a href=#位域 class=headerlink title=位域></a>位域</h3><figure class="highlight plaintext"><table><tr><td class=code><pre><span class=line>Bit mode: 2;    // mode 占 2 位</span><br></pre></td></tr></table></figure><blockquote><p>类可以将其普通数据成员（非静态）定义为位域（bit-field），在一个位域中含有一定数量的二进制位。当一个程序需要向其他程序或硬件设备传递二进制数据时，通常会用到位域。</p></blockquote><ul><li><blockquote><p>位域在内存中的布局是与机器有关的</p></blockquote></li><li><blockquote><p>位域的类型必须是整型或枚举类型，带符号类型中的位域的行为将因具体实现而定</p></blockquote></li><li><blockquote><p>取地址运算符（&amp;）不能作用于位域，任何指针都无法指向类的位域</p></blockquote></li></ul><h3 id=union-联合><a href=#union-联合 class=headerlink title="union 联合"></a>union 联合</h3><blockquote><p>联合（union）是一种节省空间的特殊的类，一个 union 可以有多个数据成员，但是在任意时刻只有一个数据成员可以有值。当某个成员被赋值后其他成员变为未定义状态。联合有如下特点：</p></blockquote><ul><li>默认访问控制符为 public</li><li>可以含有构造函数、析构函数</li><li>不能含有引用类型的成员</li><li>不能继承自其他类，不能作为基类</li><li>不能含有虚函数</li><li>匿名 union 在定义所在作用域可直接访问 union 成员</li><li>匿名 union 不能包含 protected 成员或 private 成员</li><li>全局匿名联合必须是静态（static）的</li></ul><blockquote><p>union 使用</p></blockquote><figure class="highlight plaintext"><table><tr><td class=code><pre><span class=line>#include&lt;iostream&gt;  </span><br><span class=line>union UnionTest &#123;  </span><br><span class=line>    UnionTest() : i(10) &#123;&#125;;  //构造函数  </span><br><span class=line>    int i;  </span><br><span class=line>    double d;  </span><br><span class=line>&#125;;  </span><br><span class=line>static union &#123;   </span><br><span class=line>    int i;  </span><br><span class=line>    double d;  </span><br><span class=line>&#125;;  </span><br><span class=line>int main() &#123;  </span><br><span class=line>    UnionTest u;  </span><br><span class=line>    union &#123;  //匿名联合  </span><br><span class=line>        int i;  </span><br><span class=line>        double d;  </span><br><span class=line>    &#125;;  </span><br><span class=line>    std::cout &lt;&lt; u.i &lt;&lt; std::endl;  // 输出 UnionTest 联合的 10  </span><br><span class=line>    ::i = 20;  </span><br><span class=line>    std::cout &lt;&lt; ::i &lt;&lt; std::endl;  // 输出全局静态匿名联合的 20  </span><br><span class=line>    i = 30;  </span><br><span class=line>    std::cout &lt;&lt; i &lt;&lt; std::endl;    // 输出局部匿名联合的 30  </span><br><span class=line>    return 0;  </span><br><span class=line>&#125;</span><br></pre></td></tr></table></figure><h3 id=enum-枚举类型><a href=#enum-枚举类型 class=headerlink title="enum 枚举类型"></a>enum 枚举类型</h3><blockquote><p>限定作用域的枚举类型</p></blockquote><figure class="highlight plaintext"><table><tr><td class=code><pre><span class=line>enum class open_modes &#123; input, output, append &#125;;</span><br></pre></td></tr></table></figure><blockquote><p>不限定作用域的枚举类型</p></blockquote><figure class="highlight plaintext"><table><tr><td class=code><pre><span class=line>enum color &#123; red, yellow, green &#125;;  </span><br><span class=line>enum &#123; floatPrec = 6, doublePrec = 10 &#125;;</span><br></pre></td></tr></table></figure><h3 id=decltype><a href=#decltype class=headerlink title=decltype></a>decltype</h3><blockquote><p>decltype 关键字用于检查实体的声明类型或表达式的类型及值分类。语法：</p></blockquote><figure class="highlight plaintext"><table><tr><td class=code><pre><span class=line>decltype ( expression )</span><br></pre></td></tr></table></figure><blockquote><p>decltype 使用</p></blockquote><figure class="highlight plaintext"><table><tr><td class=code><pre><span class=line>// 尾置返回允许我们在参数列表之后声明返回类型  </span><br><span class=line>template &lt;typename It&gt;  </span><br><span class=line>auto fcn(It beg, It end) -&gt; decltype(*beg)  </span><br><span class=line>&#123;  </span><br><span class=line>    // 处理序列  </span><br><span class=line>    return *beg;    // 返回序列中一个元素的引用  </span><br><span class=line>&#125;  </span><br><span class=line>// 为了使用模板参数成员，必须用 typename  </span><br><span class=line>template &lt;typename It&gt;  </span><br><span class=line>auto fcn2(It beg, It end) -&gt; typename remove_reference&lt;decltype(*beg)&gt;::type  </span><br><span class=line>&#123;  </span><br><span class=line>    // 处理序列  </span><br><span class=line>    return *beg;    // 返回序列中一个元素的拷贝  </span><br><span class=line>&#125;</span><br></pre></td></tr></table></figure><h3 id=智能指针><a href=#智能指针 class=headerlink title=智能指针></a>智能指针</h3><ul><li><p><strong>智能指针有什么用？</strong></p><ul><li><p>如果不用智能指针，每次申请的内存都要手动释放，程序员要关心申请的内存是否被释放，不然容易造成内存泄露</p></li><li><p>使用智能指针，程序员只需要申请内存，不需要关心内存的释放；如</p></li><li><p>&#96;&#96;&#96;c++<br>class A{<br>public:<br>~A(){<br>cout &lt;&lt; “析构函数被调用” &lt;&lt; endl;<br>}<br>};</p><p>int main() {<br>{<br>unique_ptr<a> s(new A);<br>}<br>cout&lt;&lt; “程序结束” &lt;&lt; endl;<br>}<br>&#x2F;&#x2F;输出结果<br>&#x2F;&#x2F;析构函数被调用 &#x2F;&#x2F;结论，使用智能指针会自动师范内存<br>&#x2F;&#x2F;程序结束</a></p><figure class="highlight plaintext"><table><tr><td class=code><pre><span class=line></span><br><span class=line>    </span><br><span class=line></span><br><span class=line>&gt; C++ 标准库（STL）中</span><br><span class=line></span><br><span class=line>&gt; 头文件：`#include &lt;memory&gt;`</span><br><span class=line></span><br><span class=line>&gt; C++ 98 </span><br><span class=line></span><br><span class=line></span><br><span class=line>```c++</span><br><span class=line>//使用方式</span><br><span class=line>std::auto_ptr&lt;std::string&gt; ps (new std::string(str))；</span><br><span class=line>//例如，又一个A类</span><br><span class=line>unique_ptr&lt;A&gt; p(new A); </span><br></pre></td></tr></table></figure></li></ul></li></ul><blockquote><p>C++ 11</p></blockquote><figure class="highlight c++"><table><tr><td class=code><pre><span class=line>shared_ptr</span><br><span class=line>unique_ptr</span><br><span class=line>weak_ptr</span><br><span class=line>auto_ptr（被 C++<span class=number>11</span> 弃用）</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class=code><pre><span class=line><span class=comment>//智能指针的使用</span></span><br><span class=line></span><br><span class=line><span class=comment>//unique_ptr实现只能有一个指针指向该地址</span></span><br><span class=line><span class=function><span class=type>int</span> <span class=title>main</span><span class=params>()</span> </span>&#123;</span><br><span class=line>	<span class=function>unique_ptr&lt;<span class=type>int</span>&gt; <span class=title>p</span><span class=params>(<span class=keyword>new</span> <span class=type>int</span>(<span class=number>11</span>))</span></span>;</span><br><span class=line>	<span class=comment>//unique_ptr&lt;int&gt; p1 = p;  调用拷贝构造函数报错，unique_ptr是独占是拥有，不可以两个指针指向同一个地址</span></span><br><span class=line>	<span class=comment>//int * p2 = p; 也报错</span></span><br><span class=line>	unique_ptr&lt;<span class=type>int</span>&gt; p3 = <span class=built_in>move</span>(p); <span class=comment>//编译正确，调用移动构造函数</span></span><br><span class=line></span><br><span class=line>	<span class=comment>//cout&lt;&lt; *p &lt;&lt; endl; 程序奔溃，p已经为野指针</span></span><br><span class=line>	cout &lt;&lt; *p3 &lt;&lt;endl; <span class=comment>//正确</span></span><br><span class=line>&#125;</span><br><span class=line></span><br><span class=line><span class=keyword>class</span> <span class="title class_">A</span>&#123;</span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>	~<span class=built_in>A</span>()&#123;</span><br><span class=line>		cout &lt;&lt; <span class=string>&quot;析构函数被调用&quot;</span> &lt;&lt;endl;</span><br><span class=line>	&#125;</span><br><span class=line>&#125;;</span><br><span class=line></span><br><span class=line></span><br><span class=line><span class=comment>//shared_ptr实现共享同一地址，当最后一个指向该地址的指针释放时才调用析构函数</span></span><br><span class=line><span class=function><span class=type>int</span> <span class=title>main</span><span class=params>()</span> </span>&#123;</span><br><span class=line>	<span class=function>shared_ptr&lt;A&gt; <span class=title>p</span><span class=params>(<span class=keyword>new</span> A)</span></span>;</span><br><span class=line>	cout &lt;&lt; p.<span class=built_in>use_count</span>() &lt;&lt; endl;  <span class=comment>//输出1，引用为1</span></span><br><span class=line>	<span class=comment>//A * p1 = p; 报错，不可以这样</span></span><br><span class=line>	shared_ptr&lt;A&gt; p2 = p; <span class=comment>//正确，可以调用构造，两个指针指向同一地址</span></span><br><span class=line>	cout &lt;&lt; p2.<span class=built_in>use_count</span>() &lt;&lt; endl; <span class=comment>//输出2，指向该地址的指针为2</span></span><br><span class=line></span><br><span class=line>	p.<span class=built_in>reset</span>();     <span class=comment>//不会调用析构函数</span></span><br><span class=line>	cout &lt;&lt; <span class=string>&quot;分割线&quot;</span> &lt;&lt; endl;</span><br><span class=line>	p2.<span class=built_in>reset</span>(); <span class=comment>//输出：析构函数调用</span></span><br><span class=line></span><br><span class=line>&#125;</span><br><span class=line></span><br><span class=line></span><br><span class=line><span class=comment>//weak_ptr主要配合shraed_ptr使用，一旦指向的地址释放，weak_ptr自动为空</span></span><br><span class=line><span class=keyword>class</span> <span class="title class_">A</span>&#123;   <span class=comment>//且weak_ptr指向的地址，不会让use_count() 增加</span></span><br><span class=line><span class=keyword>public</span>:  <span class=comment>//weak_ptr无权访问堆区内容，前面加上* 或者 -&gt; 调用堆区内容是不允许的</span></span><br><span class=line>	~<span class=built_in>A</span>()&#123;</span><br><span class=line>		cout &lt;&lt; <span class=string>&quot;析构函数被调用&quot;</span> &lt;&lt;endl;</span><br><span class=line>	&#125;</span><br><span class=line>&#125;;</span><br><span class=line></span><br><span class=line><span class=function><span class=type>int</span> <span class=title>main</span><span class=params>()</span> </span>&#123;</span><br><span class=line>	<span class=function>shared_ptr&lt;A&gt; <span class=title>p</span><span class=params>(<span class=keyword>new</span> A)</span></span>;</span><br><span class=line>	cout &lt;&lt; p.<span class=built_in>use_count</span>() &lt;&lt; endl;  <span class=comment>//输出1</span></span><br><span class=line>	weak_ptr&lt;A&gt; p1 = p; </span><br><span class=line>	<span class=comment>//cout &lt;&lt; *p1 &lt;&lt; endl; 报错，weak_ptr能指向地址，但是不拥有该对象</span></span><br><span class=line>	cout &lt;&lt; p.<span class=built_in>use_count</span>() &lt;&lt; endl; <span class=comment>//输出1；</span></span><br><span class=line>	p.<span class=built_in>reset</span>(); <span class=comment>//输出 ：析构函数被调用</span></span><br><span class=line>	shared_ptr&lt;A&gt; p2 = p1.<span class=built_in>lock</span>(); <span class=comment>//weak_ptr能通过lock（）函数把地址传递给其他指针</span></span><br><span class=line>	<span class=comment>//但是p1指向的地址已经释放，所以p1自动为空，即 p2 = nullptr；</span></span><br><span class=line>	<span class=keyword>if</span>(p2 == <span class=literal>nullptr</span>) cout &lt;&lt; <span class=string>&quot;堆区已经被全部释放&quot;</span> &lt;&lt; endl; <span class=comment>//条件成立，输出堆区已经被全部释放</span></span><br><span class=line>&#125;</span><br></pre></td></tr></table></figure><ul><li>Class shared_ptr 实现共享式拥有（shared ownership）概念。多个智能指针指向相同对象，该对象和其相关资源会在 “最后一个 reference（引用） 被销毁” 时被释放。为了在结构较复杂的情景中执行上述工作，标准库提供 weak_ptr、bad_weak_ptr 和 enable_shared_from_this 等辅助类。</li><li>Class unique_ptr 实现独占式拥有（exclusive ownership）或严格拥有（strict ownership）概念，保证同一时间内只有一个智能指针可以指向该对象。你可以移交拥有权。它对于避免内存泄漏（resource leak）——如 new 后忘记 delete ——特别有用。</li></ul><blockquote><p><code>shared_ptr</code></p></blockquote><blockquote><p>多个智能指针可以共享同一个对象，对象的最末一个拥有着有责任销毁对象，并清理与该对象相关的所有资源。</p></blockquote><ul><li>支持定制型删除器（custom deleter），可防范 Cross-DLL 问题（对象在动态链接库（DLL）中被 new 创建，却在另一个 DLL 内被 delete 销毁）、自动解除互斥锁</li></ul><blockquote><p><code>weak_ptr</code></p></blockquote><blockquote><p>weak_ptr 允许你共享但不拥有某对象，一旦最末一个拥有该对象的智能指针失去了所有权，任何 weak_ptr 都会自动成空（empty）。因此，在 default 和 copy 构造函数之外，weak_ptr 只提供 接受一个 shared_ptr 的构造函数。</p></blockquote><ul><li>可打破环状引用（cycles of references，两个其实已经没有被使用的对象彼此互指，使之看似还在 “被使用” 的状态）的问题</li></ul><blockquote><p><code>unique_ptr</code></p></blockquote><blockquote><p>unique_ptr 是 C++11 才开始提供的类型，是一种在异常时可以帮助避免资源泄漏的智能指针。采用独占式拥有，意味着可以确保一个对象和其相应的资源同一时间只被一个 pointer 拥有。一旦拥有着被销毁或编程 empty，或开始拥有另一个对象，先前拥有的那个对象就会被销毁，其任何相应资源亦会被释放。</p></blockquote><ul><li>unique_ptr 用于取代 auto_ptr</li></ul><blockquote><p><code>auto_ptr</code></p></blockquote><blockquote><p>被 c++11 弃用，原因是缺乏语言特性如 针对构造和赋值 的 <code>std::move</code> 语义，以及其他瑕疵。</p></blockquote><blockquote><p><code>auto_ptr 与 unique_ptr 比较</code></p></blockquote><ul><li>auto_ptr 可以赋值拷贝，复制拷贝后所有权转移；unqiue_ptr 无拷贝赋值语义，但实现了<code>move</code> 语义；</li><li>auto_ptr 对象不能管理数组（析构调用 <code>delete</code>），unique_ptr 可以管理数组（析构调用 <code>delete[]</code> ）；</li></ul><h3 id=C-的四种强制转换><a href=#C-的四种强制转换 class=headerlink title=C++的四种强制转换></a>C++的四种强制转换</h3><p><strong>reinterpret_cast</strong></p><p><code>reinterpret_cast&lt;type-id&gt; (expression)</code></p><p>type-id 必须是一个指针、引用、算术类型、函数指针或者成员指针。它可以用于类型之间进行强制转换。</p><p><strong>const_cast</strong></p><p><code>const_cast (expression)</code></p><p>该运算符用来修改类型的const或volatile属性。除了const 或volatile修饰之外， type_id和expression的类型是一样的。用法如下：</p><ul><li>常量指针被转化成非常量的指针，并且仍然指向原来的对象</li><li>常量引用被转换成非常量的引用，并且仍然指向原来的对象</li><li>const_cast一般用于修改底指针。如const char *p形式</li></ul><p><strong>static_cast</strong></p><p>static_cast &lt; type-id &gt; (expression)</p><p>该运算符把expression转换为type-id类型，但没有运行时类型检查来保证转换的安全性。它主要有如下几种用法：</p><ul><li>用于类层次结构中基类（父类）和派生类（子类）之间指针或引用引用的转换<ul><li>进行上行转换（把派生类的指针或引用转换成基类表示）是安全的</li><li>进行下行转换（把基类指针或引用转换成派生类表示）时，由于没有动态类型检查，所以是不安全的</li></ul></li><li>用于基本数据类型之间的转换，如把int转换成char，把int转换成enum。这种转换的安全性也要开发人员来保证。</li><li>把空指针转换成目标类型的空指针</li><li>把任何类型的表达式转换成void类型</li></ul><p>注意：static_cast不能转换掉expression的const、volatile、或者__unaligned属性。</p><p><strong>dynamic_cast</strong></p><p>有类型检查，基类向派生类转换比较安全，但是派生类向基类转换则不太安全</p><p>dynamic_cast (expression)</p><p>该运算符把expression转换成type-id类型的对象。type-id 必须是类的指针、类的引用或者void*</p><p>如果 type-id 是类指针类型，那么expression也必须是一个指针，如果 type-id 是一个引用，那么 expression 也必须是一个引用</p><p>dynamic_cast运算符可以在执行期决定真正的类型，也就是说expression必须是多态类型。如果下行转换是安全的（也就说，如果基类指针或者引用确实指向一个派生类对象）这个运算符会传回适当转型过的指针。如果 如果下行转换不安全，这个运算符会传回空指针（也就是说，基类指针或者引用没有指向一个派生类对象）</p><p>dynamic_cast主要用于类层次间的上行转换和下行转换，还可以用于类之间的交叉转换</p><p>在类层次间进行上行转换时，dynamic_cast和static_cast的效果是一样的</p><p>在进行下行转换时，dynamic_cast具有类型检查的功能，比static_cast更安全</p><p>举个例子：</p><figure class="highlight cpp"><table><tr><td class=code><pre><span class=line><span class=meta>#<span class=keyword>include</span> <span class=string>&lt;bits/stdc++.h&gt;</span></span></span><br><span class=line><span class=keyword>using</span> <span class=keyword>namespace</span> std;</span><br><span class=line></span><br><span class=line><span class=keyword>class</span> <span class="title class_">Base</span></span><br><span class=line>&#123;</span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>    <span class=built_in>Base</span>() :<span class=built_in>b</span>(<span class=number>1</span>) &#123;&#125;</span><br><span class=line>    <span class=function><span class=keyword>virtual</span> <span class=type>void</span> <span class=title>fun</span><span class=params>()</span> </span>&#123;&#125;;</span><br><span class=line>    <span class=type>int</span> b;</span><br><span class=line>&#125;;</span><br><span class=line></span><br><span class=line><span class=keyword>class</span> <span class="title class_">Son</span> : <span class=keyword>public</span> Base</span><br><span class=line>&#123;</span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>    <span class=built_in>Son</span>() :<span class=built_in>d</span>(<span class=number>2</span>) &#123;&#125;</span><br><span class=line>    <span class=type>int</span> d;</span><br><span class=line>&#125;;</span><br><span class=line></span><br><span class=line><span class=function><span class=type>int</span> <span class=title>main</span><span class=params>()</span></span></span><br><span class=line><span class=function></span>&#123;</span><br><span class=line>    <span class=type>int</span> n = <span class=number>97</span>;</span><br><span class=line></span><br><span class=line>    <span class=comment>//reinterpret_cast</span></span><br><span class=line>    <span class=type>int</span> *p = &amp;n;</span><br><span class=line>    <span class=comment>//以下两者效果相同</span></span><br><span class=line>    <span class=type>char</span> *c = <span class=built_in>reinterpret_cast</span>&lt;<span class=type>char</span>*&gt; (p); </span><br><span class=line>    <span class=type>char</span> *c2 =  (<span class=type>char</span>*)(p);</span><br><span class=line>    cout &lt;&lt; <span class=string>&quot;reinterpret_cast输出：&quot;</span>&lt;&lt; *c2 &lt;&lt; endl;</span><br><span class=line>    <span class=comment>//const_cast</span></span><br><span class=line>    <span class=type>const</span> <span class=type>int</span> *p2 = &amp;n;</span><br><span class=line>    <span class=type>int</span> *p3 = <span class=built_in>const_cast</span>&lt;<span class=type>int</span>*&gt;(p2);</span><br><span class=line>    *p3 = <span class=number>100</span>;</span><br><span class=line>    cout &lt;&lt; <span class=string>&quot;const_cast输出：&quot;</span> &lt;&lt; *p3 &lt;&lt; endl;</span><br><span class=line></span><br><span class=line>    Base* b1 = <span class=keyword>new</span> Son;</span><br><span class=line>    Base* b2 = <span class=keyword>new</span> Base;</span><br><span class=line></span><br><span class=line>    <span class=comment>//static_cast</span></span><br><span class=line>    Son* s1 = <span class=built_in>static_cast</span>&lt;Son*&gt;(b1); <span class=comment>//同类型转换</span></span><br><span class=line>    Son* s2 = <span class=built_in>static_cast</span>&lt;Son*&gt;(b2); <span class=comment>//下行转换，不安全</span></span><br><span class=line>    cout &lt;&lt; <span class=string>&quot;static_cast输出：&quot;</span>&lt;&lt; endl;</span><br><span class=line>    cout &lt;&lt; s1-&gt;d &lt;&lt; endl;</span><br><span class=line>    cout &lt;&lt; s2-&gt;d &lt;&lt; endl; <span class=comment>//下行转换，原先父对象没有d成员，输出垃圾值</span></span><br><span class=line></span><br><span class=line>    <span class=comment>//dynamic_cast</span></span><br><span class=line>    Son* s3 = <span class=built_in>dynamic_cast</span>&lt;Son*&gt;(b1); <span class=comment>//同类型转换</span></span><br><span class=line>    Son* s4 = <span class=built_in>dynamic_cast</span>&lt;Son*&gt;(b2); <span class=comment>//下行转换，安全</span></span><br><span class=line>    cout &lt;&lt; <span class=string>&quot;dynamic_cast输出：&quot;</span> &lt;&lt; endl;</span><br><span class=line>    cout &lt;&lt; s3-&gt;d &lt;&lt; endl;</span><br><span class=line>    <span class=keyword>if</span>(s4 == <span class=literal>nullptr</span>)</span><br><span class=line>        cout &lt;&lt; <span class=string>&quot;s4指针为nullptr&quot;</span> &lt;&lt; endl;</span><br><span class=line>    <span class=keyword>else</span></span><br><span class=line>        cout &lt;&lt; s4-&gt;d &lt;&lt; endl;</span><br><span class=line></span><br><span class=line></span><br><span class=line>    <span class=keyword>return</span> <span class=number>0</span>;</span><br><span class=line>&#125;</span><br><span class=line><span class=comment>//输出结果</span></span><br><span class=line><span class=comment>//reinterpret_cast输出：a</span></span><br><span class=line><span class=comment>//const_cast输出：100</span></span><br><span class=line><span class=comment>//static_cast输出：</span></span><br><span class=line><span class=comment>//2</span></span><br><span class=line><span class=comment>//-33686019</span></span><br><span class=line><span class=comment>//dynamic_cast输出：</span></span><br><span class=line><span class=comment>//2</span></span><br><span class=line><span class=comment>//s4指针为nullptrCopy to clipboardErrorCopied</span></span><br></pre></td></tr></table></figure><p>从输出结果可以看出，在进行下行转换时，dynamic_cast安全的，如果下行转换不安全的话其会返回空指针，这样在进行操作的时候可以预先判断。而使用static_cast下行转换存在不安全的情况也可以转换成功，但是直接使用转换后的对象进行操作容易造成错误。</p><h3 id=运行时类型信息-RTTI><a href=#运行时类型信息-RTTI class=headerlink title="运行时类型信息 (RTTI)"></a>运行时类型信息 (RTTI)</h3><blockquote><p>dynamic_cast</p></blockquote><ul><li>用于多态类型的转换</li></ul><blockquote><p>typeid</p></blockquote><ul><li>typeid 运算符允许在运行时确定对象的类型</li><li>type_id 返回一个 type_info 对象的引用</li><li>如果想通过基类的指针获得派生类的数据类型，基类必须带有虚函数</li><li>只能获取对象的实际类型</li></ul><blockquote><p>type_info</p></blockquote><ul><li>type_info 类描述编译器在程序中生成的类型信息。 此类的对象可以有效存储指向类型的名称的指针。 type_info 类还可存储适合比较两个类型是否相等或比较其排列顺序的编码值。 类型的编码规则和排列顺序是未指定的，并且可能因程序而异。</li><li>头文件：<code>typeinfo</code></li></ul><blockquote><p>typeid、type_info 使用</p></blockquote><figure class="highlight plaintext"><table><tr><td class=code><pre><span class=line>#include &lt;iostream&gt;  </span><br><span class=line>using namespace std;  </span><br><span class=line></span><br><span class=line>class Flyable                       // 能飞的  </span><br><span class=line>&#123;  </span><br><span class=line>public:  </span><br><span class=line>    virtual void takeoff() = 0;     // 起飞  </span><br><span class=line>    virtual void land() = 0;        // 降落  </span><br><span class=line>&#125;;  </span><br><span class=line>class Bird : public Flyable         // 鸟  </span><br><span class=line>&#123;  </span><br><span class=line>public:  </span><br><span class=line>    void foraging() &#123;...&#125;           // 觅食  </span><br><span class=line>    virtual void takeoff() &#123;...&#125;  </span><br><span class=line>    virtual void land() &#123;...&#125;  </span><br><span class=line>    virtual ~Bird()&#123;&#125;  </span><br><span class=line>&#125;;  </span><br><span class=line>class Plane : public Flyable        // 飞机  </span><br><span class=line>&#123;  </span><br><span class=line>public:  </span><br><span class=line>    void carry() &#123;...&#125;              // 运输  </span><br><span class=line>    virtual void takeoff() &#123;...&#125;  </span><br><span class=line>    virtual void land() &#123;...&#125;  </span><br><span class=line>&#125;;  </span><br><span class=line></span><br><span class=line>class type_info  </span><br><span class=line>&#123;  </span><br><span class=line>public:  </span><br><span class=line>    const char* name() const;  </span><br><span class=line>    bool operator == (const type_info &amp; rhs) const;  </span><br><span class=line>    bool operator != (const type_info &amp; rhs) const;  </span><br><span class=line>    int before(const type_info &amp; rhs) const;  </span><br><span class=line>    virtual ~type_info();  </span><br><span class=line>private:  </span><br><span class=line>    ...  </span><br><span class=line>&#125;;  </span><br><span class=line></span><br><span class=line>void doSomething(Flyable *obj)                 // 做些事情  </span><br><span class=line>&#123;  </span><br><span class=line>    obj-&gt;takeoff();  </span><br><span class=line></span><br><span class=line>    cout &lt;&lt; typeid(*obj).name() &lt;&lt; endl;        // 输出传入对象类型（&quot;class Bird&quot; or &quot;class Plane&quot;）  </span><br><span class=line></span><br><span class=line>    if(typeid(*obj) == typeid(Bird))            // 判断对象类型  </span><br><span class=line>    &#123;  </span><br><span class=line>        Bird *bird = dynamic_cast&lt;Bird *&gt;(obj); // 对象转化  </span><br><span class=line>        bird-&gt;foraging();  </span><br><span class=line>    &#125;  </span><br><span class=line></span><br><span class=line>    obj-&gt;land();  </span><br><span class=line>&#125;  </span><br><span class=line></span><br><span class=line>int main()&#123;  </span><br><span class=line>	Bird *b = new Bird();  </span><br><span class=line>	doSomething(b);  </span><br><span class=line>	delete b;  </span><br><span class=line>	b = nullptr;  </span><br><span class=line>	return 0;  </span><br><span class=line>&#125;</span><br></pre></td></tr></table></figure><h4 id=-1><a href=#-1 class=headerlink title=""></a></h4><h3 id=-2><a href=#-2 class=headerlink title=""></a></h3><h3 id=size-、length-、strlen-、sizeof><a href=#size-、length-、strlen-、sizeof class=headerlink title=size()、length()、strlen()、sizeof()></a>size()、length()、strlen()、sizeof()</h3><ul><li><blockquote><p>size()和length()这两个函数是用来计算string类对象或者即STL对象方法。都是计算字符串长度。</p></blockquote></li><li><blockquote><p>strlen()是函数，参数必须是字符型指针（char*），计算从开始到结束（’\0），返回的长度大小不包括’\0’，也是计算字符长度。</p></blockquote></li><li><blockquote><p>sizeof()是运算符，不能计算复杂内存分配空间大小。计算字符所占空间大小。</p></blockquote></li></ul><h3 id=malloc、free><a href=#malloc、free class=headerlink title=malloc、free></a>malloc、free</h3><blockquote><p>用于分配、释放内存</p></blockquote><blockquote><p>malloc、free 使用</p></blockquote><blockquote><p>申请内存，确认是否申请成功</p></blockquote><figure class="highlight c++"><table><tr><td class=code><pre><span class=line><span class=type>char</span> *str = (<span class=type>char</span>*) <span class=built_in>malloc</span>(<span class=number>100</span>);  </span><br><span class=line><span class=built_in>assert</span>(str != <span class=literal>nullptr</span>);</span><br></pre></td></tr></table></figure><blockquote><p>释放内存后指针置空</p></blockquote><figure class="highlight c++"><table><tr><td class=code><pre><span class=line><span class=built_in>free</span>(p);   </span><br><span class=line>p = <span class=literal>nullptr</span>;</span><br></pre></td></tr></table></figure><h3 id=new、delete><a href=#new、delete class=headerlink title=new、delete></a>new、delete</h3><figure class="highlight c++"><table><tr><td class=code><pre><span class=line><span class=keyword>new</span> / <span class=keyword>new</span>[]：完成两件事，先底层调用 malloc 分配了内存，然后调用构造函数（创建对象）。</span><br><span class=line> </span><br><span class=line>  </span><br><span class=line><span class=keyword>delete</span>/<span class=keyword>delete</span>[]：也完成两件事，先调用析构函数（清理资源），然后底层调用 free 释放空间</span><br><span class=line>  </span><br><span class=line><span class=keyword>delete</span>[] 如何确定释放多少空间，会在<span class=keyword>new</span>[]的时候多分配地址（比如多分配一个<span class=type>int</span>类型的空间），记录数组的个数</span><br></pre></td></tr></table></figure><blockquote><p>new、delete 使用</p></blockquote><blockquote><p>申请内存，确认是否申请成功</p></blockquote><figure class="highlight c++"><table><tr><td class=code><pre><span class=line><span class=function><span class=type>int</span> <span class=title>main</span><span class=params>()</span>  </span></span><br><span class=line><span class=function></span>&#123;  </span><br><span class=line>    T* t = <span class=keyword>new</span> <span class=built_in>T</span>();     <span class=comment>// 先内存分配 ，再构造函数  </span></span><br><span class=line>    <span class=keyword>delete</span> t;           <span class=comment>// 先析构函数，再内存释放  </span></span><br><span class=line>    <span class=keyword>return</span> <span class=number>0</span>;  </span><br><span class=line>&#125;</span><br></pre></td></tr></table></figure><h3 id=new和malloc，delete和free的区别><a href=#new和malloc，delete和free的区别 class=headerlink title=new和malloc，delete和free的区别></a>new和malloc，delete和free的区别</h3><ul><li>new是运算符（new可以重载，重写），malloc是库函数</li><li>new自动计算要分配的大小，malloc需要手动计算</li><li>new是有类型检查的（因此使用new更安全），malloc只是机械的分配内存（存在危险） 如：</li><li>new返回的是对应类型的指针，malloc返回的时void类型，必须强制类型转换</li><li>分配失败时，new抛出bad_alloc，malloc返回空指针（NULL）；</li></ul><figure class="highlight c++"><table><tr><td class=code><pre><span class=line><span class=type>int</span> *p = <span class=keyword>new</span> <span class=type>float</span>[<span class=number>2</span>]; <span class=comment>//编译错误,内存分配不对，报错</span></span><br><span class=line></span><br><span class=line><span class=comment>//malloc返回的是void类型（无类型）的指针，必须进行强制类型转换</span></span><br><span class=line><span class=type>int</span> *p = (<span class=type>int</span>*)<span class=built_in>malloc</span>(<span class=number>2</span> * <span class=built_in>sizeof</span>(<span class=type>double</span>));<span class=comment>//编译无错误</span></span><br></pre></td></tr></table></figure><h3 id=库函数、运算符、系统调用><a href=#库函数、运算符、系统调用 class=headerlink title=库函数、运算符、系统调用></a>库函数、运算符、系统调用</h3><blockquote><p>库函数可以理解为系统调用的一个封装，系统调用就是操作系统提供给应用程序的接口（程序员只需要通过系统调用就能实现相应的功能，从而隐藏内部实现的细节，具体操作由操作系统实现），而库函数可以理解为对系统调用的再次封装（系统调用作为内核提供给用户的接口，执行效率非常高效和精简，但有时我们需要完成更为负责的操作和更人性化的设计），比如fopen为库函数，通过系统调用open来实现。函数可以<strong>自己定义</strong>也可通过头文件的引入使用C&#x2F;C++自带函数称<strong>库函数</strong>（就是人写的函数）。</p><p>运算符，+ - * &#x2F; 这些就是运算符，就是编译器按照指定的要求进行操作。</p></blockquote><h3 id=变量声明、定义><a href=#变量声明、定义 class=headerlink title=变量声明、定义></a>变量声明、定义</h3><ul><li>声明仅仅是把变量的声明的位置及类型提供给编译器，并不分配内存空间；定义要在定义的地方为其分配存储空间。</li><li>相同变量可以在多处声明（外部变量extern），但只能在一处定义。</li></ul><h3 id=C-和C的struct区别><a href=#C-和C的struct区别 class=headerlink title=C++和C的struct区别></a>C++和C的struct区别</h3><ul><li>c中struct没有权限设置，c++有public，protected，private</li><li>c中struct不可以有函数，c++可以有成员函数</li><li>c中struct不可继承，c++有public，protect，private三种继承方式（还可以实现多态）</li><li>c中struct和c++定义时不一样，c取别名要typedef，或者最后加上别名</li></ul><h3 id=定位-new><a href=#定位-new class=headerlink title="定位 new"></a>定位 new</h3><blockquote><p>定位 new（placement new）允许我们向 new 传递额外的地址参数，从而在预先指定的内存区域创建对象。</p></blockquote><figure class="highlight plaintext"><table><tr><td class=code><pre><span class=line>new (place_address) type  </span><br><span class=line>new (place_address) type (initializers)  </span><br><span class=line>new (place_address) type [size]  </span><br><span class=line>new (place_address) type [size] &#123; braced initializer list &#125;</span><br></pre></td></tr></table></figure><ul><li><code>place_address</code> 是个指针</li><li><code>initializers</code> 提供一个（可能为空的）以逗号分隔的初始值列表</li></ul><h3 id=函数指针和指针函数><a href=#函数指针和指针函数 class=headerlink title=函数指针和指针函数></a>函数指针和指针函数</h3><blockquote><p><code>参考回答</code></p></blockquote><ol><li><blockquote><p><code>定义不同</code> 指针函数本质是一个函数，其返回值为指针。 函数指针本质是一个指针，其指向一个函数。</p></blockquote></li><li><blockquote><p><code>写法不同</code></p></blockquote><figure class="highlight plaintext"><table><tr><td class=code><pre><span class=line>指针函数：int *fun(int x,int y);  </span><br><span class=line>函数指针：int (*fun)(int x,int y);</span><br></pre></td></tr></table></figure></li><li><blockquote><p><code>用法不同</code></p></blockquote><blockquote><p>用法参考答案解析</p></blockquote></li></ol><blockquote><p><code>答案解析</code></p></blockquote><figure class="highlight plaintext"><table><tr><td class=code><pre><span class=line>//指针函数示例  </span><br><span class=line>typedef struct _Data&#123;  </span><br><span class=line>    int a;  </span><br><span class=line>    int b;  </span><br><span class=line>&#125;Data;  </span><br><span class=line>//指针函数  </span><br><span class=line>Data* f(int a,int b)&#123;  </span><br><span class=line>    Data * data = new Data;  </span><br><span class=line>    //...  </span><br><span class=line>    return data;  </span><br><span class=line>&#125;  </span><br><span class=line>int main()&#123;  </span><br><span class=line>    //调用指针函数  </span><br><span class=line>    Data * myData = f(4,5);  </span><br><span class=line>    //Data * myData = static_cast&lt;Data*&gt;(f(4,5));  </span><br><span class=line>   //...  </span><br><span class=line>&#125;  </span><br><span class=line></span><br><span class=line>//函数指针示例  </span><br><span class=line>int add(int x,int y)&#123;  </span><br><span class=line>    return x+y;  </span><br><span class=line>&#125;  </span><br><span class=line>//函数指针  </span><br><span class=line>int (*fun)(int x,int y);  </span><br><span class=line>//赋值  </span><br><span class=line>fun = add;  </span><br><span class=line>//调用  </span><br><span class=line>cout &lt;&lt; &quot;(*fun)(1,2) = &quot; &lt;&lt; (*fun)(1,2) ;  </span><br><span class=line>//输出结果  </span><br><span class=line>//(*fun)(1,2) =  3</span><br></pre></td></tr></table></figure><h3 id=引用><a href=#引用 class=headerlink title=引用></a>引用</h3><blockquote><p>左值引用</p></blockquote><blockquote><p>常规引用，一般表示对象的身份。</p></blockquote><blockquote><p>右值引用</p></blockquote><blockquote><p>右值引用就是必须绑定到右值（一个临时对象、将要销毁的对象）的引用，一般表示对象的值。</p></blockquote><blockquote><p>右值引用可实现转移语义（Move Sementics）和精确传递（Perfect Forwarding），它的主要目的有两个方面：</p></blockquote><ul><li>消除两个对象交互时不必要的对象拷贝，节省运算存储资源，提高效率。</li><li>能够更简洁明确地定义泛型函数。</li></ul><blockquote><p>引用折叠</p></blockquote><ul><li><blockquote><p><code>X&amp; &amp;</code>、<code>X&amp; &amp;&amp;</code>、<code>X&amp;&amp; &amp;</code> 可折叠成 <code>X&amp;</code></p></blockquote></li><li><blockquote><p><code>X&amp;&amp; &amp;&amp;</code> 可折叠成 <code>X&amp;&amp;</code></p></blockquote></li></ul><h3 id=using声明和指示><a href=#using声明和指示 class=headerlink title=using声明和指示></a>using声明和指示</h3><blockquote><p><code>using 声明</code></p></blockquote><blockquote><p>一条 <code>using 声明</code> 语句一次只引入命名空间的一个成员。它使得我们可以清楚知道程序中所引用的到底是哪个名字。如：</p></blockquote><figure class="highlight plaintext"><table><tr><td class=code><pre><span class=line>using namespace_name::name;  </span><br><span class=line>//如  </span><br><span class=line>using std::cin;  </span><br><span class=line>using srd::cout;</span><br></pre></td></tr></table></figure><blockquote><p><code>构造函数的 using 声明</code></p></blockquote><blockquote><p>在 C++11 中，派生类能够重用其直接基类定义的构造函数。</p></blockquote><figure class="highlight plaintext"><table><tr><td class=code><pre><span class=line>class Base  </span><br><span class=line>&#123;  </span><br><span class=line>public:  </span><br><span class=line>    Base() &#123;&#125;;                         //  默认、拷贝、移动构造函数不能被继承和覆盖  </span><br><span class=line>    Base(int a) &#123;&#125;;                    //  被派生类中的构造函数覆盖  </span><br><span class=line>    Base(int a, int b) &#123;&#125;;             //  被派生类中的构造函数继承  </span><br><span class=line>    Base(int a, string b) &#123;&#125;;          //  被派生类中的构造函数继承  </span><br><span class=line>&#125;;  </span><br><span class=line></span><br><span class=line>class Derived: public Base  </span><br><span class=line>&#123;  </span><br><span class=line>public:  </span><br><span class=line>    using Base::Base;         // 声明继承基类中的构造函数，若无此声明是不继承构造函数的  </span><br><span class=line>    Derived(int a) &#123;&#125;;        // 覆盖基类中的构造函数  </span><br><span class=line>&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>如上 using 声明，对于基类的每个构造函数，编译器都生成一个与之对应（形参列表完全相同）的派生类构造函数。生成如下类型构造函数：</p></blockquote><figure class="highlight plaintext"><table><tr><td class=code><pre><span class=line>Derived(parms) : Base(args) &#123; &#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>using 指示</code></p></blockquote><blockquote><p><code>using 指示</code> 使得某个特定命名空间中所有名字都可见，这样我们就无需再为它们添加任何前缀限定符了。如：</p></blockquote><figure class="highlight plaintext"><table><tr><td class=code><pre><span class=line>using namespace_name name;  </span><br><span class=line>//如  </span><br><span class=line>using namespace std；</span><br></pre></td></tr></table></figure><blockquote><p><code>尽量少使用</code>using 指示<code>污染命名空间</code></p></blockquote><blockquote><blockquote><p>一般说来，使用 using 命令比使用 using 编译命令更安全，这是由于它<code>只导入了指定的名称</code>。如果该名称与局部名称发生冲突，编译器将<code>发出指示</code>。using编译命令导入所有的名称，包括可能并不需要的名称。如果与局部名称发生冲突，则<code>局部名称将覆盖名称空间版本</code>，而编译器<code>并不会发出警告</code>。另外，名称空间的开放性意味着名称空间的名称可能分散在多个地方，这使得难以准确知道添加了哪些名称。</p></blockquote></blockquote><blockquote><p><code>using 使用</code></p></blockquote><blockquote><p>尽量少使用 <code>using 指示</code></p></blockquote><figure class="highlight plaintext"><table><tr><td class=code><pre><span class=line>using namespace std;</span><br></pre></td></tr></table></figure><blockquote><p>应该多使用 <code>using 声明</code></p></blockquote><figure class="highlight plaintext"><table><tr><td class=code><pre><span class=line>int x;  </span><br><span class=line>std::cin &gt;&gt; x ;  </span><br><span class=line>std::cout &lt;&lt; x &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><blockquote><p>或者</p></blockquote><figure class="highlight plaintext"><table><tr><td class=code><pre><span class=line>using std::cin;  </span><br><span class=line>using std::cout;  </span><br><span class=line>using std::endl;  </span><br><span class=line>int x;  </span><br><span class=line>cin &gt;&gt; x;  </span><br><span class=line>cout &lt;&lt; x &lt;&lt; endl;</span><br></pre></td></tr></table></figure><h3 id=范围解析运算符><a href=#范围解析运算符 class=headerlink title=":: 范围解析运算符"></a>:: 范围解析运算符</h3><blockquote><p>分类</p></blockquote><figure class="highlight plaintext"><table><tr><td class=code><pre><span class=line>全局作用域符（`::name`）：用于类型名称（类、类成员、成员函数、变量等）前，表示作用域为全局命名空间</span><br><span class=line> 类作用域符（`class::name`）：用于表示指定类型的作用域范围是具体某个类的</span><br><span class=line> 命名空间作用域符（`namespace::name`）:用于表示指定类型的作用域范围是具体某个命名空间的</span><br></pre></td></tr></table></figure><blockquote><p>:: 使用</p></blockquote><figure class="highlight plaintext"><table><tr><td class=code><pre><span class=line>int count = 11;         // 全局（::）的 count  </span><br><span class=line></span><br><span class=line>class A &#123;  </span><br><span class=line>public:  </span><br><span class=line>	static int count;   // 类 A 的 count（A::count）  </span><br><span class=line>&#125;;  </span><br><span class=line>int A::count = 21;  </span><br><span class=line></span><br><span class=line>void fun()  </span><br><span class=line>&#123;  </span><br><span class=line>	int count = 31;     // 初始化局部的 count 为 31  </span><br><span class=line>	count = 32;         // 设置局部的 count 的值为 32  </span><br><span class=line>&#125;  </span><br><span class=line></span><br><span class=line>int main() &#123;  </span><br><span class=line>	::count = 12;       // 测试 1：设置全局的 count 的值为 12  </span><br><span class=line></span><br><span class=line>	A::count = 22;      // 测试 2：设置类 A 的 count 为 22  </span><br><span class=line></span><br><span class=line>	fun();		        // 测试 3  </span><br><span class=line></span><br><span class=line>	return 0;  </span><br><span class=line>&#125;</span><br></pre></td></tr></table></figure><h4 id=-3><a href=#-3 class=headerlink title=""></a></h4><h3 id=四类cast转换><a href=#四类cast转换 class=headerlink title=四类cast转换></a>四类cast转换</h3><ul><li><code>cast_const</code> 常量转换，用于将const变量转为非const,需要注意的是cast_const针对的是指针，引用，this指针</li></ul><figure class="highlight plaintext"><table><tr><td class=code><pre><span class=line>int n = 5;  </span><br><span class=line> int *k1 = const_cast&lt;int*&gt;(&amp;n);  //创建k1指针指向n的地址，如果不加cast_const,会报错，要写成const * k1 = &amp;n;才不会报错  </span><br><span class=line> *k1 = 1;        //cast_const转换之和才可以重新赋值  </span><br><span class=line> int &amp;k2 = const_cast&lt;int&amp;&gt;(n);   //针对引用，引用只是给对象起别名  </span><br><span class=line> k2 = 2;  </span><br><span class=line></span><br><span class=line>int n = 5;  </span><br><span class=line>int k1 = const_cast&lt;int&gt;(n);  //编译出错,只针对指针引用，this指针  </span><br><span class=line>k1 = 1;                       //编译出错</span><br></pre></td></tr></table></figure><ul><li><code>static_cast</code> 第一个作用是代替隐式转换 ，比如：</li></ul><blockquote><p>1、void* 转换为任意类型的指针</p></blockquote><blockquote><p>2、任意类型的指针转换为void*</p></blockquote><blockquote><p>3、编译器允许的跨类型转换,比如char类型转换为int类型，double转int型</p></blockquote><figure class="highlight plaintext"><table><tr><td class=code><pre><span class=line>int n = 10;  </span><br><span class=line>char c = &#x27;a&#x27;;  </span><br><span class=line>void *p = nullptr;  </span><br><span class=line>int *k = static_cast&lt;int*&gt;(p); //把p指针转换为int * 类型的指针  </span><br><span class=line></span><br><span class=line>n = static_cast&lt;int&gt;(c); //n就变成了97，ASCLL码中字符a的位置,    相当于int n = (int)c;    //把char c转换成 int 类型</span><br></pre></td></tr></table></figure><blockquote><p>static_cast第二个作用是做基类与派生类的转换，<code>派生类转换成基类是安全的，基类转换成派生类是不安全的，因为往往子类的内容比父类多，</code></p></blockquote><blockquote><p>static_cast可以将子类转换成父类，但是不提供安全性检查</p></blockquote><blockquote><p>复制代码</p></blockquote><figure class="highlight plaintext"><table><tr><td class=code><pre><span class=line>class A&#123;  </span><br><span class=line>public:  </span><br><span class=line>    void m() &#123;  </span><br><span class=line></span><br><span class=line>    &#125;;  </span><br><span class=line>&#125;;  </span><br><span class=line>class B:public A//普通继承   </span><br><span class=line>&#123;  </span><br><span class=line></span><br><span class=line>&#125;;  </span><br><span class=line>int main() &#123;  </span><br><span class=line>    A* aa;  </span><br><span class=line>    B* bb=static_cast&lt;B*&gt; (aa);//基类指针向下转换为派生类指针,不进行类型检查，不安全  </span><br><span class=line>   //如果字类指针转父类就是安全的   </span><br><span class=line>  system(&quot;pause&quot;);       </span><br><span class=line>    return 0;  </span><br><span class=line>&#125;</span><br></pre></td></tr></table></figure><ul><li><code>dynamic_cast</code></li></ul><blockquote><p>dynamic_cast和static_cast的效果是一样的;在进行下行转换时，dynamic_cast具有类型检查的功能，弥补了static_cast类型不安全的缺陷，比static_cast更安全</p></blockquote><blockquote><p>多<code>用于有虚函数的基类与其派生类之间的转换</code>，特点是进行运行时检测转换类型是否安全，如果转换失败返回nullptr，<code>依赖于RTTI技术</code>，但是有额外的函数开销，所以非必要的时候不使用。</p></blockquote><blockquote><p>复制代码</p></blockquote><figure class="highlight plaintext"><table><tr><td class=code><pre><span class=line>class A&#123;  </span><br><span class=line>public:  </span><br><span class=line>    virtual void m() &#123;  </span><br><span class=line></span><br><span class=line>    &#125;;// C现在是 多态  </span><br><span class=line></span><br><span class=line>&#125;;  </span><br><span class=line>class B:public A   </span><br><span class=line>&#123;  </span><br><span class=line></span><br><span class=line>&#125;;  </span><br><span class=line>int main() &#123;  </span><br><span class=line>    A* aa;  </span><br><span class=line>    B* bb=dynamic_cast&lt;B*&gt; (aa);//基类指针向下转换为派生类指针  </span><br><span class=line>    system(&quot;pause&quot;);  </span><br><span class=line>    return 0;  </span><br><span class=line>&#125;</span><br></pre></td></tr></table></figure><blockquote><p>复制代码</p></blockquote><blockquote><p>RTTI是一种意思是运行时类型信息，它提供了运行时确定对象类型的方法，换句话说，RTTI是一种可以获取变量在运行时的实际指向的机制，使用了typeid()函数</p></blockquote><blockquote><p><img src=https://img2020.cnblogs.com/blog/1468919/202009/1468919-20200906183653388-869154319.png alt=img></p></blockquote><ul><li><code>reinterpret_cast</code></li></ul><blockquote><p>reinterpret代替显示转换，用于转换各种高风险的转换（隐式转换无法转换的）</p></blockquote><blockquote><p>它可以把一个指针转换成一个整数，也可以把一个整数转换成一个指针（先把一个指针转换成一个整数，再把该整数转换成原类型的指针，还可以得到原先的指针值）</p></blockquote><blockquote><p>但是不进行检查，只是进行强制的复制，有安全隐患，一般不用</p></blockquote><blockquote><p>reinterpret_cast是四种强制转换中功能最为强大的，它可以暴力完成两个完全无关类型的指针之间或指针和数之间的互转，比如用char类型指针指向double值。<code>它对原始对象的位模式提供较低层次上的重新解释*（即reinterpret）*，完全复制二进制比特位到目标对象，转换后的值与原始对象无关但比特位一致，前后无精度损失。</code></p></blockquote><blockquote><p>复制代码</p></blockquote><figure class="highlight plaintext"><table><tr><td class=code><pre><span class=line>int main() &#123;  </span><br><span class=line>    double d = 1;  </span><br><span class=line>    char* p = reinterpret_cast&lt;char*&gt;(&amp;d); // 将d以二进制（位模式）方式解释为char，并赋给*p  </span><br><span class=line>    double* q = reinterpret_cast&lt;double*&gt;(p);  </span><br><span class=line>    cout &lt;&lt; *q &lt;&lt; endl; // 1  </span><br><span class=line>    system(&quot;pause&quot;);  </span><br><span class=line>    return 0;  </span><br><span class=line>&#125;</span><br></pre></td></tr></table></figure><h2 id=函数相关><a href=#函数相关 class=headerlink title=函数相关></a>函数相关</h2><h3 id=传值方式（引用，指针）><a href=#传值方式（引用，指针） class=headerlink title=传值方式（引用，指针）></a>传值方式（引用，指针）</h3><h3 id=内联函数和函数的区别><a href=#内联函数和函数的区别 class=headerlink title=内联函数和函数的区别></a>内联函数和函数的区别</h3><blockquote><p><code>参考回答</code></p></blockquote><ol><li>内联函数比普通函数多了关键字<code>inline</code></li><li>内联函数避免了函数调用的<code>开销</code>；普通函数有调用的开销</li><li>普通函数在被调用的时候，需要<code>寻址（函数入口地址）</code>；内联函数不需要寻址。</li><li>内联函数有一定的限制，内联函数体要求<code>代码简单</code>，不能包含复杂的结构控制语句；普通函数没有这个要求。</li></ol><blockquote><p><code>内联函数的作用</code>：内联函数在调用时，是将调用表达式用内联函数体来替换。避免函数调用的开销。</p></blockquote><blockquote><p><code>答案解析</code></p></blockquote><blockquote><p>在使用内联函数时，应注意如下几点：</p></blockquote><ol><li><blockquote><p>在内联函数内不允许用循环语句和开关语句。 如果内联函数有这些语句，则编译将该函数视同普通函数那样产生函数调用代码,递归函数是不能被用来做内联函数的。内联函数只适合于只有1～5行的小函数。对一个含有许多语句的大函数，函数调用和返回的开销相对来说微不足道，所以也没有必要用内联函数实现。</p></blockquote></li><li><blockquote><p>内联函数的定义必须出现在内联函数第一次被调用之前。</p></blockquote></li><li><blockquote><p>inline 内联函数</p></blockquote></li></ol><blockquote><p>特征</p></blockquote><ul><li>相当于把内联函数里面的内容写在调用内联函数处；</li><li>相当于不用执行进入函数的步骤，直接执行函数体；</li><li>相当于宏，却比宏多了类型检查，真正具有函数特性；</li><li>编译器一般不内联包含循环、递归、switch 等复杂操作的内联函数；</li><li>在类声明中定义的函数，除了虚函数的其他函数都会自动隐式地当成内联函数。</li></ul><blockquote><p>使用</p></blockquote><blockquote><p>inline 使用</p></blockquote><figure class="highlight plaintext"><table><tr><td class=code><pre><span class=line>// 声明1（加 inline，建议使用）  </span><br><span class=line>inline int functionName(int first, int second,...);  </span><br><span class=line></span><br><span class=line>// 声明2（不加 inline）  </span><br><span class=line>int functionName(int first, int second,...);  </span><br><span class=line></span><br><span class=line>// 定义  </span><br><span class=line>inline int functionName(int first, int second,...) &#123;/****/&#125;;  </span><br><span class=line></span><br><span class=line>// 类内定义，隐式内联  </span><br><span class=line>class A &#123;  </span><br><span class=line>    int doA() &#123; return 0; &#125;         // 隐式内联  </span><br><span class=line>&#125;  </span><br><span class=line></span><br><span class=line>// 类外定义，需要显式内联  </span><br><span class=line>class A &#123;  </span><br><span class=line>    int doA();  </span><br><span class=line>&#125;  </span><br><span class=line>inline int A::doA() &#123; return 0; &#125;   // 需要显式内联</span><br></pre></td></tr></table></figure><blockquote><p>编译器对 inline 函数的处理步骤</p></blockquote><ol><li>将 inline 函数体复制到 inline 函数调用点处；</li><li>为所用 inline 函数中的局部变量分配内存空间；</li><li>将 inline 函数的的输入参数和返回值映射到调用方法的局部变量空间中；</li><li>如果 inline 函数有多个返回点，将其转变为 inline 函数代码块末尾的分支（使用 GOTO）。</li></ol><blockquote><p>优缺点</p></blockquote><blockquote><p>优点</p></blockquote><ol><li>内联函数同宏函数一样将在被调用处进行代码展开，省去了参数压栈、栈帧开辟与回收，结果返回等，从而提高程序运行速度。</li><li>内联函数相比宏函数来说，在代码展开时，会做安全检查或自动类型转换（同普通函数），而宏定义则不会。</li><li>在类中声明同时定义的成员函数，自动转化为内联函数，因此内联函数可以访问类的成员变量，宏定义则不能。</li><li>内联函数在运行时可调试，而宏定义不可以。</li></ol><blockquote><p>缺点</p></blockquote><ol><li>代码膨胀。内联是以代码膨胀（复制）为代价，消除函数调用带来的开销。如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率的收获会很少。另一方面，每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间。</li><li>inline 函数无法随着函数库升级而升级。inline函数的改变需要重新编译，不像 non-inline 可以直接链接。</li><li>是否内联，程序员不可控。内联函数只是对编译器的建议，是否对函数内联，决定权在于编译器。</li></ol><blockquote><p>虚函数（virtual）可以是内联函数（inline）吗？</p></blockquote><blockquote><blockquote><p>Are inline virtual member functions ever actually inlined?</p></blockquote></blockquote><ul><li>虚函数可以是内联函数，内联是可以修饰虚函数的，但是当虚函数表现多态性的时候不能内联。</li><li>内联是在编译期建议编译器内联，而虚函数的多态性在运行期，编译器无法知道运行期调用哪个代码，因此虚函数表现为多态性时（运行期）不可以内联。</li><li><code>inline virtual</code> 唯一可以内联的时候是：编译器知道所调用的对象是哪个类（如 <code>Base::who()</code>），这只有在编译器具有实际对象而不是对象的指针或引用时才会发生。</li></ul><blockquote><p>虚函数内联使用</p></blockquote><figure class="highlight plaintext"><table><tr><td class=code><pre><span class=line>#include &lt;iostream&gt;    </span><br><span class=line>using namespace std;  </span><br><span class=line>class Base  </span><br><span class=line>&#123;  </span><br><span class=line>public:  </span><br><span class=line>	inline virtual void who()  </span><br><span class=line>	&#123;  </span><br><span class=line>		cout &lt;&lt; &quot;I am Base\\n&quot;;  </span><br><span class=line>	&#125;  </span><br><span class=line>	virtual ~Base() &#123;&#125;  </span><br><span class=line>&#125;;  </span><br><span class=line>class Derived : public Base  </span><br><span class=line>&#123;  </span><br><span class=line>public:  </span><br><span class=line>	inline void who()  // 不写inline时隐式内联  </span><br><span class=line>	&#123;  </span><br><span class=line>		cout &lt;&lt; &quot;I am Derived\\n&quot;;  </span><br><span class=line>	&#125;  </span><br><span class=line>&#125;;  </span><br><span class=line></span><br><span class=line>int main()  </span><br><span class=line>&#123;  </span><br><span class=line>	// 此处的虚函数 who()，是通过类（Base）的具体对象（b）来调用的，编译期间就能确定了，所以它可以是内联的，但最终是否内联取决于编译器。   </span><br><span class=line>	Base b;  </span><br><span class=line>	b.who();  </span><br><span class=line></span><br><span class=line>	// 此处的虚函数是通过指针调用的，呈现多态性，需要在运行时期间才能确定，所以不能为内联。    </span><br><span class=line>	Base *ptr = new Derived();  </span><br><span class=line>	ptr-&gt;who();  </span><br><span class=line></span><br><span class=line>	// 因为Base有虚析构函数（virtual ~Base() &#123;&#125;），所以 delete 时，会先调用派生类（Derived）析构函数，再调用基类（Base）析构函数，防止内存泄漏。  </span><br><span class=line>	delete ptr;  </span><br><span class=line>	ptr = nullptr;  </span><br><span class=line></span><br><span class=line>	system(&quot;pause&quot;);  </span><br><span class=line>	return 0;  </span><br><span class=line>&#125;</span><br></pre></td></tr></table></figure><h3 id=C-传值方式，区别><a href=#C-传值方式，区别 class=headerlink title=C++传值方式，区别></a>C++传值方式，区别</h3><blockquote><p><code>参考回答</code></p></blockquote><blockquote><p>传参方式有这三种：<code>值传递、引用传递、指针传递</code></p></blockquote><ol><li>值传递：形参即使在函数体内值发生变化，也不会影响实参的值；</li><li>引用传递：形参在函数体内值发生变化，会影响实参的值；</li><li>指针传递：在指针指向没有发生改变的前提下，形参在函数体内值发生变化，会影响实参的值</li><li>在传递函数参数时，什么时候该使用指针，什么时候该使用引用呢<ul><li>需要返回函数内局部变量的内存的时候用指针。使用指针传参需要开辟内存，用完要记得释放指针，不然会内存泄漏。而返回局部变量的引用是没有意义的</li><li>对栈空间大小比较敏感（比如递归）的时候使用引用。使用引用传递不需要创建临时变量，开销要更小</li><li>类对象作为参数传递的时候使用引用，这是C++类对象传递的标准方式</li><li>除了必须使用指针的（如二叉树，链表的操作），一般情况下都用引用</li></ul></li></ol><blockquote><p><code>答案解析</code></p></blockquote><blockquote><p>值传递用于对象时，整个对象会拷贝一个副本，这样效率低；而引用传递用于对象时，不发生拷贝行为，只是绑定对象，更高效；指针传递同理，但不如引用传递安全。</p></blockquote><blockquote><p>代码示例</p></blockquote><figure class="highlight c++"><table><tr><td class=code><pre><span class=line><span class=comment>//代码示例  </span></span><br><span class=line><span class=meta>#<span class=keyword>include</span> <span class=string>&lt;iostream&gt;</span>  </span></span><br><span class=line><span class=keyword>using</span> <span class=keyword>namespace</span> std;  </span><br><span class=line></span><br><span class=line><span class=function><span class=type>void</span> <span class=title>testfunc</span><span class=params>(<span class=type>int</span> a, <span class=type>int</span> *b, <span class=type>int</span> &amp;c)</span></span>&#123;<span class=comment>//形参a值发生了改变，但是没有影响实参i的值；但形参*b、c的值发生了改变，影响到了实参*j、k的值  </span></span><br><span class=line>    a += <span class=number>1</span>;  </span><br><span class=line>    (*b) += <span class=number>1</span>;  </span><br><span class=line>    c += <span class=number>1</span>;  </span><br><span class=line>    <span class=built_in>printf</span>(<span class=string>&quot;a= %d, b= %d, c= %d\\n&quot;</span>,a,*b,c);<span class=comment>//a= 2, b= 2, c= 2  </span></span><br><span class=line>&#125;  </span><br><span class=line><span class=function><span class=type>int</span> <span class=title>main</span><span class=params>()</span></span>&#123;  </span><br><span class=line>       <span class=type>int</span> i = <span class=number>1</span>;  </span><br><span class=line>    <span class=type>int</span> a = <span class=number>1</span>;  </span><br><span class=line>    <span class=type>int</span> *j = &amp;a;  </span><br><span class=line>    <span class=type>int</span> k = <span class=number>1</span>;  </span><br><span class=line>    <span class=built_in>testfunc</span>(i, j, k);  </span><br><span class=line>    <span class=built_in>printf</span>(<span class=string>&quot;i= %d, j= %d, k= %d\\n&quot;</span>,i,*j,k);<span class=comment>//i= 1, j= 2, k= 2  </span></span><br><span class=line>    <span class=keyword>return</span> <span class=number>0</span>;  </span><br><span class=line>&#125;</span><br></pre></td></tr></table></figure><h2 id=C-x2F-C><a href=#C-x2F-C class=headerlink title=C&#x2F;C++></a>C&#x2F;C++</h2><h3 id=导入C函数关键字><a href=#导入C函数关键字 class=headerlink title=导入C函数关键字></a>导入C函数关键字</h3><ol><li><code>关键字：</code>在C++中，导入C函数的关键字是<code>extern</code>，表达形式为<code>extern “C”</code>， extern “C”的主要作用就是为了能够正确实现C++代码调用其他C语言代码。加上extern “C”后，会指示编译器这部分代码按<code>C语言</code>的进行编译，而不是C++的。</li><li><code>编译区别：</code>由于C++支持函数重载，因此编译器编译函数的过程中会将函数的<code>参数类型</code>也加到编译后的代码中，而不仅仅是<code>函数名</code>；而C语言并不支持函数重载，因此编译C语言代码的函数时不会带上函数的参数类型，一般只包括<code>函数名</code>。</li></ol><blockquote><p><code>答案解析</code></p></blockquote><figure class="highlight plaintext"><table><tr><td class=code><pre><span class=line>//extern示例 //在C++程序里边声明该函数，会指示编译器这部分代码按C语言的进行编译 extern &quot;C&quot; int strcmp(const char *s1, const char *s2);  //在C++程序里边声明该函数 extern &quot;C&quot;&#123;     #include &lt;string.h&gt;//string.h里边包含了要调用的C函数的声明 &#125;  //两种不同的语言，有着不同的编译规则，比如一个函数fun，可能C语言编译的时候为_fun，而C++则是__fun__</span><br></pre></td></tr></table></figure><h4 id=-4><a href=#-4 class=headerlink title=""></a></h4><h3 id=C-x2F-C-struct区别><a href=#C-x2F-C-struct区别 class=headerlink title="C&#x2F;C++ struct区别"></a>C&#x2F;C++ struct区别</h3><h2 id=程序执行过程><a href=#程序执行过程 class=headerlink title=程序执行过程></a>程序执行过程</h2><h3 id=main执行之前和之后><a href=#main执行之前和之后 class=headerlink title=main执行之前和之后></a>main执行之前和之后</h3><blockquote><p><code>main函数执行之前</code>，主要就是初始化系统相关资源：</p></blockquote><ul><li>设置栈指针</li><li>初始化静态<code>static</code>变量和<code>global</code>全局变量，即<code>.data</code>段的内容</li><li>将未初始化部分的全局变量赋初值：数值型<code>short</code>，<code>int</code>，<code>long</code>等为<code>0</code>，<code>bool</code>为<code>FALSE</code>，指针为<code>NULL</code>等等，即<code>.bss</code>段的内容</li><li>全局对象初始化，在<code>main</code>之前调用构造函数，这是可能会执行前的一些代码</li><li>将main函数的参数<code>argc</code>，<code>argv</code>等传递给<code>main</code>函数，然后才真正运行<code>main</code>函数</li><li>&#96;&#96;&#96;<br><strong>attribute</strong>((constructor))<figure class="highlight plaintext"><table><tr><td class=code><pre><span class=line></span><br><span class=line>&gt; `main函数执行之后`：</span><br><span class=line></span><br><span class=line>*   全局对象的析构函数会在main函数之后执行；</span><br><span class=line>*   可以用 ``atexit`` 注册一个函数，它会在main 之后执行;</span><br><span class=line>*   ```</span><br><span class=line>    __attribute__((destructor))</span><br></pre></td></tr></table></figure></li></ul><h3 id=C-代码到可执行二进制文件的过程><a href=#C-代码到可执行二进制文件的过程 class=headerlink title=C++代码到可执行二进制文件的过程></a>C++代码到可执行二进制文件的过程</h3><blockquote><p><code>参考回答</code></p></blockquote><blockquote><p><code>预编译、编译、汇编、链接</code>。</p></blockquote><blockquote><p><code>答案解析</code></p></blockquote><ol><li><blockquote><p>预编译：这个过程主要的处理操作如下：</p></blockquote><blockquote><p>（1）处理 # 指令，如 #include，判断条件指令，#ifdef</p></blockquote><blockquote><p>（2） 过滤注释</p></blockquote><blockquote><p>（3） 添加行号和文件名标识，处理空行。</p></blockquote></li><li><blockquote><p>编译：这个过程主要的处理操作如下：（<strong>判断代码是否正确</strong>）</p></blockquote><blockquote><p>（1） 词法分析：将源代码的字符序列分割成一系列的记号。</p></blockquote><blockquote><p>（2） 语法分析：对记号进行语法分析，产生语法树。</p></blockquote><blockquote><p>（3） 语义分析：判断表达式是否有意义。</p></blockquote><blockquote><p>（4） 代码优化：</p></blockquote><blockquote><p>（5） 目标代码生成：生成汇编代码。</p></blockquote><blockquote><p>（6） 目标代码优化：</p></blockquote></li><li><blockquote><p>汇编：将汇编代码转变成机器指令。</p></blockquote></li><li><blockquote><p>链接：将不同的源文件产生的目标文件进行链接，从而形成一个可以执行的程序。</p></blockquote><blockquote><p>链接分为静态链接和动态链接。</p></blockquote><blockquote><p>静态链接，是在链接的时候就已经把要调用的函数或者过程链接到了生成的可执行文件中，就算你在去把静态库删除也不会影响可执行程序的执行；生成的静态链接库，Windows下以.lib为后缀，Linux下以.a为后缀。</p></blockquote><blockquote><p>而动态链接，是在链接的时候没有把调用的函数代码链接进去，而是在执行的过程中，再去找要链接的函数，生成的可执行文件中没有函数代码，只包含函数的重定位信息，所以当你删除动态库时，可执行程序就不能运行。生成的动态链接库，Windows下以.dll为后缀，Linux下以.so为后缀。</p></blockquote></li></ol><h3 id=静态变量初始化><a href=#静态变量初始化 class=headerlink title=静态变量初始化></a>静态变量初始化</h3><blockquote><p><code>参考回答</code></p></blockquote><blockquote><p>c++规定：全局或静态对象当且仅当首次用到时才进行初始化</p></blockquote><blockquote><p><code>答案解析</code></p></blockquote><ol><li><blockquote><p><code>作用域</code>：C++里作用域可分为6种：全局，局部，类，语句，命名空间和文件作用域。</p></blockquote><blockquote><p>静态全局变量 ：全局作用域+文件作用域，所以无法在其他文件中使用。</p></blockquote><blockquote><p>静态局部变量 ：局部作用域</p></blockquote><blockquote><p>类静态成员变量：类作用域。</p></blockquote></li><li><blockquote><p><code>所在空间</code>：都在全局区&#x2F;静态存储区。因为静态变量都在静态存储区，所以下次调用函数的时候还是能取到原来的值。</p></blockquote></li><li><blockquote><p><code>生命周期</code>：静态全局变量、静态局部变量都在静态存储区，直到程序结束才会回收内存。类静态成员变量在静态存储区，当超出类作用域时回收内存。</p></blockquote></li><li><blockquote><p>new和malloc的区别</p></blockquote></li></ol><blockquote><p><code>参考回答</code></p></blockquote><ol><li>new是操作符，而malloc是函数。</li><li>new在调用的时候先分配内存，在调用构造函数，释放的时候调用析构函数；而malloc没有构造函数和析构函数。</li><li>malloc需要给定申请内存的大小，返回的指针需要强转；new会调用构造函数，不用指定内存的大小，返回指针不用强转。</li><li>new可以被重载；malloc不行</li><li>new分配内存更直接和安全。</li><li>new发生错误抛出异常，malloc返回null</li></ol><blockquote><p><code>答案解析</code></p></blockquote><blockquote><p><code>malloc底层实现：</code>当开辟的空间小于 128K 时，调用 brk（）函数；当开辟的空间大于 128K 时，调用mmap（）。malloc采用的是内存池的管理方式，以减少内存碎片。先申请大块内存作为堆区，然后将堆区分为多个内存块。当用户申请内存时，直接从堆区分配一块合适的空闲快。采用隐式链表将所有空闲块，每一个空闲块记录了一个未分配的、连续的内存地址。</p></blockquote><blockquote><p><code>new底层实现：</code>关键字new在调用构造函数的时候实际上进行了如下的几个步骤：</p></blockquote><ol><li><blockquote><p>创建一个新的对象</p></blockquote></li><li><blockquote><p>将构造函数的作用域赋值给这个新的对象（因此this指向了这个新的对象）</p></blockquote></li><li><blockquote><p>执行构造函数中的代码（为这个新对象添加属性）</p></blockquote></li><li><blockquote><p>返回新对象</p></blockquote></li></ol><h2 id=STL><a href=#STL class=headerlink title=STL></a>STL</h2><h3 id=什么是STL？><a href=#什么是STL？ class=headerlink title=什么是STL？></a>什么是STL？</h3><blockquote><p>C++ STL从广义来讲包括了三类：算法，容器和迭代器。</p></blockquote><ul><li><blockquote><p>算法包括排序，复制等常用算法，以及不同容器特定的算法。</p></blockquote></li><li><blockquote><p>容器就是数据的存放形式，包括序列式容器和关联式容器，序列式容器就是list，vector等，关联式容器就是set，map等。</p></blockquote></li><li><blockquote><p>迭代器就是在不暴露容器内部结构的情况下对容器的遍历。</p></blockquote></li></ul><h3 id=STL-索引><a href=#STL-索引 class=headerlink title="STL 索引"></a>STL 索引</h3><blockquote><p>STL 方法含义索引</p></blockquote><h3 id=STL-容器><a href=#STL-容器 class=headerlink title="STL 容器"></a>STL 容器</h3><p>容器 底层数据结构 时间复杂度 有无序 可不可重复 其他</p><hr><p>array 数组 随机读改 O(1)，插入O（n） 无序 可重复 支持随机访问<br>vector 数组 随机读改、尾部插入、尾部删除 O(1) 头部插入、头部删除 O(n) 无序 可重复 支持随机访问<br>deque 双端数组 头尾插入、头尾删除 O(1) 无序 可重复 一个中央控制器 + 多个缓冲区，支持首尾快速增删，支持随机访问<br>forward_list 单向链表 插入、删除 O(1) 无序 可重复 不支持随机访问<br>list 双向链表 插入、删除 O(1) 无序 可重复 不支持随机访问<br>stack deque &#x2F; list 顶部插入、顶部删除 O(1) 无序 可重复 deque 或 list 封闭头端开口，不用 vector 的原因应该是容量大小有限制，扩容耗时<br>queue deque &#x2F; list 尾部插入、头部删除 O(1) 无序 可重复 deque 或 list 封闭头端开口，不用 vector 的原因应该是容量大小有限制，扩容耗时<br>priority_queue vector + max-heap 插入、删除 O(log2n) 有序 可重复 vector容器+heap处理规则<br>set 红黑树 插入、删除、查找 O(log2n) 有序 不可重复<br>multiset 红黑树 插入、删除、查找 O(log2n) 有序 可重复<br>map 红黑树 插入、删除、查找 O(log2n) 有序 不可重复<br>multimap 红黑树 插入、删除、查找 O(log2n) 有序 可重复<br>unordered_set 哈希表 插入、删除、查找 O(1) 最差 O(n) 无序 不可重复<br>unordered_multiset 哈希表 插入、删除、查找 O(1) 最差 O(n) 无序 可重复<br>unordered_map 哈希表 插入、删除、查找 O(1) 最差 O(n) 无序 不可重复<br>unordered_multimap 哈希表 插入、删除、查找 O(1) 最差 O(n) 无序 可重复</p><ul><li><code>deque内部工作原理:</code></li></ul><blockquote><p>deque内部有个<code>中控器</code>，维护每段缓冲区中的内容，缓冲区中存放真实数据</p></blockquote><blockquote><p>中控器维护的是每个缓冲区的地址，使得使用deque时像一片连续的内存空间</p></blockquote><blockquote><p><img src=/Users/apple/Desktop/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%B5%84%E6%96%99/C++/C++%E6%8F%90%E9%AB%98/%E8%AE%B2%E4%B9%89/assets/clip_image002-1547547896341.jpg alt=clip_image002-1547547896341></p></blockquote><ul><li>deque容器的迭代器也是支持随机访问的</li></ul><h3 id=STL-算法><a href=#STL-算法 class=headerlink title="STL 算法"></a>STL 算法</h3><p>算法 底层算法 时间复杂度 可不可重复</p><hr><p>find 顺序查找 O(n) 可重复<br>sort 内省排序 O(n*log2n) 可重复</p><h2 id=数据结构及其算法><a href=#数据结构及其算法 class=headerlink title=数据结构及其算法></a>数据结构及其算法</h2><ul><li><h3 id=选择排序（每次选取最大的元素）><a href=#选择排序（每次选取最大的元素） class=headerlink title=选择排序（每次选取最大的元素）></a>选择排序（每次选取最大的元素）</h3><figure class="highlight c++"><table><tr><td class=code><pre><span class=line><span class=meta>#<span class=keyword>include</span> <span class=string>&lt;iostream&gt;</span></span></span><br><span class=line><span class=meta>#<span class=keyword>include</span> <span class=string>&lt;vector&gt;</span></span></span><br><span class=line><span class=keyword>using</span> <span class=keyword>namespace</span> std;</span><br><span class=line></span><br><span class=line><span class=function><span class=type>void</span> <span class=title>selectsort</span><span class=params>(vector&lt;<span class=type>int</span>&gt; &amp;s)</span></span>&#123;  </span><br><span class=line>    <span class=keyword>for</span>(<span class=type>int</span> i = <span class=number>0</span>; i &lt; s.<span class=built_in>size</span>(); i++)&#123;</span><br><span class=line>        <span class=keyword>for</span>(<span class=type>int</span> j = i + <span class=number>1</span>; j &lt; s.<span class=built_in>size</span>(); j++)&#123; <span class=comment>//从i的后一个位置开始搜索</span></span><br><span class=line>            <span class=keyword>if</span>(s[i] &gt; s[j]) <span class=built_in>swap</span>(s[i],s[j]); <span class=comment>//如果遇到比i位置小的元素，则交换</span></span><br><span class=line>        &#125;   </span><br><span class=line>    &#125;</span><br><span class=line>&#125; <span class=comment>//选择排序的思想是，每次选取最大的元素，放到前面（或者后面）</span></span><br><span class=line></span><br><span class=line><span class=function><span class=type>int</span> <span class=title>main</span><span class=params>()</span></span>&#123;</span><br><span class=line>    vector&lt;<span class=type>int</span>&gt; s = &#123;<span class=number>6</span>,<span class=number>7</span>,<span class=number>4</span>,<span class=number>2</span>,<span class=number>8</span>,<span class=number>1</span>,<span class=number>0</span>,<span class=number>9</span>,<span class=number>11</span>,<span class=number>-1</span>&#125;;</span><br><span class=line>    <span class=built_in>selectsort</span>(s);</span><br><span class=line>    <span class=keyword>for</span>(<span class=type>int</span> i = <span class=number>0</span>; i &lt; s.<span class=built_in>size</span>(); i++)&#123;</span><br><span class=line>        cout &lt;&lt; s[i] &lt;&lt; <span class=string>&quot;    &quot;</span>;</span><br><span class=line>    &#125;</span><br><span class=line>    cout &lt;&lt;endl;</span><br><span class=line>&#125;</span><br></pre></td></tr></table></figure><h3 id=插入排序><a href=#插入排序 class=headerlink title=插入排序></a>插入排序</h3></li></ul><h2 id=操作系统相关><a href=#操作系统相关 class=headerlink title=操作系统相关></a>操作系统相关</h2><h3 id=进程、线程和协程的区别和联系><a href=#进程、线程和协程的区别和联系 class=headerlink title=进程、线程和协程的区别和联系></a>进程、线程和协程的区别和联系</h3><table><thead><tr><th align=left></th><th align=left>进程</th><th align=left>线程</th><th align=left>协程</th></tr></thead><tbody><tr><td align=left>定义</td><td align=left>资源分配和拥有的基本单位</td><td align=left>程序执行的基本单位</td><td align=left>用户态的轻量级线程，线程内部调度的基本单位</td></tr><tr><td align=left>切换情况</td><td align=left>进程CPU环境(栈、寄存器、页表和文件句柄等)的保存以及新调度的进程CPU环境的设置</td><td align=left>保存和设置程序计数器、少量寄存器和栈的内容</td><td align=left>先将寄存器上下文和栈保存，等切换回来的时候再进行恢复</td></tr><tr><td align=left>切换者</td><td align=left>操作系统</td><td align=left>操作系统</td><td align=left>用户</td></tr><tr><td align=left>切换过程</td><td align=left>用户态-&gt;内核态-&gt;用户态</td><td align=left>用户态-&gt;内核态-&gt;用户态</td><td align=left>用户态(没有陷入内核)</td></tr><tr><td align=left>调用栈</td><td align=left>内核栈</td><td align=left>内核栈</td><td align=left>用户栈</td></tr><tr><td align=left>拥有资源</td><td align=left>CPU资源、内存资源、文件资源和句柄等</td><td align=left>程序计数器、寄存器、栈和状态字</td><td align=left>拥有自己的寄存器上下文和栈</td></tr><tr><td align=left>并发性</td><td align=left>不同进程之间切换实现并发，各自占有CPU实现并行</td><td align=left>一个进程内部的多个线程并发执行</td><td align=left>同一时间只能执行一个协程，而其他协程处于休眠状态，适合对任务进行分时处理</td></tr><tr><td align=left>系统开销</td><td align=left>切换虚拟地址空间，切换内核栈和硬件上下文，CPU高速缓存失效、页表切换，开销很大</td><td align=left>切换时只需保存和设置少量寄存器内容，因此开销很小</td><td align=left>直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快</td></tr><tr><td align=left>通信方面</td><td align=left>进程间通信需要借助操作系统</td><td align=left>线程间可以直接读写进程数据段(如全局变量)来进行通信</td><td align=left>共享内存、消息队列</td></tr></tbody></table><p>1、进程是资源调度的基本单位，运行一个可执行程序会创建一个或多个进程，进程就是运行起来的可执行程序</p><p>2、线程是程序执行的基本单位，是轻量级的进程。每个进程中都有唯一的主线程，且只能有一个，主线程和进程是相互依存的关系，主线程结束进程也会结束。多提一句：协程是用户态的轻量级线程，线程内部调度的基本单位</p><h3 id=一个进程可以创建多少线程，和什么有关><a href=#一个进程可以创建多少线程，和什么有关 class=headerlink title=一个进程可以创建多少线程，和什么有关></a>一个进程可以创建多少线程，和什么有关</h3><p>理论上，一个进程可用虚拟空间是2G，默认情况下，线程的栈的大小是1MB，所以理论上最多只能创建2048个线程。如果要创建多于2048的话，必须修改编译器的设置。</p><p>因此，一个进程可以创建的线程数由可用虚拟空间和线程的栈的大小共同决定，只要虚拟空间足够，那么新线程的建立就会成功。如果需要创建超过2K以上的线程，减小你线程栈的大小就可以实现了，虽然在一般情况下，你不需要那么多的线程。过多的线程将会导致大量的时间浪费在线程切换上，给程序运行效率带来负面影响。</p><h3 id=外中断和异常有什么区别？><a href=#外中断和异常有什么区别？ class=headerlink title=外中断和异常有什么区别？></a>外中断和异常有什么区别？</h3><p>外中断是指由 CPU 执行指令以外的事件引起，如 I&#x2F;O 完成中断，表示设备输入&#x2F;输出处理已经完成，处理器能够发送下一个输入&#x2F;输出请求。此外还有时钟中断、控制台中断等。</p><p>而异常时由 CPU 执行指令的内部事件引起，如非法操作码、地址越界、算术溢出等。</p><h3 id=进程间通信方式><a href=#进程间通信方式 class=headerlink title=进程间通信方式></a>进程间通信方式</h3><ul><li><p>进程之间的通信方式以及优缺点</p><ul><li>管道（PIPE）<ul><li>有名管道：一种半双工的通信方式，它允许无亲缘关系进程间的通信<ul><li>优点：可以实现任意关系的进程间的通信</li><li>缺点：<ol><li>长期存于系统中，使用不当容易出错</li><li>缓冲区有限</li></ol></li></ul></li><li>无名管道：一种半双工的通信方式，只能在具有亲缘关系的进程间使用（父子进程）<ul><li>优点：简单方便</li><li>缺点：<ol><li>局限于单向通信</li><li>只能创建在它的进程以及其有亲缘关系的进程之间</li><li>缓冲区有限</li></ol></li></ul></li></ul></li><li>信号量（Semaphore）：一个计数器，可以用来控制多个线程对共享资源的访问<ul><li>优点：可以同步进程</li><li>缺点：信号量有限</li></ul></li><li>信号（Signal）：一种比较复杂的通信方式，用于通知接收进程某个事件已经发生</li><li>消息队列（Message Queue）：是消息的链表，存放在内核中并由消息队列标识符标识<ul><li>优点：可以实现任意进程间的通信，并通过系统调用函数来实现消息发送和接收之间的同步，无需考虑同步问题，方便</li><li>缺点：信息的复制需要额外消耗 CPU 的时间，不适宜于信息量大或操作频繁的场合</li></ul></li><li>共享内存（Shared Memory）：映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问<ul><li>优点：无须复制，快捷，信息量大</li><li>缺点：<ol><li>通信是通过将共享空间缓冲区直接附加到进程的虚拟地址空间中来实现的，因此进程间的读写操作的同步问题</li><li>利用内存缓冲区直接交换信息，内存的实体存在于计算机中，只能同一个计算机系统中的诸多进程共享，不方便网络通信</li></ol></li></ul></li><li>套接字（Socket）：可用于不同计算机间的进程通信<ul><li>优点：<ol><li>传输数据为字节级，传输数据可自定义，数据量小效率高</li><li>传输数据时间短，性能高</li><li>适合于客户端和服务器端之间信息实时交互</li><li>可以加密,数据安全性强</li></ol></li><li>缺点：需对传输的数据进行解析，转化成应用级的数据。</li></ul></li></ul><h3 id=线程之间的通信方式><a href=#线程之间的通信方式 class=headerlink title=线程之间的通信方式></a>线程之间的通信方式</h3><ul><li>锁机制：包括互斥锁&#x2F;量（mutex）、读写锁（reader-writer lock）、自旋锁（spin lock）、条件变量（condition）<ul><li>互斥锁&#x2F;量（mutex）：提供了以排他方式防止数据结构被并发修改的方法。</li><li>读写锁（reader-writer lock）：允许多个线程同时读共享数据，而对写操作是互斥的。</li><li>自旋锁（spin lock）与互斥锁类似，都是为了保护共享资源。互斥锁是当资源被占用，申请者进入睡眠状态；而自旋锁则循环检测保持者是否已经释放锁。</li><li>条件变量（condition）：可以以原子的方式阻塞进程，直到某个特定条件为真为止。对条件的测试是在互斥锁的保护下进行的。条件变量始终与互斥锁一起使用。</li></ul></li><li>信号量机制(Semaphore)<ul><li>无名线程信号量</li><li>命名线程信号量</li></ul></li><li>信号机制(Signal)：类似进程间的信号处理</li><li>屏障（barrier）：屏障允许每个线程等待，直到所有的合作线程都达到某一点，然后从该点继续执行。</li></ul><p>线程间的通信目的主要是用于线程同步，所以线程没有像进程通信中的用于数据交换的通信机制</p><blockquote><p>进程之间的通信方式以及优缺点来源于：<a target=_blank rel=noopener href=http://blog.csdn.net/wujiafei_njgcxy/article/details/77098977>进程线程面试题总结</a></p></blockquote><h4 id=进程之间私有和共享的资源><a href=#进程之间私有和共享的资源 class=headerlink title=进程之间私有和共享的资源></a>进程之间私有和共享的资源</h4><ul><li>私有：地址空间、堆、全局变量、栈、寄存器</li><li>共享：代码段，公共数据，进程目录，进程 ID</li></ul><h4 id=线程之间私有和共享的资源><a href=#线程之间私有和共享的资源 class=headerlink title=线程之间私有和共享的资源></a>线程之间私有和共享的资源</h4><ul><li><p>私有：线程栈，寄存器，程序计数器</p></li><li><p>共享：堆，地址空间，全局变量，静态变量</p></li></ul></li></ul><h3 id=局部性原理你知道吗？主要有哪两大局部性原理？各自是什么？><a href=#局部性原理你知道吗？主要有哪两大局部性原理？各自是什么？ class=headerlink title=局部性原理你知道吗？主要有哪两大局部性原理？各自是什么？></a>局部性原理你知道吗？主要有哪两大局部性原理？各自是什么？</h3><p>主要分为<strong>时间局部性和空间局部性</strong>。</p><p>时间局部性:如果执行了程序中的某条指令，那么不久后这条指令很有可能再次执行;如果某个数据被访问过，不久之后该数据很可能再次被访问。(因为程序中存在大量的循环) 空间局部性:一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也很有可能被访问。(因为很多数据在内存中都是连续存放的，并且程序的指令也是顺序地在内存中存放的)</p><h3 id=介绍一下几种典型的锁？><a href=#介绍一下几种典型的锁？ class=headerlink title=介绍一下几种典型的锁？></a><a target=_blank rel=noopener href="https://interviewguide.cn/#/Doc/Knowledge/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F?id=24%E3%80%81%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B%E5%87%A0%E7%A7%8D%E5%85%B8%E5%9E%8B%E7%9A%84%E9%94%81%EF%BC%9F">介绍一下几种典型的锁？</a></h3><h5 id=读写锁><a href=#读写锁 class=headerlink title=读写锁></a><a target=_blank rel=noopener href="https://interviewguide.cn/#/Doc/Knowledge/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F?id=%E8%AF%BB%E5%86%99%E9%94%81">读写锁</a></h5><ul><li>多个读者可以同时进行读</li><li>写者必须互斥（只允许一个写者写，也不能读者写者同时进行）</li><li>写者优先于读者（一旦有写者，则后续读者必须等待，唤醒时优先考虑写者）</li></ul><h5 id=互斥锁><a href=#互斥锁 class=headerlink title=互斥锁></a><a target=_blank rel=noopener href="https://interviewguide.cn/#/Doc/Knowledge/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F?id=%E4%BA%92%E6%96%A5%E9%94%81">互斥锁</a></h5><p>一次只能一个线程拥有互斥锁，其他线程只有等待</p><p>互斥锁是在抢锁失败的情况下主动放弃CPU进入睡眠状态直到锁的状态改变时再唤醒，而操作系统负责线程调度，为了实现锁的状态发生改变时唤醒阻塞的线程或者进程，需要把锁交给操作系统管理，所以互斥锁在加锁操作时涉及上下文的切换。互斥锁实际的效率还是可以让人接受的，加锁的时间大概100ns左右，而实际上互斥锁的一种可能的实现是先自旋一段时间，当自旋的时间超过阀值之后再将线程投入睡眠中，因此在并发运算中使用互斥锁（每次占用锁的时间很短）的效果可能不亚于使用自旋锁</p><h5 id=条件变量><a href=#条件变量 class=headerlink title=条件变量></a><a target=_blank rel=noopener href="https://interviewguide.cn/#/Doc/Knowledge/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F?id=%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F">条件变量</a></h5><p>互斥锁一个明显的缺点是他只有两种状态：锁定和非锁定。而条件变量通过允许线程阻塞和等待另一个线程发送信号的方法弥补了互斥锁的不足，他常和互斥锁一起使用，以免出现竞态条件。当条件不满足时，线程往往解开相应的互斥锁并阻塞线程然后等待条件发生变化。一旦其他的某个线程改变了条件变量，他将通知相应的条件变量唤醒一个或多个正被此条件变量阻塞的线程。总的来说<strong>互斥锁是线程间互斥的机制，条件变量则是同步机制。</strong></p><h5 id=自旋锁><a href=#自旋锁 class=headerlink title=自旋锁></a><a target=_blank rel=noopener href="https://interviewguide.cn/#/Doc/Knowledge/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F?id=%E8%87%AA%E6%97%8B%E9%94%81">自旋锁</a></h5><p>如果进线程无法取得锁，进线程不会立刻放弃CPU时间片，而是一直循环尝试获取锁，直到获取为止。如果别的线程长时期占有锁，那么自旋就是在浪费CPU做无用功，但是自旋锁一般应用于加锁时间很短的场景，这个时候效率比较高。</p><h2 id=计算机网络><a href=#计算机网络 class=headerlink title=计算机网络></a>计算机网络</h2><h4 id=OSI-的七层模型分别是？各自的功能是什么？><a href=#OSI-的七层模型分别是？各自的功能是什么？ class=headerlink title="OSI 的七层模型分别是？各自的功能是什么？"></a><a target=_blank rel=noopener href="https://interviewguide.cn/#/Doc/Knowledge/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C?id=1%E3%80%81osi-%E7%9A%84%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B%E5%88%86%E5%88%AB%E6%98%AF%EF%BC%9F%E5%90%84%E8%87%AA%E7%9A%84%E5%8A%9F%E8%83%BD%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F">OSI 的七层模型分别是？各自的功能是什么？</a></h4><h5 id=简要概括><a href=#简要概括 class=headerlink title=简要概括></a><a target=_blank rel=noopener href="https://interviewguide.cn/#/Doc/Knowledge/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C?id=%E7%AE%80%E8%A6%81%E6%A6%82%E6%8B%AC">简要概括</a></h5><ul><li>物理层：底层数据传输，如网线；网卡标准。</li><li>数据链路层：定义数据的基本格式，如何传输，如何标识；如网卡MAC地址。</li><li>网络层：定义IP编址，定义路由功能；如不同设备的数据转发。</li><li>传输层：端到端传输数据的基本功能；如 TCP、UDP。</li><li>会话层：控制应用程序之间会话能力；如不同软件数据分发给不同软件。</li><li>表示层：数据格式标识，基本压缩加密功能。</li><li>应用层：各种应用软件，包括 Web 应用。</li></ul><p><img src=https://cdn.jsdelivr.net/gh/forthespada/mediaImage2@2.6/202104/net-52-1.png alt=img></p><h3 id=TCP><a href=#TCP class=headerlink title=TCP></a>TCP</h3><ul><li>TCP（Transmission Control Protocol，传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议，其传输的单位是报文段。</li></ul><p>特征：</p><ul><li>面向连接</li><li>只能点对点（一对一）通信</li><li>可靠交互</li><li>全双工通信</li><li>面向字节流</li></ul><p>TCP 如何保证可靠传输：</p><ul><li>确认和超时重传</li><li>数据合理分片和排序</li><li>流量控制</li><li>拥塞控制</li><li>数据校验</li></ul><h3 id=UDP><a href=#UDP class=headerlink title=UDP></a>UDP</h3><ul><li>UDP（User Datagram Protocol，用户数据报协议）是 OSI（Open System Interconnection 开放式系统互联） 参考模型中一种无连接的传输层协议，提供面向事务的简单不可靠信息传送服务，其传输的单位是用户数据报。</li></ul><p>特征：</p><ul><li>无连接</li><li>尽最大努力交付</li><li>面向报文</li><li>没有拥塞控制</li><li>支持一对一、一对多、多对一、多对多的交互通信</li><li>首部开销小</li></ul><h3 id=TCP-与-UDP-的区别><a href=#TCP-与-UDP-的区别 class=headerlink title="TCP 与 UDP 的区别"></a>TCP 与 UDP 的区别</h3><ol><li>TCP 面向连接，UDP 是无连接的；</li><li>TCP 提供可靠的服务，也就是说，通过 TCP 连接传送的数据，无差错，不丢失，不重复，且按序到达；UDP 尽最大努力交付，即不保证可靠交付</li><li>TCP 的逻辑通信信道是全双工的可靠信道；UDP 则是不可靠信道</li><li>每一条 TCP 连接只能是点到点的；UDP 支持一对一，一对多，多对一和多对多的交互通信</li><li>TCP 面向字节流（可能出现黏包问题），实际上是 TCP 把数据看成一连串无结构的字节流；UDP 是面向报文的（不会出现黏包问题）</li><li>UDP 没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如 IP 电话，实时视频会议等）</li><li>TCP 首部开销20字节；UDP 的首部开销小，只有 8 个字节</li></ol><h3 id=TCP-拥塞控制><a href=#TCP-拥塞控制 class=headerlink title="TCP 拥塞控制"></a>TCP 拥塞控制</h3><h5 id=概念><a href=#概念 class=headerlink title=概念></a>概念</h5><p>拥塞控制就是防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载。</p><h5 id=方法><a href=#方法 class=headerlink title=方法></a>方法</h5><ul><li>慢开始( slow-start )</li><li>拥塞避免( congestion avoidance )</li><li>快重传( fast retransmit )</li><li>快恢复( fast recovery )</li></ul><p>TCP的拥塞控制图</p><p><a target=_blank rel=noopener href=https://camo.githubusercontent.com/56f29286817e27ee1efe2254a6a22c78029342fc95a72fc3135b056f8a2231f9/68747470733a2f2f67697465652e636f6d2f6875696875742f696e746572766965772f7261772f6d61737465722f696d616765732f54435025453625384225413525453525413125394525453725414125393725453525384625413363776e642545352539432541382545362538422541352545352541312539452545362538452541372545352538382542362545362539372542362545372539412538342545352538462539382545352538432539362545362538332538352545352538362542352e706e67><img src=https://camo.githubusercontent.com/56f29286817e27ee1efe2254a6a22c78029342fc95a72fc3135b056f8a2231f9/68747470733a2f2f67697465652e636f6d2f6875696875742f696e746572766965772f7261772f6d61737465722f696d616765732f54435025453625384225413525453525413125394525453725414125393725453525384625413363776e642545352539432541382545362538422541352545352541312539452545362538452541372545352538382542362545362539372542362545372539412538342545352538462539382545352538432539362545362538332538352545352538362542352e706e67 alt=img></a></p><h3 id=TCP-建立连接全过程解释><a href=#TCP-建立连接全过程解释 class=headerlink title="TCP 建立连接全过程解释"></a>TCP 建立连接全过程解释</h3><p><a target=_blank rel=noopener href=https://camo.githubusercontent.com/acd13227ae0680f7d15aeec2189c61128115ff8f57c593a93b7af9db4282adef/687474703a2f2f696d616765732e636e626c6f67732e636f6d2f636e626c6f67735f636f6d2f736b796e65742f3230313031322f3230313031323132323135373436373235382e706e67><img src=https://camo.githubusercontent.com/acd13227ae0680f7d15aeec2189c61128115ff8f57c593a93b7af9db4282adef/687474703a2f2f696d616765732e636e626c6f67732e636f6d2f636e626c6f67735f636f6d2f736b796e65742f3230313031322f3230313031323132323135373436373235382e706e67 alt="socket 中发送的 TCP 三次握手"></a></p><ol><li>客户端发送 SYN 给服务器，说明客户端请求建立连接；</li><li>服务端收到客户端发的 SYN，并回复 SYN+ACK 给客户端（同意建立连接）；</li><li>客户端收到服务端的 SYN+ACK 后，回复 ACK 给服务端（表示客户端收到了服务端发的同意报文）；</li><li>服务端收到客户端的 ACK，连接已建立，可以数据传输。</li></ol><h5 id=TCP-为什么要进行三次握手？><a href=#TCP-为什么要进行三次握手？ class=headerlink title="TCP 为什么要进行三次握手？"></a>TCP 为什么要进行三次握手？</h5><p>【答案一】因为信道不可靠，而 TCP 想在不可靠信道上建立可靠地传输，那么三次通信是理论上的最小值。（而 UDP 则不需建立可靠传输，因此 UDP 不需要三次握手。）</p><blockquote><p><a target=_blank rel=noopener href=https://groups.google.com/forum/#!msg/pongba/kF6O7-MFxM0/5S7zIJ4yqKUJ>Google Groups . TCP 建立连接为什么是三次握手？{技术}{网络通信}</a></p></blockquote><p>【答案二】因为双方都需要确认对方收到了自己发送的序列号，确认过程最少要进行三次通信。</p><blockquote><p><a target=_blank rel=noopener href=https://www.zhihu.com/question/24853633/answer/115173386>知乎 . TCP 为什么是三次握手，而不是两次或四次？</a></p></blockquote><p>【答案三】为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。</p><blockquote><p><a target=_blank rel=noopener href=https://gitee.com/huihut/interview/raw/master/images/TCP-transport-connection-management.png>《计算机网络（第 7 版）-谢希仁》</a></p></blockquote><h4 id=TCP-四次挥手释放连接><a href=#TCP-四次挥手释放连接 class=headerlink title="TCP 四次挥手释放连接"></a>TCP 四次挥手释放连接</h4><p><a target=_blank rel=noopener href=https://camo.githubusercontent.com/209302157a20fd1f442f30199165650023d4c0815c31c9924df1ff2116ea9f1f/68747470733a2f2f67697465652e636f6d2f6875696875742f696e746572766965772f7261772f6d61737465722f696d616765732f5443502545352539422539422545362541432541312545362538432541352545362538392538422545392538372538412545362539342542452545382542462539452545362538452541352e706e67><img src=https://camo.githubusercontent.com/209302157a20fd1f442f30199165650023d4c0815c31c9924df1ff2116ea9f1f/68747470733a2f2f67697465652e636f6d2f6875696875742f696e746572766965772f7261772f6d61737465722f696d616765732f5443502545352539422539422545362541432541312545362538432541352545362538392538422545392538372538412545362539342542452545382542462539452545362538452541352e706e67 alt="UDP 报文"></a></p><p>【TCP 释放连接全过程解释】</p><ol><li>客户端发送 FIN 给服务器，说明客户端不必发送数据给服务器了（请求释放从客户端到服务器的连接）；</li><li>服务器接收到客户端发的 FIN，并回复 ACK 给客户端（同意释放从客户端到服务器的连接）；</li><li>客户端收到服务端回复的 ACK，此时从客户端到服务器的连接已释放（但服务端到客户端的连接还未释放，并且客户端还可以接收数据）；</li><li>服务端继续发送之前没发完的数据给客户端；</li><li>服务端发送 FIN+ACK 给客户端，说明服务端发送完了数据（请求释放从服务端到客户端的连接，就算没收到客户端的回复，过段时间也会自动释放）；</li><li>客户端收到服务端的 FIN+ACK，并回复 ACK 给服务端（同意释放从服务端到客户端的连接）；</li><li>服务端收到客户端的 ACK 后，释放从服务端到客户端的连接。</li></ol><h3 id=TCP-为什么要进行四次挥手？><a href=#TCP-为什么要进行四次挥手？ class=headerlink title="TCP 为什么要进行四次挥手？"></a>TCP 为什么要进行四次挥手？</h3><p>【问题一】TCP 为什么要进行四次挥手？ &#x2F; 为什么 TCP 建立连接需要三次，而释放连接则需要四次？</p><p>【答案一】因为 TCP 是全双工模式，客户端请求关闭连接后，客户端向服务端的连接关闭（一二次挥手），服务端继续传输之前没传完的数据给客户端（数据传输），服务端向客户端的连接关闭（三四次挥手）。所以 TCP 释放连接时服务器的 ACK 和 FIN 是分开发送的（中间隔着数据传输），而 TCP 建立连接时服务器的 ACK 和 SYN 是一起发送的（第二次握手），所以 TCP 建立连接需要三次，而释放连接则需要四次。</p><p>【问题二】为什么 TCP 连接时可以 ACK 和 SYN 一起发送，而释放时则 ACK 和 FIN 分开发送呢？（ACK 和 FIN 分开是指第二次和第三次挥手）</p><p>【答案二】因为客户端请求释放时，服务器可能还有数据需要传输给客户端，因此服务端要先响应客户端 FIN 请求（服务端发送 ACK），然后数据传输，传输完成后，服务端再提出 FIN 请求（服务端发送 FIN）；而连接时则没有中间的数据传输，因此连接时可以 ACK 和 SYN 一起发送。</p><p>【问题三】为什么客户端释放最后需要 TIME-WAIT 等待 2MSL 呢？</p><p>【答案三】</p><ol><li>为了保证客户端发送的最后一个 ACK 报文能够到达服务端。若未成功到达，则服务端超时重传 FIN+ACK 报文段，客户端再重传 ACK，并重新计时。</li><li>防止已失效的连接请求报文段出现在本连接中。TIME-WAIT 持续 2MSL 可使本连接持续的时间内所产生的所有报文段都从网络中消失，这样可使下次连接中不会出现旧的连接报文段。</li></ol><h4 id=HTTPS和HTTP的区别><a href=#HTTPS和HTTP的区别 class=headerlink title=HTTPS和HTTP的区别></a><a target=_blank rel=noopener href="https://interviewguide.cn/#/Doc/Knowledge/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C?id=19%E3%80%81https%E5%92%8Chttp%E7%9A%84%E5%8C%BA%E5%88%AB">HTTPS和HTTP的区别</a></h4><p>1、HTTP协议传输的数据都是未加密的，也就是明文的，因此使用HTTP协议传输隐私信息非常不安全， HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全。</p><p>2、https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。</p><p>3、http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。</p><h3 id=select、poll、epoll><a href=#select、poll、epoll class=headerlink title=select、poll、epoll></a>select、poll、epoll</h3><h2 id=同步异步与阻塞非阻塞><a href=#同步异步与阻塞非阻塞 class=headerlink title=同步异步与阻塞非阻塞></a>同步异步与阻塞非阻塞</h2><h3 id=用户空间和内核空间><a href=#用户空间和内核空间 class=headerlink title=用户空间和内核空间></a>用户空间和内核空间</h3><p>操作系统为了支持多个应用同时运行，需要保证不同进程之间相对独立（一个进程的崩溃不会影响其他的进程 ， 恶意进程不能直接读取和修改其他进程运行时的代码和数据）。 因此操作系统内核<strong>需要拥有高于普通进程的权限</strong>， 以此来调度和管理用户的应用程序。</p><p>于是内存空间被划分为两部分，一部分为内核空间，一部分为用户空间，内核空间存储的代码和数据具有更高级别的权限。内存访问的<strong>相关硬件</strong>在程序执行期间会进行访问控制（ Access Control），使得用户空间的程序不能直接读写内核空间的内存。</p><h3 id=进程切换><a href=#进程切换 class=headerlink title=进程切换></a>进程切换</h3><p><img src=https://upload-images.jianshu.io/upload_images/15744422-0f91fa4d5a55339c.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/925 alt=img></p><p>进程切换</p><p>上图展示了进程切换中几个最重要的步骤：</p><ol><li>当一个程序正在执行的过程中， 中断（interrupt） 或 系统调用（system call） 发生可以使得 CPU 的控制权会从当前进程转移到操作系统内核。</li><li>操作系统内核负责保存进程 i 在 CPU 中的上下文（程序计数器， 寄存器）到 PCBi （操作系统分配给进程的一个内存块）中。</li><li>从 PCBj 取出进程 j 的CPU 上下文， 将 CPU 控制权转移给进程 j ， 开始执行进程 j 的指令。</li></ol><blockquote><p>可以看出来， 操作系统在进行进切换时，需要进行一系列的内存读写操作， 这带来了一定的开销</p></blockquote><h3 id=进程阻塞><a href=#进程阻塞 class=headerlink title=进程阻塞></a>进程阻塞</h3><p><img src=https://upload-images.jianshu.io/upload_images/15744422-a22baad4e8ba5ba8.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/977 alt=img></p><p>进程阻塞</p><p>上图展示了一个进程的不同状态：</p><ul><li>New. 进程正在被创建.</li><li>Running. 进程的指令正在被执行</li><li>Waiting. 进程正在等待一些事件的发生（例如 I&#x2F;O 的完成或者收到某个信号）</li><li>Ready. 进程在等待被操作系统调度</li><li>Terminated. 进程执行完毕（可能是被强行终止的）</li></ul><p>我们所说的 “阻塞”是指进程在<strong>发起了一个系统调用</strong>（System Call） 后， 由于该系统调用的操作不能立即完成，需要等待一段时间，于是内核将进程挂起为<strong>等待 （waiting）</strong>状态， 以确保它不会被调度执行， 占用 CPU 资源。</p><p><strong>阻塞的原理</strong></p><p>阻塞的原理？</p><p><img src=https://upload-images.jianshu.io/upload_images/15744422-287d3903e5faf39d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/484 alt=img></p><p>分时进程队列</p><p>对于Socket来说：</p><p>当发生阻塞时候，调用阻塞程序，而阻塞程序最重要的一个操作就是将进程从工作队列移除，并且将其加到等待队列。</p><p><img src=https://upload-images.jianshu.io/upload_images/15744422-a1aa3ba57ef13bad.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/563 alt=img></p><p>阻塞</p><p>当发生中断时候，调用中断程序，而中断程序最重要的一个操作就是将等待队列中的进程重新移回工作队列，继续分配系统的CPU资源。</p><p><img src=https://upload-images.jianshu.io/upload_images/15744422-cc1d0f4c42acde9d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/585 alt=img></p><p>中断</p><h3 id=文件描述符><a href=#文件描述符 class=headerlink title=文件描述符></a>文件描述符</h3><p>我们最熟悉的句柄是0、1、2三个，0是标准输入，1是标准输出，2是标准错误输出。0、1、2是整数表示的，对应的FILE *结构的表示就是stdin、stdout、stderr，0就是stdin，1就是stdout，2就是stderr。</p><figure class="highlight c++"><table><tr><td class=code><pre><span class=line><span class=meta>#<span class=keyword>include</span> <span class=string>&lt;stdio.h&gt;</span></span></span><br><span class=line><span class=meta>#<span class=keyword>include</span> <span class=string>&lt;unistd.h&gt;</span></span></span><br><span class=line><span class=meta>#<span class=keyword>include</span> <span class=string>&lt;string.h&gt;</span></span></span><br><span class=line><span class=function><span class=type>int</span> <span class=title>main</span><span class=params>(<span class=type>int</span> argc, <span class=type>char</span> **argv)</span></span></span><br><span class=line><span class=function></span>&#123;</span><br><span class=line>    <span class=type>char</span> buf[<span class=number>10</span>] = <span class=string>&quot;&quot;</span>;</span><br><span class=line>    <span class=built_in>read</span>(<span class=number>0</span>, buf, <span class=number>9</span>);              <span class=comment>/* 从标准输入 0 读入字符 */</span></span><br><span class=line>    <span class=comment>// fprintf(stdout, &quot;%s\n&quot;, buf); /* 向标准输出 stdout 写字符 */</span></span><br><span class=line>    <span class=built_in>write</span>(<span class=number>1</span>, buf, <span class=built_in>strlen</span>(buf));</span><br><span class=line>    <span class=keyword>return</span> <span class=number>0</span>;</span><br><span class=line>&#125;</span><br></pre></td></tr></table></figure><h3 id=同步><a href=#同步 class=headerlink title=同步></a>同步</h3><p>同步就是一个任务的完成需要依赖另外一个任务时，只有等待被依赖的任务完成后，依赖的任务才能算完成，这是一种可靠的任务序列。<strong>也就是说，调用会等待返回结果计算完成才能继续执行。</strong></p><h3 id=异步><a href=#异步 class=headerlink title=异步></a>异步</h3><p>异步是不需要等待被依赖的任务完成，只是通知被依赖的任务要完成什么工作，依赖的任务也立即执行，只要自己完成了整个任务就算完成了。<strong>也就是说，其实异步调用会直接返回，但是这个结果不是计算的结果，当结果计算出来之后，才通知被调用的程序。</strong></p><blockquote><p>举个通俗的例子：<br>你打电话问书店老板有没有《分布式系统》这本书，如果是同步通信机制，书店老板会说，你稍等，”我查一下”，然后开始查啊查，等查好了（可能是5秒，也可能是一天）告诉你结果（返回结果）。<br>而异步通信机制，书店老板直接告诉你我查一下啊，查好了打电话给你，然后直接挂电话了（不返回结果）。然后查好了，他会主动打电话给你。在这里老板通过“回电”这种方式来回调。</p></blockquote><h3 id=阻塞><a href=#阻塞 class=headerlink title=阻塞></a>阻塞</h3><p>阻塞调用是指调用结果返回之前，当前线程会被挂起，一直处于等待消息通知，不能够执行其他业务。</p><h3 id=非阻塞><a href=#非阻塞 class=headerlink title=非阻塞></a>非阻塞</h3><p>不管可不可以读写，它都会立即返回，返回成功说明读写操作完成了，返回失败会设置相应errno状态码，根据这个errno可以进一步执行其他处理。它不会像阻塞IO那样，卡在那里不动。</p><blockquote><p>阻塞和非阻塞关注的是<strong>程序在等待调用结果（消息，返回值）时的状态.</strong></p></blockquote><p><strong>可以这么理解么？阻塞和非阻塞，应该描述的是一种状态，同步与非同步描述的是行为方式.</strong></p><h3 id=多路复用><a href=#多路复用 class=headerlink title=多路复用></a>多路复用</h3><p>&#x3D;&#x3D;IO多路复用是指内核一旦发现进程指定的一个或者多个IO条件准备读取，它就通知该进程&#x3D;&#x3D;。</p><p>在处理 IO 的时候，阻塞和非阻塞都是同步 IO。<br>只有使用了特殊的 API 才是异步 IO。</p><p><img src=https://upload-images.jianshu.io/upload_images/15744422-1ad8e572f0df79ba.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/415 alt=img></p><p>同步IO与异步IO</p><p>select、poll、epoll之间的区别：</p><table><thead><tr><th align=center>\</th><th align=center>select</th><th align=center>poll</th><th align=center>epoll</th></tr></thead><tbody><tr><td align=center>操作方式</td><td align=center>遍历</td><td align=center>遍历</td><td align=center>回调</td></tr><tr><td align=center>底层实现</td><td align=center>数组</td><td align=center>链表</td><td align=center>哈希表</td></tr><tr><td align=center>IO效率</td><td align=center>每次调用都进行线性遍历，时间复杂度为O(n)</td><td align=center>每次调用都进行线性遍历，时间复杂度为O(n)</td><td align=center>事件通知方式，每当fd就绪，系统注册的回调函数就会被调用，将就绪fd放到rdllist里面。时间复杂度O(1)</td></tr><tr><td align=center>最大连接数</td><td align=center>1024（x86）或 2048（x64）</td><td align=center>无上限</td><td align=center>无上限</td></tr><tr><td align=center>fd拷贝</td><td align=center>每次调用select，都需要把fd集合从用户态拷贝到内核态</td><td align=center>每次调用poll，都需要把fd集合从用户态拷贝到内核态</td><td align=center>调用epoll_ctl时拷贝进内核并保存，之后每次epoll_wait不拷贝</td></tr></tbody></table><h2 id=Select><a href=#Select class=headerlink title=Select></a>Select</h2><p>基于select调用的I&#x2F;O复用模型如下：</p><p><img src=https://upload-images.jianshu.io/upload_images/15744422-fda6bf9dd993626e.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/565 alt=img></p><p>img</p><h3 id=流程><a href=#流程 class=headerlink title=流程></a>流程</h3><p><img src=https://upload-images.jianshu.io/upload_images/15744422-9235bdb58a8de591.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/475 alt=img></p><p>select流程</p><p><strong>传统select&#x2F;poll的另一个致命弱点就是当你拥有一个很大的socket集合，由于网络得延时，使得任一时间只有部分的socket是”活跃” 的，而select&#x2F;poll每次调用都会线性扫描全部的集合，导致效率呈现线性下降。</strong></p><p><strong>但是epoll不存在这个问题，它只会对”活跃”的socket进 行操作</strong>—这是因为在内核实现中epoll是根据每个fd上面的callback函数实现的。于是，只有”活跃”的socket才会主动去调用 callback函数，其他idle状态的socket则不会，在这点上，epoll实现了一个<font color=pink> “伪”AIO</font>，因为这时候推动力在os内核。</p><p><strong>过程</strong></p><p>当进程A调用select语句的时候，会将进程A添加到多个监听socket的等待队列中</p><p><img src=https://upload-images.jianshu.io/upload_images/15744422-3a36f7cc5e48276a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/628 alt=img></p><p>Select阻塞过程</p><p>当网卡接收到数据，然后网卡通过中断信号通知cpu有数据到达，执行中断程序，中断程序主要做了两件事：</p><ol><li>将网络数据写入到对应socket的接收缓冲区里面</li><li>唤醒队列中的等待进程(A),重新将进程A放入工作队列中.</li></ol><p>如下图，将所有等待队列的进程移除，并且添加到工作队列中。</p><p><img src=https://upload-images.jianshu.io/upload_images/15744422-543af9ba5e6e2ba6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/582 alt=img></p><p>Select中断</p><blockquote><p>上面只是一种情况，当程序调用 Select 时，内核会先遍历一遍 Socket，如果有一个以上的 Socket 接收缓冲区有数据，那么 Select 直接返回，不会阻塞。</p></blockquote><p>问题：</p><ul><li>每次调用 Select 都需要将进程加入到所有监视 Socket 的等待队列，每次唤醒都需要从每个队列中移除。这里涉及了两次遍历，而且每次都要将整个 FDS 列表传递给内核，有一定的开销。</li><li>进程被唤醒后，程序并不知道哪些 Socket 收到数据，还需要遍历一次</li></ul><blockquote><p>select和poll在内部机制方面并没有太大的差异。相比于select机制，poll只是取消了最大监控文件描述符数限制，并没有从根本上解决select存在的问题。</p></blockquote><h3 id=Slect-API><a href=#Slect-API class=headerlink title="Slect API"></a>Slect API</h3><p>轮询所有的句柄，找到有处理状态的句柄并且进行操作。</p><p>主要函数：</p><figure class="highlight c++"><table><tr><td class=code><pre><span class=line><span class=comment>/* According to POSIX.1-2001 */</span></span><br><span class=line><span class=meta>#<span class=keyword>include</span> <span class=string>&lt;sys/select.h&gt;</span></span></span><br><span class=line></span><br><span class=line><span class=comment>/* According to earlier standards */</span></span><br><span class=line><span class=meta>#<span class=keyword>include</span> <span class=string>&lt;sys/time.h&gt;</span></span></span><br><span class=line><span class=meta>#<span class=keyword>include</span> <span class=string>&lt;sys/types.h&gt;</span></span></span><br><span class=line><span class=meta>#<span class=keyword>include</span> <span class=string>&lt;unistd.h&gt;</span></span></span><br><span class=line></span><br><span class=line><span class=function><span class=type>int</span> <span class=title>select</span><span class=params>(<span class=type>int</span> nfds, fd_set *readfds, fd_set *writefds,</span></span></span><br><span class=line><span class=params><span class=function>           fd_set *exceptfds, <span class=keyword>struct</span> timeval *timeout)</span></span>;</span><br><span class=line><span class=comment>/**</span></span><br><span class=line><span class=comment>    nfds:       监控的文件描述符集里最大文件描述符加1，因为此参数会告诉内核检测前多少个文件描述符的状态</span></span><br><span class=line><span class=comment>    readfds：    监控有读数据到达文件描述符集合，传入传出参数</span></span><br><span class=line><span class=comment>    writefds：   监控写数据到达文件描述符集合，传入传出参数</span></span><br><span class=line><span class=comment>    exceptfds：  监控异常发生达文件描述符集合,如带外数据到达异常，传入传出参数</span></span><br><span class=line><span class=comment>    timeout：    定时阻塞监控时间，3种情况</span></span><br><span class=line><span class=comment>                1.NULL，永远等下去</span></span><br><span class=line><span class=comment>                2.设置timeval，等待固定时间</span></span><br><span class=line><span class=comment>                3.设置timeval里时间均为0，检查描述字后立即返回，轮询</span></span><br><span class=line><span class=comment>    struct timeval &#123;</span></span><br><span class=line><span class=comment>        long tv_sec; // seconds </span></span><br><span class=line><span class=comment>        long tv_usec; // microseconds </span></span><br><span class=line><span class=comment>    &#125;;</span></span><br><span class=line><span class=comment>*/</span></span><br><span class=line><span class=function><span class=type>void</span> <span class=title>FD_CLR</span><span class=params>(<span class=type>int</span> fd, fd_set *set)</span></span>;   <span class=comment>// 把文件描述符集合里fd清0</span></span><br><span class=line><span class=function><span class=type>int</span>  <span class=title>FD_ISSET</span><span class=params>(<span class=type>int</span> fd, fd_set *set)</span></span>; <span class=comment>// 测试文件描述符集合里fd是否置1</span></span><br><span class=line><span class=function><span class=type>void</span> <span class=title>FD_SET</span><span class=params>(<span class=type>int</span> fd, fd_set *set)</span></span>;   <span class=comment>// 把文件描述符集合里fd位置1</span></span><br><span class=line><span class=function><span class=type>void</span> <span class=title>FD_ZERO</span><span class=params>(fd_set *set)</span></span>;         <span class=comment>//把文件描述符集合里所有位清0</span></span><br></pre></td></tr></table></figure><h3 id=Select例子><a href=#Select例子 class=headerlink title=Select例子></a>Select例子</h3><p><strong>服务器</strong></p><figure class="highlight c++"><table><tr><td class=code><pre><span class=line><span class=comment>/*************************************************************************</span></span><br><span class=line><span class=comment>    &gt; File Name: server.cpp</span></span><br><span class=line><span class=comment>    &gt; Author: SongLee</span></span><br><span class=line><span class=comment>    &gt; E-mail: lisong.shine@qq.com</span></span><br><span class=line><span class=comment>    &gt; Created Time: 2016年04月28日 星期四 22时02分43秒</span></span><br><span class=line><span class=comment>    &gt; Personal Blog: http://songlee24.github.io/</span></span><br><span class=line><span class=comment> ************************************************************************/</span></span><br><span class=line><span class=meta>#<span class=keyword>include</span> <span class=string>&lt;netinet/in.h&gt;</span> <span class=comment>// sockaddr_in</span></span></span><br><span class=line><span class=meta>#<span class=keyword>include</span> <span class=string>&lt;sys/types.h&gt;</span>  <span class=comment>// socket</span></span></span><br><span class=line><span class=meta>#<span class=keyword>include</span> <span class=string>&lt;sys/socket.h&gt;</span> <span class=comment>// socket</span></span></span><br><span class=line><span class=meta>#<span class=keyword>include</span> <span class=string>&lt;arpa/inet.h&gt;</span></span></span><br><span class=line><span class=meta>#<span class=keyword>include</span> <span class=string>&lt;unistd.h&gt;</span></span></span><br><span class=line><span class=meta>#<span class=keyword>include</span> <span class=string>&lt;sys/select.h&gt;</span> <span class=comment>// select</span></span></span><br><span class=line><span class=meta>#<span class=keyword>include</span> <span class=string>&lt;sys/ioctl.h&gt;</span></span></span><br><span class=line><span class=meta>#<span class=keyword>include</span> <span class=string>&lt;sys/time.h&gt;</span></span></span><br><span class=line><span class=meta>#<span class=keyword>include</span> <span class=string>&lt;iostream&gt;</span></span></span><br><span class=line><span class=meta>#<span class=keyword>include</span> <span class=string>&lt;vector&gt;</span></span></span><br><span class=line><span class=meta>#<span class=keyword>include</span> <span class=string>&lt;string&gt;</span></span></span><br><span class=line><span class=meta>#<span class=keyword>include</span> <span class=string>&lt;cstdlib&gt;</span></span></span><br><span class=line><span class=meta>#<span class=keyword>include</span> <span class=string>&lt;cstdio&gt;</span></span></span><br><span class=line><span class=meta>#<span class=keyword>include</span> <span class=string>&lt;cstring&gt;</span></span></span><br><span class=line><span class=keyword>using</span> <span class=keyword>namespace</span> std;</span><br><span class=line><span class=meta>#<span class=keyword>define</span> BUFFER_SIZE 1024</span></span><br><span class=line></span><br><span class=line><span class=keyword>struct</span> <span class="title class_">PACKET_HEAD</span></span><br><span class=line>&#123;</span><br><span class=line>    <span class=type>int</span> length;</span><br><span class=line>&#125;;</span><br><span class=line></span><br><span class=line><span class=keyword>class</span> <span class="title class_">Server</span></span><br><span class=line>&#123;</span><br><span class=line><span class=keyword>private</span>:</span><br><span class=line>    <span class=keyword>struct</span> <span class="title class_">sockaddr_in</span> server_addr;</span><br><span class=line>    <span class=type>socklen_t</span> server_addr_len;</span><br><span class=line>    <span class=type>int</span> listen_fd;      <span class=comment>// 监听的fd</span></span><br><span class=line>    <span class=type>int</span> max_fd;         <span class=comment>// 最大的fd</span></span><br><span class=line>    fd_set master_set;  <span class=comment>// 所有fd集合，包括监听fd和客户端fd</span></span><br><span class=line>    fd_set working_set; <span class=comment>// 工作集合</span></span><br><span class=line>    <span class=keyword>struct</span> <span class="title class_">timeval</span> timeout;</span><br><span class=line></span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>    <span class=built_in>Server</span>(<span class=type>int</span> port);</span><br><span class=line>    ~<span class=built_in>Server</span>();</span><br><span class=line>    <span class=function><span class=type>void</span> <span class=title>Bind</span><span class=params>()</span></span>;</span><br><span class=line>    <span class=function><span class=type>void</span> <span class=title>Listen</span><span class=params>(<span class=type>int</span> queue_len = <span class=number>20</span>)</span></span>;</span><br><span class=line>    <span class=function><span class=type>void</span> <span class=title>Accept</span><span class=params>()</span></span>;</span><br><span class=line>    <span class=function><span class=type>void</span> <span class=title>Run</span><span class=params>()</span></span>;</span><br><span class=line>    <span class=function><span class=type>void</span> <span class=title>Recv</span><span class=params>(<span class=type>int</span> nums)</span></span>;</span><br><span class=line>&#125;;</span><br><span class=line></span><br><span class=line>Server::<span class=built_in>Server</span>(<span class=type>int</span> port)</span><br><span class=line>&#123;</span><br><span class=line>    <span class=built_in>bzero</span>(&amp;server_addr, <span class=built_in>sizeof</span>(server_addr));</span><br><span class=line>    server_addr.sin_family = AF_INET;</span><br><span class=line>    server_addr.sin_addr.s_addr = <span class=built_in>htons</span>(INADDR_ANY);</span><br><span class=line>    server_addr.sin_port = <span class=built_in>htons</span>(port);</span><br><span class=line>    <span class=comment>// create socket to listen</span></span><br><span class=line>    listen_fd = <span class=built_in>socket</span>(PF_INET, SOCK_STREAM, <span class=number>0</span>);</span><br><span class=line>    <span class=keyword>if</span> (listen_fd &lt; <span class=number>0</span>)</span><br><span class=line>    &#123;</span><br><span class=line>        cout &lt;&lt; <span class=string>&quot;Create Socket Failed!&quot;</span>;</span><br><span class=line>        <span class=built_in>exit</span>(<span class=number>1</span>);</span><br><span class=line>    &#125;</span><br><span class=line>    <span class=type>int</span> opt = <span class=number>1</span>;</span><br><span class=line>    <span class=comment>// 允许重用本地地址和端口</span></span><br><span class=line>    <span class=built_in>setsockopt</span>(listen_fd, SOL_SOCKET, SO_REUSEADDR, &amp;opt, <span class=built_in>sizeof</span>(opt));</span><br><span class=line>&#125;</span><br><span class=line></span><br><span class=line>Server::~<span class=built_in>Server</span>()</span><br><span class=line>&#123;</span><br><span class=line>    <span class=keyword>for</span> (<span class=type>int</span> fd = <span class=number>0</span>; fd &lt;= max_fd; ++fd)</span><br><span class=line>    &#123;</span><br><span class=line>        <span class=keyword>if</span> (<span class=built_in>FD_ISSET</span>(fd, &amp;master_set))</span><br><span class=line>        &#123;</span><br><span class=line>            <span class=built_in>close</span>(fd);</span><br><span class=line>        &#125;</span><br><span class=line>    &#125;</span><br><span class=line>&#125;</span><br><span class=line></span><br><span class=line><span class=function><span class=type>void</span> <span class=title>Server::Bind</span><span class=params>()</span></span></span><br><span class=line><span class=function></span>&#123;</span><br><span class=line>    <span class=keyword>if</span> (<span class=number>-1</span> == (<span class=built_in>bind</span>(listen_fd, (<span class=keyword>struct</span> sockaddr *)&amp;server_addr, <span class=built_in>sizeof</span>(server_addr))))</span><br><span class=line>    &#123;</span><br><span class=line>        cout &lt;&lt; <span class=string>&quot;Server Bind Failed!&quot;</span>;</span><br><span class=line>        <span class=built_in>exit</span>(<span class=number>1</span>);</span><br><span class=line>    &#125;</span><br><span class=line>    cout &lt;&lt; <span class=string>&quot;Bind Successfully.\n&quot;</span>;</span><br><span class=line>&#125;</span><br><span class=line></span><br><span class=line><span class=function><span class=type>void</span> <span class=title>Server::Listen</span><span class=params>(<span class=type>int</span> queue_len)</span></span></span><br><span class=line><span class=function></span>&#123;</span><br><span class=line>    <span class=keyword>if</span> (<span class=number>-1</span> == <span class=built_in>listen</span>(listen_fd, queue_len))</span><br><span class=line>    &#123;</span><br><span class=line>        cout &lt;&lt; <span class=string>&quot;Server Listen Failed!&quot;</span>;</span><br><span class=line>        <span class=built_in>exit</span>(<span class=number>1</span>);</span><br><span class=line>    &#125;</span><br><span class=line>    cout &lt;&lt; <span class=string>&quot;Listen Successfully.\n&quot;</span>;</span><br><span class=line>&#125;</span><br><span class=line></span><br><span class=line><span class=function><span class=type>void</span> <span class=title>Server::Accept</span><span class=params>()</span></span></span><br><span class=line><span class=function></span>&#123;</span><br><span class=line>    <span class=keyword>struct</span> <span class="title class_">sockaddr_in</span> client_addr;</span><br><span class=line>    <span class=type>socklen_t</span> client_addr_len = <span class=built_in>sizeof</span>(client_addr);</span><br><span class=line></span><br><span class=line>    <span class=type>int</span> new_fd = <span class=built_in>accept</span>(listen_fd, (<span class=keyword>struct</span> sockaddr *)&amp;client_addr, &amp;client_addr_len);</span><br><span class=line>    <span class=keyword>if</span> (new_fd &lt; <span class=number>0</span>)</span><br><span class=line>    &#123;</span><br><span class=line>        cout &lt;&lt; <span class=string>&quot;Server Accept Failed!&quot;</span>;</span><br><span class=line>        <span class=built_in>exit</span>(<span class=number>1</span>);</span><br><span class=line>    &#125;</span><br><span class=line></span><br><span class=line>    cout &lt;&lt; <span class=string>&quot;new connection was accepted.\n&quot;</span>;</span><br><span class=line>    <span class=comment>// 将新建立的连接的fd加入master_set</span></span><br><span class=line>    <span class=built_in>FD_SET</span>(new_fd, &amp;master_set);</span><br><span class=line>    <span class=keyword>if</span> (new_fd &gt; max_fd)</span><br><span class=line>    &#123;</span><br><span class=line>        max_fd = new_fd;</span><br><span class=line>    &#125;</span><br><span class=line>&#125;</span><br><span class=line></span><br><span class=line><span class=function><span class=type>void</span> <span class=title>Server::Run</span><span class=params>()</span></span></span><br><span class=line><span class=function></span>&#123;</span><br><span class=line>    max_fd = listen_fd; <span class=comment>// 初始化max_fd</span></span><br><span class=line>    <span class=built_in>FD_ZERO</span>(&amp;master_set);</span><br><span class=line>    <span class=built_in>FD_SET</span>(listen_fd, &amp;master_set); <span class=comment>// 添加监听fd</span></span><br><span class=line></span><br><span class=line>    <span class=keyword>while</span> (<span class=number>1</span>)</span><br><span class=line>    &#123;</span><br><span class=line>        <span class=built_in>FD_ZERO</span>(&amp;working_set);</span><br><span class=line>        <span class=built_in>memcpy</span>(&amp;working_set, &amp;master_set, <span class=built_in>sizeof</span>(master_set));</span><br><span class=line></span><br><span class=line>        timeout.tv_sec = <span class=number>30</span>;</span><br><span class=line>        timeout.tv_usec = <span class=number>0</span>;</span><br><span class=line></span><br><span class=line>        <span class=type>int</span> nums = <span class=built_in>select</span>(max_fd + <span class=number>1</span>, &amp;working_set, <span class=literal>NULL</span>, <span class=literal>NULL</span>, &amp;timeout);</span><br><span class=line>        <span class=keyword>if</span> (nums &lt; <span class=number>0</span>)</span><br><span class=line>        &#123;</span><br><span class=line>            cout &lt;&lt; <span class=string>&quot;select() error!&quot;</span>;</span><br><span class=line>            <span class=built_in>exit</span>(<span class=number>1</span>);</span><br><span class=line>        &#125;</span><br><span class=line></span><br><span class=line>        <span class=keyword>if</span> (nums == <span class=number>0</span>)</span><br><span class=line>        &#123;</span><br><span class=line>            <span class=comment>//cout &lt;&lt; &quot;select() is timeout!&quot;;</span></span><br><span class=line>            <span class=keyword>continue</span>;</span><br><span class=line>        &#125;</span><br><span class=line></span><br><span class=line>        <span class=keyword>if</span> (<span class=built_in>FD_ISSET</span>(listen_fd, &amp;working_set))</span><br><span class=line>            <span class=built_in>Accept</span>(); <span class=comment>// 有新的客户端请求</span></span><br><span class=line>        <span class=keyword>else</span></span><br><span class=line>            <span class=built_in>Recv</span>(nums); <span class=comment>// 接收客户端的消息</span></span><br><span class=line>    &#125;</span><br><span class=line>&#125;</span><br><span class=line></span><br><span class=line><span class=function><span class=type>void</span> <span class=title>Server::Recv</span><span class=params>(<span class=type>int</span> nums)</span></span></span><br><span class=line><span class=function></span>&#123;</span><br><span class=line>    <span class=keyword>for</span> (<span class=type>int</span> fd = <span class=number>0</span>; fd &lt;= max_fd; ++fd)</span><br><span class=line>    &#123;</span><br><span class=line>        <span class=keyword>if</span> (<span class=built_in>FD_ISSET</span>(fd, &amp;working_set))</span><br><span class=line>        &#123;</span><br><span class=line>            <span class=type>bool</span> close_conn = <span class=literal>false</span>; <span class=comment>// 标记当前连接是否断开了</span></span><br><span class=line></span><br><span class=line>            PACKET_HEAD head;</span><br><span class=line>            <span class=built_in>recv</span>(fd, &amp;head, <span class=built_in>sizeof</span>(head), <span class=number>0</span>); <span class=comment>// 先接受包头，即数据总长度</span></span><br><span class=line>            <span class=comment>// std::cout &lt;&lt; head.length &lt;&lt; std::endl;</span></span><br><span class=line>            <span class=type>char</span> *buffer = <span class=keyword>new</span> <span class=type>char</span>[head.length];</span><br><span class=line>            <span class=built_in>bzero</span>(buffer, head.length);</span><br><span class=line>            <span class=type>int</span> total = <span class=number>0</span>;</span><br><span class=line>            <span class=keyword>while</span> (total &lt; head.length)</span><br><span class=line>            &#123;</span><br><span class=line>                <span class=type>int</span> len = <span class=built_in>recv</span>(fd, buffer + total, head.length - total, <span class=number>0</span>);</span><br><span class=line>                <span class=keyword>if</span> (len &lt; <span class=number>0</span>)</span><br><span class=line>                &#123;</span><br><span class=line>                    cout &lt;&lt; <span class=string>&quot;recv() error!&quot;</span>;</span><br><span class=line>                    close_conn = <span class=literal>true</span>;</span><br><span class=line>                    <span class=keyword>break</span>;</span><br><span class=line>                &#125;</span><br><span class=line>                total = total + len;</span><br><span class=line>            &#125;</span><br><span class=line></span><br><span class=line>            <span class=keyword>if</span> (total == head.length) <span class=comment>// 将收到的消息原样发回给客户端</span></span><br><span class=line>            &#123;</span><br><span class=line>                <span class=type>int</span> ret1 = <span class=built_in>send</span>(fd, &amp;head, <span class=built_in>sizeof</span>(head), <span class=number>0</span>);</span><br><span class=line>                <span class=type>int</span> ret2 = <span class=built_in>send</span>(fd, buffer, head.length, <span class=number>0</span>);</span><br><span class=line>                <span class=keyword>if</span> (ret1 &lt; <span class=number>0</span> || ret2 &lt; <span class=number>0</span>)</span><br><span class=line>                &#123;</span><br><span class=line>                    cout &lt;&lt; <span class=string>&quot;send() error!&quot;</span>;</span><br><span class=line>                    close_conn = <span class=literal>true</span>;</span><br><span class=line>                &#125;</span><br><span class=line>            &#125;</span><br><span class=line></span><br><span class=line>            <span class=keyword>delete</span> buffer;</span><br><span class=line></span><br><span class=line>            <span class=keyword>if</span> (close_conn) <span class=comment>// 当前这个连接有问题，关闭它</span></span><br><span class=line>            &#123;</span><br><span class=line>                <span class=built_in>close</span>(fd);</span><br><span class=line>                <span class=built_in>FD_CLR</span>(fd, &amp;master_set);</span><br><span class=line>                <span class=keyword>if</span> (fd == max_fd) <span class=comment>// 需要更新max_fd;</span></span><br><span class=line>                &#123;</span><br><span class=line>                    <span class=keyword>while</span> (<span class=built_in>FD_ISSET</span>(max_fd, &amp;master_set) == <span class=literal>false</span>)</span><br><span class=line>                        --max_fd;</span><br><span class=line>                &#125;</span><br><span class=line>            &#125;</span><br><span class=line>        &#125;</span><br><span class=line>    &#125;</span><br><span class=line>&#125;</span><br><span class=line></span><br><span class=line><span class=function><span class=type>int</span> <span class=title>main</span><span class=params>()</span></span></span><br><span class=line><span class=function></span>&#123;</span><br><span class=line>    <span class=function>Server <span class=title>server</span><span class=params>(<span class=number>15000</span>)</span></span>;</span><br><span class=line>    server.<span class=built_in>Bind</span>();</span><br><span class=line>    server.<span class=built_in>Listen</span>();</span><br><span class=line>    server.<span class=built_in>Run</span>();</span><br><span class=line>    <span class=keyword>return</span> <span class=number>0</span>;</span><br><span class=line>&#125;</span><br></pre></td></tr></table></figure><p><strong>客户端</strong></p><figure class="highlight c++"><table><tr><td class=code><pre><span class=line><span class=comment>/*************************************************************************</span></span><br><span class=line><span class=comment>    &gt; File Name: client.cpp</span></span><br><span class=line><span class=comment>    &gt; Author: SongLee</span></span><br><span class=line><span class=comment>    &gt; E-mail: lisong.shine@qq.com</span></span><br><span class=line><span class=comment>    &gt; Created Time: 2016年04月28日 星期四 23时10分15秒</span></span><br><span class=line><span class=comment>    &gt; Personal Blog: http://songlee24.github.io/</span></span><br><span class=line><span class=comment> ************************************************************************/</span></span><br><span class=line><span class=meta>#<span class=keyword>include</span><span class=string>&lt;netinet/in.h&gt;</span>   <span class=comment>// sockaddr_in</span></span></span><br><span class=line><span class=meta>#<span class=keyword>include</span><span class=string>&lt;sys/types.h&gt;</span>    <span class=comment>// socket</span></span></span><br><span class=line><span class=meta>#<span class=keyword>include</span><span class=string>&lt;sys/socket.h&gt;</span>   <span class=comment>// socket</span></span></span><br><span class=line><span class=meta>#<span class=keyword>include</span><span class=string>&lt;arpa/inet.h&gt;</span></span></span><br><span class=line><span class=meta>#<span class=keyword>include</span><span class=string>&lt;sys/ioctl.h&gt;</span></span></span><br><span class=line><span class=meta>#<span class=keyword>include</span><span class=string>&lt;unistd.h&gt;</span></span></span><br><span class=line><span class=meta>#<span class=keyword>include</span><span class=string>&lt;iostream&gt;</span></span></span><br><span class=line><span class=meta>#<span class=keyword>include</span><span class=string>&lt;string&gt;</span></span></span><br><span class=line><span class=meta>#<span class=keyword>include</span><span class=string>&lt;cstdlib&gt;</span></span></span><br><span class=line><span class=meta>#<span class=keyword>include</span><span class=string>&lt;cstdio&gt;</span></span></span><br><span class=line><span class=meta>#<span class=keyword>include</span><span class=string>&lt;cstring&gt;</span></span></span><br><span class=line><span class=keyword>using</span> <span class=keyword>namespace</span> std;</span><br><span class=line><span class=meta>#<span class=keyword>define</span> BUFFER_SIZE 1024</span></span><br><span class=line></span><br><span class=line><span class=keyword>struct</span> <span class="title class_">PACKET_HEAD</span></span><br><span class=line>&#123;</span><br><span class=line>    <span class=type>int</span> length;</span><br><span class=line>&#125;;</span><br><span class=line></span><br><span class=line><span class=keyword>class</span> <span class="title class_">Client</span> </span><br><span class=line>&#123;</span><br><span class=line><span class=keyword>private</span>:</span><br><span class=line>    <span class=keyword>struct</span> <span class="title class_">sockaddr_in</span> server_addr;</span><br><span class=line>    <span class=type>socklen_t</span> server_addr_len;</span><br><span class=line>    <span class=type>int</span> fd;</span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>    <span class=built_in>Client</span>(string ip, <span class=type>int</span> port);</span><br><span class=line>    ~<span class=built_in>Client</span>();</span><br><span class=line>    <span class=function><span class=type>void</span> <span class=title>Connect</span><span class=params>()</span></span>;</span><br><span class=line>    <span class=function><span class=type>void</span> <span class=title>Send</span><span class=params>(string str)</span></span>;</span><br><span class=line>    <span class=function>string <span class=title>Recv</span><span class=params>()</span></span>;</span><br><span class=line>&#125;;</span><br><span class=line></span><br><span class=line>Client::<span class=built_in>Client</span>(string ip, <span class=type>int</span> port)</span><br><span class=line>&#123;</span><br><span class=line>    <span class=built_in>bzero</span>(&amp;server_addr, <span class=built_in>sizeof</span>(server_addr));</span><br><span class=line>    server_addr.sin_family = AF_INET;</span><br><span class=line>    <span class=keyword>if</span>(<span class=built_in>inet_pton</span>(AF_INET, ip.<span class=built_in>c_str</span>(), &amp;server_addr.sin_addr) == <span class=number>0</span>)</span><br><span class=line>    &#123;</span><br><span class=line>        cout &lt;&lt; <span class=string>&quot;Server IP Address Error!&quot;</span>;</span><br><span class=line>        <span class=built_in>exit</span>(<span class=number>1</span>);</span><br><span class=line>    &#125;</span><br><span class=line>    server_addr.sin_port = <span class=built_in>htons</span>(port);</span><br><span class=line>    server_addr_len = <span class=built_in>sizeof</span>(server_addr);</span><br><span class=line>    <span class=comment>// create socket</span></span><br><span class=line>    fd = <span class=built_in>socket</span>(AF_INET, SOCK_STREAM, <span class=number>0</span>);</span><br><span class=line>    <span class=keyword>if</span>(fd &lt; <span class=number>0</span>)</span><br><span class=line>    &#123;</span><br><span class=line>        cout &lt;&lt; <span class=string>&quot;Create Socket Failed!&quot;</span>;</span><br><span class=line>        <span class=built_in>exit</span>(<span class=number>1</span>);</span><br><span class=line>    &#125;</span><br><span class=line>&#125;</span><br><span class=line></span><br><span class=line>Client::~<span class=built_in>Client</span>()</span><br><span class=line>&#123;</span><br><span class=line>    <span class=built_in>close</span>(fd);</span><br><span class=line>&#125;</span><br><span class=line></span><br><span class=line><span class=function><span class=type>void</span> <span class=title>Client::Connect</span><span class=params>()</span></span></span><br><span class=line><span class=function></span>&#123;</span><br><span class=line>    cout &lt;&lt; <span class=string>&quot;Connecting......&quot;</span> &lt;&lt; endl;</span><br><span class=line>    <span class=keyword>if</span>(<span class=built_in>connect</span>(fd, (<span class=keyword>struct</span> sockaddr*)&amp;server_addr, server_addr_len) &lt; <span class=number>0</span>)</span><br><span class=line>    &#123;</span><br><span class=line>        cout &lt;&lt; <span class=string>&quot;Can not Connect to Server IP!&quot;</span>;</span><br><span class=line>        <span class=built_in>exit</span>(<span class=number>1</span>);</span><br><span class=line>    &#125;</span><br><span class=line>    cout &lt;&lt; <span class=string>&quot;Connect to Server successfully.&quot;</span> &lt;&lt; endl;</span><br><span class=line>&#125;</span><br><span class=line></span><br><span class=line><span class=function><span class=type>void</span> <span class=title>Client::Send</span><span class=params>(string str)</span></span></span><br><span class=line><span class=function></span>&#123;</span><br><span class=line>    PACKET_HEAD head;</span><br><span class=line>    head.length = str.<span class=built_in>size</span>()+<span class=number>1</span>;   <span class=comment>// 注意这里需要+1</span></span><br><span class=line>    <span class=type>int</span> ret1 = <span class=built_in>send</span>(fd, &amp;head, <span class=built_in>sizeof</span>(head), <span class=number>0</span>);</span><br><span class=line>    <span class=type>int</span> ret2 = <span class=built_in>send</span>(fd, str.<span class=built_in>c_str</span>(), head.length, <span class=number>0</span>);</span><br><span class=line>    <span class=keyword>if</span>(ret1 &lt; <span class=number>0</span> || ret2 &lt; <span class=number>0</span>)</span><br><span class=line>    &#123;</span><br><span class=line>        cout &lt;&lt; <span class=string>&quot;Send Message Failed!&quot;</span>;</span><br><span class=line>        <span class=built_in>exit</span>(<span class=number>1</span>);</span><br><span class=line>    &#125;</span><br><span class=line>&#125;</span><br><span class=line></span><br><span class=line><span class=function>string <span class=title>Client::Recv</span><span class=params>()</span></span></span><br><span class=line><span class=function></span>&#123;</span><br><span class=line>    PACKET_HEAD head;</span><br><span class=line>    <span class=built_in>recv</span>(fd, &amp;head, <span class=built_in>sizeof</span>(head), <span class=number>0</span>);</span><br><span class=line></span><br><span class=line>    <span class=type>char</span>* buffer = <span class=keyword>new</span> <span class=type>char</span>[head.length];</span><br><span class=line>    <span class=built_in>bzero</span>(buffer, head.length);</span><br><span class=line>    <span class=type>int</span> total = <span class=number>0</span>;</span><br><span class=line>    <span class=keyword>while</span>(total &lt; head.length)</span><br><span class=line>    &#123;</span><br><span class=line>        <span class=type>int</span> len = <span class=built_in>recv</span>(fd, buffer + total, head.length - total, <span class=number>0</span>);</span><br><span class=line>        <span class=keyword>if</span>(len &lt; <span class=number>0</span>)</span><br><span class=line>        &#123;</span><br><span class=line>            cout &lt;&lt; <span class=string>&quot;recv() error!&quot;</span>;</span><br><span class=line>            <span class=keyword>break</span>;</span><br><span class=line>        &#125;</span><br><span class=line>        total = total + len;</span><br><span class=line>    &#125;</span><br><span class=line>    <span class=function>string <span class=title>result</span><span class=params>(buffer)</span></span>;</span><br><span class=line>    <span class=keyword>delete</span> buffer;</span><br><span class=line>    <span class=keyword>return</span> result;</span><br><span class=line>&#125;</span><br><span class=line></span><br><span class=line><span class=function><span class=type>int</span> <span class=title>main</span><span class=params>()</span></span></span><br><span class=line><span class=function></span>&#123;</span><br><span class=line>    <span class=function>Client <span class=title>client</span><span class=params>(<span class=string>&quot;127.0.0.1&quot;</span>, <span class=number>15000</span>)</span></span>;</span><br><span class=line>    client.<span class=built_in>Connect</span>();</span><br><span class=line>    <span class=keyword>while</span>(<span class=number>1</span>)</span><br><span class=line>    &#123;</span><br><span class=line>        string msg;</span><br><span class=line>        <span class=built_in>getline</span>(cin, msg);</span><br><span class=line>        <span class=keyword>if</span>(msg == <span class=string>&quot;exit&quot;</span>)</span><br><span class=line>            <span class=keyword>break</span>;</span><br><span class=line>        client.<span class=built_in>Send</span>(msg);</span><br><span class=line>        cout &lt;&lt; client.<span class=built_in>Recv</span>() &lt;&lt; endl;  </span><br><span class=line>    &#125;</span><br><span class=line>    <span class=keyword>return</span> <span class=number>0</span>;</span><br><span class=line>&#125;</span><br></pre></td></tr></table></figure><p>说明：</p><ul><li>监听socket也由select来轮询，不需要单独的线程；</li><li>working_set每次都要重新设置，因为select调用后它所检测的集合working_set会被修改；</li><li>接收很长一段数据时，需要循环多次recv。但是recv函数会阻塞，可以通过自定义包头（保存数据长度）</li></ul><h2 id=Poll><a href=#Poll class=headerlink title=Poll></a>Poll</h2><p>poll的机制与select类似，与select在本质上没有多大差别，管理多个描述符也是进行轮询，根据描述符的状态进行处理，但是poll没有最大文件描述符数量的限制。poll和select同样存在一个缺点就是，包含大量文件描述符的数组被整体复制于用户态和内核的地址空间之间，而不论这些文件描述符是否就绪，它的开销随着文件描述符数量的增加而线性增大。</p><p>相关的函数：</p><figure class="highlight c++"><table><tr><td class=code><pre><span class=line><span class=meta>#<span class=keyword>include</span> <span class=string>&lt;poll.h&gt;</span></span></span><br><span class=line><span class=function><span class=type>int</span> <span class=title>poll</span><span class=params>(<span class=keyword>struct</span> pollfd fds[], <span class=type>nfds_t</span> nfds, <span class=type>int</span> timeout)</span>；</span></span><br></pre></td></tr></table></figure><p>参数描述：</p><ol><li>该poll()函数返回fds集合中就绪的读、写，或出错的描述符数量，返回0表示超时，返回-1表示出错；</li><li>fds是一个<code>struct pollfd</code>类型的数组，用于存放需要检测其状态的socket描述符，并且调用poll函数之后fds数组不会被清空；</li><li>nfds：记录数组fds中描述符的总数量；</li><li>timeout：调用poll函数阻塞的超时时间，单位毫秒；</li></ol><p>其中pollfd结构体定义如下：</p><figure class="highlight c++"><table><tr><td class=code><pre><span class=line><span class=keyword>typedef</span> <span class=keyword>struct</span> <span class="title class_">pollfd</span> &#123;</span><br><span class=line>        <span class=type>int</span> fd;                         <span class=comment>/* 需要被检测或选择的文件描述符*/</span></span><br><span class=line>        <span class=type>short</span> events;                   <span class=comment>/* 对文件描述符fd上感兴趣的事件 */</span></span><br><span class=line>        <span class=type>short</span> revents;                  <span class=comment>/* 文件描述符fd上当前实际发生的事件*/</span></span><br><span class=line>&#125; <span class=type>pollfd_t</span>;</span><br></pre></td></tr></table></figure><p>一个pollfd结构体表示一个被监视的文件描述符，通过传递<code>fds[]</code>指示 poll() 监视多个文件描述符，其中：</p><ul><li>结构体的<code>events</code>域是监视该文件描述符的事件掩码，由用户来设置这个域。</li><li>结构体的<code>revents</code>域是文件描述符的操作结果事件掩码，内核在调用返回时设置这个域。</li></ul><p>events域中请求的任何事件都可能在revents域中返回。合法的事件如下：</p><table><thead><tr><th>常量</th><th>说明</th></tr></thead><tbody><tr><td>POLLIN</td><td>普通或优先级带数据可读</td></tr><tr><td>POLLRDNORM</td><td>普通数据可读</td></tr><tr><td>POLLRDBAND</td><td>优先级带数据可读</td></tr><tr><td>POLLPRI</td><td>高优先级数据可读</td></tr><tr><td>POLLOUT</td><td>普通数据可写</td></tr><tr><td>POLLWRNORM</td><td>普通数据可写</td></tr><tr><td>POLLWRBAND</td><td>优先级带数据可写</td></tr><tr><td>POLLERR</td><td>发生错误</td></tr><tr><td>POLLHUP</td><td>发生挂起</td></tr><tr><td>POLLNVAL</td><td>描述字不是一个打开的文件</td></tr></tbody></table><p>当需要监听多个事件时，使用<code>POLLIN | POLLRDNORM</code>设置 events 域；当poll调用之后检测某事件是否就绪时，<code>fds[i].revents &amp; POLLIN</code>进行判断。</p><h3 id=Poll例子><a href=#Poll例子 class=headerlink title=Poll例子></a>Poll例子</h3><p><strong>服务器</strong></p><figure class="highlight c++"><table><tr><td class=code><pre><span class=line><span class=meta>#<span class=keyword>include</span> <span class=string>&lt;netinet/in.h&gt;</span> <span class=comment>// sockaddr_in</span></span></span><br><span class=line><span class=meta>#<span class=keyword>include</span> <span class=string>&lt;sys/types.h&gt;</span>  <span class=comment>// socket</span></span></span><br><span class=line><span class=meta>#<span class=keyword>include</span> <span class=string>&lt;sys/socket.h&gt;</span> <span class=comment>// socket</span></span></span><br><span class=line><span class=meta>#<span class=keyword>include</span> <span class=string>&lt;arpa/inet.h&gt;</span></span></span><br><span class=line><span class=meta>#<span class=keyword>include</span> <span class=string>&lt;unistd.h&gt;</span></span></span><br><span class=line><span class=meta>#<span class=keyword>include</span> <span class=string>&lt;poll.h&gt;</span> <span class=comment>// poll</span></span></span><br><span class=line><span class=meta>#<span class=keyword>include</span> <span class=string>&lt;sys/ioctl.h&gt;</span></span></span><br><span class=line><span class=meta>#<span class=keyword>include</span> <span class=string>&lt;sys/time.h&gt;</span></span></span><br><span class=line><span class=meta>#<span class=keyword>include</span> <span class=string>&lt;iostream&gt;</span></span></span><br><span class=line><span class=meta>#<span class=keyword>include</span> <span class=string>&lt;vector&gt;</span></span></span><br><span class=line><span class=meta>#<span class=keyword>include</span> <span class=string>&lt;string&gt;</span></span></span><br><span class=line><span class=meta>#<span class=keyword>include</span> <span class=string>&lt;cstdlib&gt;</span></span></span><br><span class=line><span class=meta>#<span class=keyword>include</span> <span class=string>&lt;cstdio&gt;</span></span></span><br><span class=line><span class=meta>#<span class=keyword>include</span> <span class=string>&lt;cstring&gt;</span></span></span><br><span class=line><span class=keyword>using</span> <span class=keyword>namespace</span> std;</span><br><span class=line><span class=meta>#<span class=keyword>define</span> BUFFER_SIZE 1024</span></span><br><span class=line><span class=meta>#<span class=keyword>define</span> MAX_FD 1000</span></span><br><span class=line></span><br><span class=line><span class=keyword>struct</span> <span class="title class_">PACKET_HEAD</span></span><br><span class=line>&#123;</span><br><span class=line>    <span class=type>int</span> length;</span><br><span class=line>&#125;;</span><br><span class=line></span><br><span class=line><span class=keyword>class</span> <span class="title class_">Server</span></span><br><span class=line>&#123;</span><br><span class=line><span class=keyword>private</span>:</span><br><span class=line>    <span class=keyword>struct</span> <span class="title class_">sockaddr_in</span> server_addr;</span><br><span class=line>    <span class=type>socklen_t</span> server_addr_len;</span><br><span class=line>    <span class=type>int</span> listen_fd;             <span class=comment>// 监听的fd</span></span><br><span class=line>    <span class=keyword>struct</span> <span class="title class_">pollfd</span> fds[MAX_FD]; <span class=comment>// fd数组，大小为1000</span></span><br><span class=line>    <span class=type>int</span> nfds;</span><br><span class=line></span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>    <span class=built_in>Server</span>(<span class=type>int</span> port);</span><br><span class=line>    ~<span class=built_in>Server</span>();</span><br><span class=line>    <span class=function><span class=type>void</span> <span class=title>Bind</span><span class=params>()</span></span>;</span><br><span class=line>    <span class=function><span class=type>void</span> <span class=title>Listen</span><span class=params>(<span class=type>int</span> queue_len = <span class=number>20</span>)</span></span>;</span><br><span class=line>    <span class=function><span class=type>void</span> <span class=title>Accept</span><span class=params>()</span></span>;</span><br><span class=line>    <span class=function><span class=type>void</span> <span class=title>Run</span><span class=params>()</span></span>;</span><br><span class=line>    <span class=function><span class=type>void</span> <span class=title>Recv</span><span class=params>()</span></span>;</span><br><span class=line>&#125;;</span><br><span class=line></span><br><span class=line>Server::<span class=built_in>Server</span>(<span class=type>int</span> port)</span><br><span class=line>&#123;</span><br><span class=line>    <span class=built_in>bzero</span>(&amp;server_addr, <span class=built_in>sizeof</span>(server_addr));</span><br><span class=line>    server_addr.sin_family = AF_INET;</span><br><span class=line>    server_addr.sin_addr.s_addr = <span class=built_in>htons</span>(INADDR_ANY);</span><br><span class=line>    server_addr.sin_port = <span class=built_in>htons</span>(port);</span><br><span class=line>    <span class=comment>// create socket to listen</span></span><br><span class=line>    listen_fd = <span class=built_in>socket</span>(PF_INET, SOCK_STREAM, <span class=number>0</span>);</span><br><span class=line>    <span class=keyword>if</span> (listen_fd &lt; <span class=number>0</span>)</span><br><span class=line>    &#123;</span><br><span class=line>        cout &lt;&lt; <span class=string>&quot;Create Socket Failed!&quot;</span>;</span><br><span class=line>        <span class=built_in>exit</span>(<span class=number>1</span>);</span><br><span class=line>    &#125;</span><br><span class=line>    <span class=type>int</span> opt = <span class=number>1</span>;</span><br><span class=line>    <span class=built_in>setsockopt</span>(listen_fd, SOL_SOCKET, SO_REUSEADDR, &amp;opt, <span class=built_in>sizeof</span>(opt));</span><br><span class=line>&#125;</span><br><span class=line></span><br><span class=line>Server::~<span class=built_in>Server</span>()</span><br><span class=line>&#123;</span><br><span class=line>    <span class=keyword>for</span> (<span class=type>int</span> i = <span class=number>0</span>; i &lt; MAX_FD; ++i)</span><br><span class=line>    &#123;</span><br><span class=line>        <span class=keyword>if</span> (fds[i].fd &gt;= <span class=number>0</span>)</span><br><span class=line>        &#123;</span><br><span class=line>            <span class=built_in>close</span>(fds[i].fd);</span><br><span class=line>        &#125;</span><br><span class=line>    &#125;</span><br><span class=line>&#125;</span><br><span class=line></span><br><span class=line><span class=function><span class=type>void</span> <span class=title>Server::Bind</span><span class=params>()</span></span></span><br><span class=line><span class=function></span>&#123;</span><br><span class=line>    <span class=keyword>if</span> (<span class=number>-1</span> == (<span class=built_in>bind</span>(listen_fd, (<span class=keyword>struct</span> sockaddr *)&amp;server_addr, <span class=built_in>sizeof</span>(server_addr))))</span><br><span class=line>    &#123;</span><br><span class=line>        cout &lt;&lt; <span class=string>&quot;Server Bind Failed!&quot;</span>;</span><br><span class=line>        <span class=built_in>exit</span>(<span class=number>1</span>);</span><br><span class=line>    &#125;</span><br><span class=line>    cout &lt;&lt; <span class=string>&quot;Bind Successfully.\n&quot;</span>;</span><br><span class=line>&#125;</span><br><span class=line></span><br><span class=line><span class=function><span class=type>void</span> <span class=title>Server::Listen</span><span class=params>(<span class=type>int</span> queue_len)</span></span></span><br><span class=line><span class=function></span>&#123;</span><br><span class=line>    <span class=keyword>if</span> (<span class=number>-1</span> == <span class=built_in>listen</span>(listen_fd, queue_len))</span><br><span class=line>    &#123;</span><br><span class=line>        cout &lt;&lt; <span class=string>&quot;Server Listen Failed!&quot;</span>;</span><br><span class=line>        <span class=built_in>exit</span>(<span class=number>1</span>);</span><br><span class=line>    &#125;</span><br><span class=line>    cout &lt;&lt; <span class=string>&quot;Listen Successfully.\n&quot;</span>;</span><br><span class=line>&#125;</span><br><span class=line></span><br><span class=line><span class=function><span class=type>void</span> <span class=title>Server::Accept</span><span class=params>()</span></span></span><br><span class=line><span class=function></span>&#123;</span><br><span class=line>    <span class=keyword>struct</span> <span class="title class_">sockaddr_in</span> client_addr;</span><br><span class=line>    <span class=type>socklen_t</span> client_addr_len = <span class=built_in>sizeof</span>(client_addr);</span><br><span class=line></span><br><span class=line>    <span class=type>int</span> new_fd = <span class=built_in>accept</span>(listen_fd, (<span class=keyword>struct</span> sockaddr *)&amp;client_addr, &amp;client_addr_len);</span><br><span class=line>    <span class=keyword>if</span> (new_fd &lt; <span class=number>0</span>)</span><br><span class=line>    &#123;</span><br><span class=line>        cout &lt;&lt; <span class=string>&quot;Server Accept Failed!&quot;</span>;</span><br><span class=line>        <span class=built_in>exit</span>(<span class=number>1</span>);</span><br><span class=line>    &#125;</span><br><span class=line></span><br><span class=line>    cout &lt;&lt; <span class=string>&quot;new connection was accepted.\n&quot;</span>;</span><br><span class=line>    <span class=comment>// 将新建立的连接的fd加入fds[]</span></span><br><span class=line>    <span class=type>int</span> i;</span><br><span class=line>    <span class=keyword>for</span> (i = <span class=number>1</span>; i &lt; MAX_FD; ++i)</span><br><span class=line>    &#123;</span><br><span class=line>        <span class=keyword>if</span> (fds[i].fd &lt; <span class=number>0</span>)</span><br><span class=line>        &#123;</span><br><span class=line>            fds[i].fd = new_fd;</span><br><span class=line>            <span class=keyword>break</span>;</span><br><span class=line>        &#125;</span><br><span class=line>    &#125;</span><br><span class=line>    <span class=comment>// 超过最大连接数</span></span><br><span class=line>    <span class=keyword>if</span> (i == MAX_FD)</span><br><span class=line>    &#123;</span><br><span class=line>        cout &lt;&lt; <span class=string>&quot;Too many clients.\n&quot;</span>;</span><br><span class=line>        <span class=built_in>exit</span>(<span class=number>1</span>);</span><br><span class=line>    &#125;</span><br><span class=line></span><br><span class=line>    fds[i].events = POLLIN;     <span class=comment>// 设置新描述符的读事件</span></span><br><span class=line>    nfds = i &gt; nfds ? i : nfds; <span class=comment>// 更新连接数</span></span><br><span class=line>&#125;</span><br><span class=line></span><br><span class=line><span class=function><span class=type>void</span> <span class=title>Server::Run</span><span class=params>()</span></span></span><br><span class=line><span class=function></span>&#123;</span><br><span class=line>    fds[<span class=number>0</span>].fd = listen_fd; <span class=comment>// 添加监听描述符</span></span><br><span class=line>    fds[<span class=number>0</span>].events = POLLIN;</span><br><span class=line>    nfds = <span class=number>0</span>;</span><br><span class=line></span><br><span class=line>    <span class=keyword>for</span> (<span class=type>int</span> i = <span class=number>1</span>; i &lt; MAX_FD; ++i)</span><br><span class=line>        fds[i].fd = <span class=number>-1</span>;</span><br><span class=line></span><br><span class=line>    <span class=keyword>while</span> (<span class=number>1</span>)</span><br><span class=line>    &#123;</span><br><span class=line>        <span class=type>int</span> nums = <span class=built_in>poll</span>(fds, nfds + <span class=number>1</span>, <span class=number>-1</span>);</span><br><span class=line>        <span class=keyword>if</span> (nums &lt; <span class=number>0</span>)</span><br><span class=line>        &#123;</span><br><span class=line>            cout &lt;&lt; <span class=string>&quot;poll() error!&quot;</span>;</span><br><span class=line>            <span class=built_in>exit</span>(<span class=number>1</span>);</span><br><span class=line>        &#125;</span><br><span class=line></span><br><span class=line>        <span class=keyword>if</span> (nums == <span class=number>0</span>)</span><br><span class=line>        &#123;</span><br><span class=line>            <span class=keyword>continue</span>;</span><br><span class=line>        &#125;</span><br><span class=line></span><br><span class=line>        <span class=keyword>if</span> (fds[<span class=number>0</span>].revents &amp; POLLIN)</span><br><span class=line>            <span class=built_in>Accept</span>(); <span class=comment>// 有新的客户端请求</span></span><br><span class=line>        <span class=keyword>else</span></span><br><span class=line>            <span class=built_in>Recv</span>();</span><br><span class=line>    &#125;</span><br><span class=line>&#125;</span><br><span class=line></span><br><span class=line><span class=function><span class=type>void</span> <span class=title>Server::Recv</span><span class=params>()</span></span></span><br><span class=line><span class=function></span>&#123;</span><br><span class=line>    <span class=keyword>for</span> (<span class=type>int</span> i = <span class=number>1</span>; i &lt; MAX_FD; ++i)</span><br><span class=line>    &#123;</span><br><span class=line>        <span class=keyword>if</span> (fds[i].fd &lt; <span class=number>0</span>)</span><br><span class=line>            <span class=keyword>continue</span>;</span><br><span class=line>        <span class=keyword>if</span> (fds[i].revents &amp; POLLIN) <span class=comment>// 读就绪</span></span><br><span class=line>        &#123;</span><br><span class=line>            <span class=type>int</span> fd = fds[i].fd;</span><br><span class=line>            <span class=type>bool</span> close_conn = <span class=literal>false</span>; <span class=comment>// 标记当前连接是否断开了</span></span><br><span class=line></span><br><span class=line>            PACKET_HEAD head;</span><br><span class=line>            <span class=built_in>recv</span>(fd, &amp;head, <span class=built_in>sizeof</span>(head), <span class=number>0</span>); <span class=comment>// 先接受包头，即数据总长度</span></span><br><span class=line></span><br><span class=line>            <span class=type>char</span> *buffer = <span class=keyword>new</span> <span class=type>char</span>[head.length];</span><br><span class=line>            <span class=built_in>bzero</span>(buffer, head.length);</span><br><span class=line>            <span class=type>int</span> total = <span class=number>0</span>;</span><br><span class=line>            <span class=keyword>while</span> (total &lt; head.length)</span><br><span class=line>            &#123;</span><br><span class=line>                <span class=type>int</span> len = <span class=built_in>recv</span>(fd, buffer + total, head.length - total, <span class=number>0</span>);</span><br><span class=line>                <span class=keyword>if</span> (len &lt; <span class=number>0</span>)</span><br><span class=line>                &#123;</span><br><span class=line>                    cout &lt;&lt; <span class=string>&quot;recv() error!&quot;</span>;</span><br><span class=line>                    close_conn = <span class=literal>true</span>;</span><br><span class=line>                    <span class=keyword>break</span>;</span><br><span class=line>                &#125;</span><br><span class=line>                total = total + len;</span><br><span class=line>            &#125;</span><br><span class=line></span><br><span class=line>            <span class=keyword>if</span> (total == head.length) <span class=comment>// 将收到的消息原样发回给客户端</span></span><br><span class=line>            &#123;</span><br><span class=line>                <span class=type>int</span> ret1 = <span class=built_in>send</span>(fd, &amp;head, <span class=built_in>sizeof</span>(head), <span class=number>0</span>);</span><br><span class=line>                <span class=type>int</span> ret2 = <span class=built_in>send</span>(fd, buffer, head.length, <span class=number>0</span>);</span><br><span class=line>                <span class=keyword>if</span> (ret1 &lt; <span class=number>0</span> || ret2 &lt; <span class=number>0</span>)</span><br><span class=line>                &#123;</span><br><span class=line>                    cout &lt;&lt; <span class=string>&quot;send() error!&quot;</span>;</span><br><span class=line>                    close_conn = <span class=literal>true</span>;</span><br><span class=line>                &#125;</span><br><span class=line>            &#125;</span><br><span class=line></span><br><span class=line>            <span class=keyword>delete</span> buffer;</span><br><span class=line></span><br><span class=line>            <span class=keyword>if</span> (close_conn) <span class=comment>// 当前这个连接有问题，关闭它</span></span><br><span class=line>            &#123;</span><br><span class=line>                <span class=built_in>close</span>(fd);</span><br><span class=line>                fds[i].fd = <span class=number>-1</span>;</span><br><span class=line>            &#125;</span><br><span class=line>        &#125;</span><br><span class=line>    &#125;</span><br><span class=line>&#125;</span><br><span class=line></span><br><span class=line><span class=function><span class=type>int</span> <span class=title>main</span><span class=params>()</span></span></span><br><span class=line><span class=function></span>&#123;</span><br><span class=line>    <span class=function>Server <span class=title>server</span><span class=params>(<span class=number>15000</span>)</span></span>;</span><br><span class=line>    server.<span class=built_in>Bind</span>();</span><br><span class=line>    server.<span class=built_in>Listen</span>();</span><br><span class=line>    server.<span class=built_in>Run</span>();</span><br><span class=line>    <span class=keyword>return</span> <span class=number>0</span>;</span><br><span class=line>&#125;</span><br></pre></td></tr></table></figure><p><strong>客户端</strong></p><p>核Select客户端一样</p><h2 id=Epoll><a href=#Epoll class=headerlink title=Epoll></a>Epoll</h2><p>epoll可以理解为event poll(基于事件的轮询)。</p><h3 id=使用场合：><a href=#使用场合： class=headerlink title=使用场合：></a>使用场合：</h3><ol><li>当客户处理多个描述符时（一般是交互式输入和网络套接口），必须使用I&#x2F;O复用。</li><li>当一个客户同时处理多个套接口时，而这种情况是可能的，但很少出现。</li><li>如果一个TCP服务器既要处理监听套接口，又要处理已连接套接口，一般也要用到I&#x2F;O复用。</li><li>如果一个服务器即要处理TCP，又要处理UDP，一般要使用I&#x2F;O复用。</li><li>如果一个服务器要处理多个服务或多个协议，一般要使用I&#x2F;O复用。</li></ol><blockquote><p>I&#x2F;O多路复用有很多种实现。在linux上，2.4内核前主要是select和poll，自Linux 2.6内核正式引入epoll以来，epoll已经成为了目前实现高性能网络服务器的必备技术。尽管他们的使用方法不尽相同，但是本质上却没有什么区别。</p></blockquote><h3 id=Epoll原理><a href=#Epoll原理 class=headerlink title=Epoll原理></a>Epoll原理</h3><p>不同于select&#x2F;poll，Epoll正是保存了那些收到数据的Socket到一个双向链表中，这样一来，就少了一次遍历。epoll &#x3D; <font color=Orange>减少遍历</font> + <font color=Orange>保存就绪Socket</font></p><ol><li><strong>减少遍历</strong></li></ol><p>将控制与阻塞分离。</p><ol><li><strong>保存就绪Socket</strong></li></ol><p>维护一个rdlist以及rb_tree，类似于双向链表操作。</p><hr><p>通过 epoll_ctl 添加 Sock1、Sock2 和 Sock3 的监视，内核会将 eventpoll的<strong>引用</strong> 添加到这三个 Socket 的等待队列中。</p><p>epoll 在 Linux 内核中申请了一个简易的文件系统，用于存储相关的对象，每一个 epoll 对象都有一个独立的 eventpoll 结构体，这个结构体会在内核空间中创造独立的内存，用于存储使用epoll_ctl 方法向 epoll 对象中添加进来的事件。这些事件都会挂到 rbr 红黑树中，这样，重复添加的事件就可以通过红黑树而高效地识别出来。</p><p><img src=https://upload-images.jianshu.io/upload_images/15744422-32af7c797010bf43.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000 alt=img></p><p>epoll数据结构</p><p>epoll底层实现最重要的两个数据结构:epitem和eventpoll。可以简单的认为epitem是和每个用户态监控IO的fd对应的,eventpoll是用户态创建的管理所有被监控fd的结构，详细的定义如下：</p><figure class="highlight c++"><table><tr><td class=code><pre><span class=line><span class=keyword>struct</span> <span class="title class_">epitem</span> &#123;</span><br><span class=line>  <span class=keyword>struct</span> <span class="title class_">rb_node</span>  rbn;      </span><br><span class=line>  <span class=keyword>struct</span> <span class="title class_">list_head</span>  rdllink; </span><br><span class=line>  <span class=keyword>struct</span> <span class="title class_">epitem</span>  *next;      </span><br><span class=line>  <span class=keyword>struct</span> <span class="title class_">epoll_filefd</span>  ffd;  </span><br><span class=line>  <span class=type>int</span>  nwait;                 </span><br><span class=line>  <span class=keyword>struct</span> <span class="title class_">list_head</span>  pwqlist;  </span><br><span class=line>  <span class=keyword>struct</span> <span class="title class_">eventpoll</span>  *ep;      </span><br><span class=line>  <span class=keyword>struct</span> <span class="title class_">list_head</span>  fllink;   </span><br><span class=line>  <span class=keyword>struct</span> <span class="title class_">epoll_event</span>  event;  </span><br><span class=line>&#125;;</span><br><span class=line></span><br><span class=line><span class=keyword>struct</span> <span class="title class_">eventpoll</span> &#123;</span><br><span class=line>  <span class=type>spin_lock_t</span>       lock; </span><br><span class=line>  <span class=keyword>struct</span> <span class="title class_">mutex</span>      mtx;  </span><br><span class=line>  <span class=type>wait_queue_head_t</span>     wq; </span><br><span class=line>  <span class=type>wait_queue_head_t</span>   poll_wait; </span><br><span class=line>  <span class=keyword>struct</span> <span class="title class_">list_head</span>    rdllist;   <span class=comment>//就绪链表</span></span><br><span class=line>  <span class=keyword>struct</span> <span class="title class_">rb_root</span>      rbr;      <span class=comment>//红黑树根节点 </span></span><br><span class=line>  <span class=keyword>struct</span> <span class="title class_">epitem</span>      *ovflist;</span><br><span class=line>&#125;;</span><br></pre></td></tr></table></figure><p><strong>epoll过程</strong></p><p>调用epoll_create，内核会创建一个eventpoll对象（也就是程序中epfd所代表的对象）。eventpoll对象也是文件系统中的一员，和socket一样，它也会有等待队列。</p><p><img src=https://upload-images.jianshu.io/upload_images/15744422-20eccf6c314f3c76.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/540 alt=img></p><p>创建eventpoll对象</p><p>通过 epoll_ctl 添加 Sock1、Sock2 和 Sock3 的监视，内核会将 eventpoll的<strong>引用</strong> 添加到这三个 Socket 的等待队列中。</p><p><img src=https://upload-images.jianshu.io/upload_images/15744422-f5413d2fce88ff00.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/966 alt=img></p><p>image-20200830163121454</p><p>当Socket收到数据之后，中断程序会执行将Socket的<strong>引用</strong>添加到eventpoll对象的rdlist就绪列表中。</p><p><img src=https://upload-images.jianshu.io/upload_images/15744422-129ddaf93b668a13.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/848 alt=img></p><p>添加socket到rdlist</p><p>假设计算机中正在运行进程 A 和进程 B、C，在某时刻进程 A 运行到了 epoll_wait 语句，会将进程A添加到eventpoll的等待队列中。</p><p><img src=https://upload-images.jianshu.io/upload_images/15744422-5fdf94c3582f06ed.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/845 alt=img></p><p>阻塞加入等待队列</p><p>当 Socket 接收到数据，中断程序一方面修改 Rdlist，另一方面唤醒 eventpoll 等待队列中的进程，进程 A 再次进入运行状态。因为Soket包含eventpoll对象的引用，因此可以直接操作eventpoll对象.</p><p><img src=https://upload-images.jianshu.io/upload_images/15744422-a5ea34937d73a36a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000 alt=img></p><p>中断加入就绪队列</p><p><strong>epoll API</strong></p><p>epoll的api定义:</p><figure class="highlight c++"><table><tr><td class=code><pre><span class=line><span class=comment>//用户数据载体</span></span><br><span class=line><span class=keyword>typedef</span> <span class=keyword>union</span> <span class="title class_">epoll_data</span> &#123;</span><br><span class=line>   <span class=type>void</span>    *ptr;</span><br><span class=line>   <span class=type>int</span>      fd;</span><br><span class=line>   <span class=type>uint32_t</span> u32;</span><br><span class=line>   <span class=type>uint64_t</span> u64;</span><br><span class=line>&#125; <span class=type>epoll_data_t</span>;</span><br><span class=line><span class=comment>//fd装载入内核的载体</span></span><br><span class=line> <span class=keyword>struct</span> <span class="title class_">epoll_event</span> &#123;</span><br><span class=line>     <span class=type>uint32_t</span>     events;    <span class=comment>/* Epoll events */</span></span><br><span class=line>     <span class=type>epoll_data_t</span> data;      <span class=comment>/* User data variable */</span></span><br><span class=line> &#125;;</span><br><span class=line> <span class=comment>//三板斧api</span></span><br><span class=line><span class=function><span class=type>int</span> <span class=title>epoll_create</span><span class=params>(<span class=type>int</span> size)</span></span>; </span><br><span class=line><span class=function><span class=type>int</span> <span class=title>epoll_ctl</span><span class=params>(<span class=type>int</span> epfd, <span class=type>int</span> op, <span class=type>int</span> fd, <span class=keyword>struct</span> epoll_event *event)</span></span>;  </span><br><span class=line><span class=function><span class=type>int</span> <span class=title>epoll_wait</span><span class=params>(<span class=type>int</span> epfd, <span class=keyword>struct</span> epoll_event *events,</span></span></span><br><span class=line><span class=params><span class=function>                 <span class=type>int</span> maxevents, <span class=type>int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><strong>poll_create</strong>是在内核区创建一个epoll相关的一些列结构，并且将一个句柄fd返回给用户态，后续的操作都是基于此fd的，参数size是告诉内核这个结构的元素的大小，类似于stl的vector动态数组，如果size不合适会涉及复制扩容，不过貌似4.1.2内核之后size已经没有太大用途了；</li><li><strong>epoll_ctl</strong>是将fd添加&#x2F;删除于epoll_create返回的epfd中，其中epoll_event是用户态和内核态交互的结构，定义了用户态关心的事件类型和触发时数据的载体epoll_data；</li><li><strong>epoll_wait</strong>*是阻塞等待内核返回的可读写事件，epfd还是epoll_create的返回值，events是个结构体数组指针存储epoll_event，也就是将内核返回的待处理epoll_event结构都存储下来，maxevents告诉内核本次返回的最大fd数量，这个和events指向的数组是相关的；</li><li><strong>epoll_wait</strong>是用户态需监控fd的代言人，后续用户程序对fd的操作都是基于此结构的；</li></ul><h3 id=epoll例子><a href=#epoll例子 class=headerlink title=epoll例子></a>epoll例子</h3><p>服务端</p><figure class="highlight c++"><table><tr><td class=code><pre><span class=line><span class=meta>#<span class=keyword>include</span> <span class=string>&lt;netinet/in.h&gt;</span> <span class=comment>// sockaddr_in</span></span></span><br><span class=line><span class=meta>#<span class=keyword>include</span> <span class=string>&lt;sys/types.h&gt;</span>  <span class=comment>// socket</span></span></span><br><span class=line><span class=meta>#<span class=keyword>include</span> <span class=string>&lt;sys/socket.h&gt;</span> <span class=comment>// socket</span></span></span><br><span class=line><span class=meta>#<span class=keyword>include</span> <span class=string>&lt;arpa/inet.h&gt;</span></span></span><br><span class=line><span class=meta>#<span class=keyword>include</span> <span class=string>&lt;unistd.h&gt;</span></span></span><br><span class=line><span class=meta>#<span class=keyword>include</span> <span class=string>&lt;sys/epoll.h&gt;</span> <span class=comment>// epoll</span></span></span><br><span class=line><span class=meta>#<span class=keyword>include</span> <span class=string>&lt;sys/ioctl.h&gt;</span></span></span><br><span class=line><span class=meta>#<span class=keyword>include</span> <span class=string>&lt;sys/time.h&gt;</span></span></span><br><span class=line><span class=meta>#<span class=keyword>include</span> <span class=string>&lt;iostream&gt;</span></span></span><br><span class=line><span class=meta>#<span class=keyword>include</span> <span class=string>&lt;vector&gt;</span></span></span><br><span class=line><span class=meta>#<span class=keyword>include</span> <span class=string>&lt;string&gt;</span></span></span><br><span class=line><span class=meta>#<span class=keyword>include</span> <span class=string>&lt;cstdlib&gt;</span></span></span><br><span class=line><span class=meta>#<span class=keyword>include</span> <span class=string>&lt;cstdio&gt;</span></span></span><br><span class=line><span class=meta>#<span class=keyword>include</span> <span class=string>&lt;cstring&gt;</span></span></span><br><span class=line><span class=keyword>using</span> <span class=keyword>namespace</span> std;</span><br><span class=line><span class=meta>#<span class=keyword>define</span> BUFFER_SIZE 1024</span></span><br><span class=line><span class=meta>#<span class=keyword>define</span> EPOLLSIZE 100</span></span><br><span class=line></span><br><span class=line><span class=keyword>struct</span> <span class="title class_">PACKET_HEAD</span></span><br><span class=line>&#123;</span><br><span class=line>    <span class=type>int</span> length;</span><br><span class=line>&#125;;</span><br><span class=line></span><br><span class=line><span class=keyword>class</span> <span class="title class_">Server</span></span><br><span class=line>&#123;</span><br><span class=line><span class=keyword>private</span>:</span><br><span class=line>    <span class=keyword>struct</span> <span class="title class_">sockaddr_in</span> server_addr;</span><br><span class=line>    <span class=type>socklen_t</span> server_addr_len;</span><br><span class=line>    <span class=type>int</span> listen_fd;                        <span class=comment>// 监听的fd</span></span><br><span class=line>    <span class=type>int</span> epfd;                             <span class=comment>// epoll fd</span></span><br><span class=line>    <span class=keyword>struct</span> <span class="title class_">epoll_event</span> events[EPOLLSIZE]; <span class=comment>// epoll_wait返回的就绪事件</span></span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>    <span class=built_in>Server</span>(<span class=type>int</span> port);</span><br><span class=line>    ~<span class=built_in>Server</span>();</span><br><span class=line>    <span class=function><span class=type>void</span> <span class=title>Bind</span><span class=params>()</span></span>;</span><br><span class=line>    <span class=function><span class=type>void</span> <span class=title>Listen</span><span class=params>(<span class=type>int</span> queue_len = <span class=number>20</span>)</span></span>;</span><br><span class=line>    <span class=function><span class=type>void</span> <span class=title>Accept</span><span class=params>()</span></span>;</span><br><span class=line>    <span class=function><span class=type>void</span> <span class=title>Run</span><span class=params>()</span></span>;</span><br><span class=line>    <span class=function><span class=type>void</span> <span class=title>Recv</span><span class=params>(<span class=type>int</span> fd)</span></span>;</span><br><span class=line>&#125;;</span><br><span class=line></span><br><span class=line>Server::<span class=built_in>Server</span>(<span class=type>int</span> port)</span><br><span class=line>&#123;</span><br><span class=line>    <span class=built_in>bzero</span>(&amp;server_addr, <span class=built_in>sizeof</span>(server_addr));</span><br><span class=line>    server_addr.sin_family = AF_INET;</span><br><span class=line>    server_addr.sin_addr.s_addr = <span class=built_in>htons</span>(INADDR_ANY);</span><br><span class=line>    server_addr.sin_port = <span class=built_in>htons</span>(port);</span><br><span class=line>    <span class=comment>// create socket to listen</span></span><br><span class=line>    listen_fd = <span class=built_in>socket</span>(PF_INET, SOCK_STREAM, <span class=number>0</span>);</span><br><span class=line>    <span class=keyword>if</span> (listen_fd &lt; <span class=number>0</span>)</span><br><span class=line>    &#123;</span><br><span class=line>        cout &lt;&lt; <span class=string>&quot;Create Socket Failed!&quot;</span>;</span><br><span class=line>        <span class=built_in>exit</span>(<span class=number>1</span>);</span><br><span class=line>    &#125;</span><br><span class=line>    <span class=type>int</span> opt = <span class=number>1</span>;</span><br><span class=line>    <span class=built_in>setsockopt</span>(listen_fd, SOL_SOCKET, SO_REUSEADDR, &amp;opt, <span class=built_in>sizeof</span>(opt));</span><br><span class=line>&#125;</span><br><span class=line></span><br><span class=line>Server::~<span class=built_in>Server</span>()</span><br><span class=line>&#123;</span><br><span class=line>    <span class=built_in>close</span>(epfd);</span><br><span class=line>&#125;</span><br><span class=line></span><br><span class=line><span class=function><span class=type>void</span> <span class=title>Server::Bind</span><span class=params>()</span></span></span><br><span class=line><span class=function></span>&#123;</span><br><span class=line>    <span class=keyword>if</span> (<span class=number>-1</span> == (<span class=built_in>bind</span>(listen_fd, (<span class=keyword>struct</span> sockaddr *)&amp;server_addr, <span class=built_in>sizeof</span>(server_addr))))</span><br><span class=line>    &#123;</span><br><span class=line>        cout &lt;&lt; <span class=string>&quot;Server Bind Failed!&quot;</span>;</span><br><span class=line>        <span class=built_in>exit</span>(<span class=number>1</span>);</span><br><span class=line>    &#125;</span><br><span class=line>    cout &lt;&lt; <span class=string>&quot;Bind Successfully.\n&quot;</span>;</span><br><span class=line>&#125;</span><br><span class=line></span><br><span class=line><span class=function><span class=type>void</span> <span class=title>Server::Listen</span><span class=params>(<span class=type>int</span> queue_len)</span></span></span><br><span class=line><span class=function></span>&#123;</span><br><span class=line>    <span class=keyword>if</span> (<span class=number>-1</span> == <span class=built_in>listen</span>(listen_fd, queue_len))</span><br><span class=line>    &#123;</span><br><span class=line>        cout &lt;&lt; <span class=string>&quot;Server Listen Failed!&quot;</span>;</span><br><span class=line>        <span class=built_in>exit</span>(<span class=number>1</span>);</span><br><span class=line>    &#125;</span><br><span class=line>    cout &lt;&lt; <span class=string>&quot;Listen Successfully.\n&quot;</span>;</span><br><span class=line>&#125;</span><br><span class=line></span><br><span class=line><span class=function><span class=type>void</span> <span class=title>Server::Accept</span><span class=params>()</span></span></span><br><span class=line><span class=function></span>&#123;</span><br><span class=line>    <span class=keyword>struct</span> <span class="title class_">sockaddr_in</span> client_addr;</span><br><span class=line>    <span class=type>socklen_t</span> client_addr_len = <span class=built_in>sizeof</span>(client_addr);</span><br><span class=line></span><br><span class=line>    <span class=type>int</span> new_fd = <span class=built_in>accept</span>(listen_fd, (<span class=keyword>struct</span> sockaddr *)&amp;client_addr, &amp;client_addr_len);</span><br><span class=line>    <span class=keyword>if</span> (new_fd &lt; <span class=number>0</span>)</span><br><span class=line>    &#123;</span><br><span class=line>        cout &lt;&lt; <span class=string>&quot;Server Accept Failed!&quot;</span>;</span><br><span class=line>        <span class=built_in>exit</span>(<span class=number>1</span>);</span><br><span class=line>    &#125;</span><br><span class=line></span><br><span class=line>    cout &lt;&lt; <span class=string>&quot;new connection was accepted.\n&quot;</span>;</span><br><span class=line></span><br><span class=line>    <span class=comment>// 在epfd中注册新建立的连接</span></span><br><span class=line>    <span class=keyword>struct</span> <span class="title class_">epoll_event</span> event;</span><br><span class=line>    event.data.fd = new_fd;</span><br><span class=line>    event.events = EPOLLIN;</span><br><span class=line></span><br><span class=line>    <span class=built_in>epoll_ctl</span>(epfd, EPOLL_CTL_ADD, new_fd, &amp;event);</span><br><span class=line>&#125;</span><br><span class=line></span><br><span class=line><span class=function><span class=type>void</span> <span class=title>Server::Run</span><span class=params>()</span></span></span><br><span class=line><span class=function></span>&#123;</span><br><span class=line>    epfd = <span class=built_in>epoll_create</span>(<span class=number>1</span>); <span class=comment>// 创建epoll句柄</span></span><br><span class=line></span><br><span class=line>    <span class=keyword>struct</span> <span class="title class_">epoll_event</span> event;</span><br><span class=line>    event.data.fd = listen_fd;</span><br><span class=line>    event.events = EPOLLIN;</span><br><span class=line>    <span class=built_in>epoll_ctl</span>(epfd, EPOLL_CTL_ADD, listen_fd, &amp;event); <span class=comment>// 注册listen_fd</span></span><br><span class=line></span><br><span class=line>    <span class=keyword>while</span> (<span class=number>1</span>)</span><br><span class=line>    &#123;</span><br><span class=line>        <span class=type>int</span> nums = <span class=built_in>epoll_wait</span>(epfd, events, EPOLLSIZE, <span class=number>-1</span>);</span><br><span class=line>        <span class=keyword>if</span> (nums &lt; <span class=number>0</span>)</span><br><span class=line>        &#123;</span><br><span class=line>            cout &lt;&lt; <span class=string>&quot;poll() error!&quot;</span>;</span><br><span class=line>            <span class=built_in>exit</span>(<span class=number>1</span>);</span><br><span class=line>        &#125;</span><br><span class=line></span><br><span class=line>        <span class=keyword>if</span> (nums == <span class=number>0</span>)</span><br><span class=line>        &#123;</span><br><span class=line>            <span class=keyword>continue</span>;</span><br><span class=line>        &#125;</span><br><span class=line></span><br><span class=line>        <span class=keyword>for</span> (<span class=type>int</span> i = <span class=number>0</span>; i &lt; nums; ++i) <span class=comment>// 遍历所有就绪事件</span></span><br><span class=line>        &#123;</span><br><span class=line>            <span class=type>int</span> fd = events[i].data.fd;</span><br><span class=line>            <span class=keyword>if</span> ((fd == listen_fd) &amp;&amp; (events[i].events &amp; EPOLLIN))</span><br><span class=line>                <span class=built_in>Accept</span>(); <span class=comment>// 有新的客户端请求</span></span><br><span class=line>            <span class=keyword>else</span> <span class=keyword>if</span> (events[i].events &amp; EPOLLIN)</span><br><span class=line>                <span class=built_in>Recv</span>(fd); <span class=comment>// 读数据</span></span><br><span class=line>            <span class=keyword>else</span></span><br><span class=line>                ;</span><br><span class=line>        &#125;</span><br><span class=line>    &#125;</span><br><span class=line>&#125;</span><br><span class=line></span><br><span class=line><span class=function><span class=type>void</span> <span class=title>Server::Recv</span><span class=params>(<span class=type>int</span> fd)</span></span></span><br><span class=line><span class=function></span>&#123;</span><br><span class=line>    <span class=type>bool</span> close_conn = <span class=literal>false</span>; <span class=comment>// 标记当前连接是否断开了</span></span><br><span class=line></span><br><span class=line>    PACKET_HEAD head;</span><br><span class=line>    <span class=built_in>recv</span>(fd, &amp;head, <span class=built_in>sizeof</span>(head), <span class=number>0</span>); <span class=comment>// 先接受包头，即数据总长度</span></span><br><span class=line></span><br><span class=line>    <span class=type>char</span> *buffer = <span class=keyword>new</span> <span class=type>char</span>[head.length];</span><br><span class=line>    <span class=built_in>bzero</span>(buffer, head.length);</span><br><span class=line>    <span class=type>int</span> total = <span class=number>0</span>;</span><br><span class=line>    <span class=keyword>while</span> (total &lt; head.length)</span><br><span class=line>    &#123;</span><br><span class=line>        <span class=type>int</span> len = <span class=built_in>recv</span>(fd, buffer + total, head.length - total, <span class=number>0</span>);</span><br><span class=line>        <span class=keyword>if</span> (len &lt; <span class=number>0</span>)</span><br><span class=line>        &#123;</span><br><span class=line>            cout &lt;&lt; <span class=string>&quot;recv() error!&quot;</span>;</span><br><span class=line>            close_conn = <span class=literal>true</span>;</span><br><span class=line>            <span class=keyword>break</span>;</span><br><span class=line>        &#125;</span><br><span class=line>        total = total + len;</span><br><span class=line>    &#125;</span><br><span class=line></span><br><span class=line>    <span class=keyword>if</span> (total == head.length) <span class=comment>// 将收到的消息原样发回给客户端</span></span><br><span class=line>    &#123;</span><br><span class=line>        <span class=type>int</span> ret1 = <span class=built_in>send</span>(fd, &amp;head, <span class=built_in>sizeof</span>(head), <span class=number>0</span>);</span><br><span class=line>        <span class=type>int</span> ret2 = <span class=built_in>send</span>(fd, buffer, head.length, <span class=number>0</span>);</span><br><span class=line>        <span class=keyword>if</span> (ret1 &lt; <span class=number>0</span> || ret2 &lt; <span class=number>0</span>)</span><br><span class=line>        &#123;</span><br><span class=line>            cout &lt;&lt; <span class=string>&quot;send() error!&quot;</span>;</span><br><span class=line>            close_conn = <span class=literal>true</span>;</span><br><span class=line>        &#125;</span><br><span class=line>    &#125;</span><br><span class=line></span><br><span class=line>    <span class=keyword>delete</span> buffer;</span><br><span class=line></span><br><span class=line>    <span class=keyword>if</span> (close_conn) <span class=comment>// 当前这个连接有问题，关闭它</span></span><br><span class=line>    &#123;</span><br><span class=line>        <span class=built_in>close</span>(fd);</span><br><span class=line>        <span class=keyword>struct</span> <span class="title class_">epoll_event</span> event;</span><br><span class=line>        event.data.fd = fd;</span><br><span class=line>        event.events = EPOLLIN;</span><br><span class=line>        <span class=built_in>epoll_ctl</span>(epfd, EPOLL_CTL_DEL, fd, &amp;event); <span class=comment>// Delete一个fd</span></span><br><span class=line>    &#125;</span><br><span class=line>&#125;</span><br><span class=line></span><br><span class=line><span class=function><span class=type>int</span> <span class=title>main</span><span class=params>()</span></span></span><br><span class=line><span class=function></span>&#123;</span><br><span class=line>    <span class=function>Server <span class=title>server</span><span class=params>(<span class=number>15000</span>)</span></span>;</span><br><span class=line>    server.<span class=built_in>Bind</span>();</span><br><span class=line>    server.<span class=built_in>Listen</span>();</span><br><span class=line>    server.<span class=built_in>Run</span>();</span><br><span class=line>    <span class=keyword>return</span> <span class=number>0</span>;</span><br><span class=line>&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><p>每次调用poll&#x2F;select系统调用，操作系统都要把current（当前进程）挂到fd对应的所有设备的等待队列上，可以想象，fd多到上千的时候，这样“挂”法很费事；而每次调用epoll_wait则没有这么罗嗦，epoll只在epoll_ctl时把current挂一遍（这第一遍是免不了的）并给每个fd一个命令“好了就调回调函数”，如果设备有事件了，通过回调函数，会把fd放入rdllist，而每次调用epoll_wait就只是收集rdllist里的fd就可以了——epoll巧妙的利用回调函数，实现了更高效的事件驱动模型。</p><h3 id=epoll工作模式><a href=#epoll工作模式 class=headerlink title=epoll工作模式></a>epoll工作模式</h3><h4 id=LT模式><a href=#LT模式 class=headerlink title=LT模式></a>LT模式</h4><p>LT(level triggered)是缺省的工作方式，并且同时支持block和no-block socket。在这种做法中，内核告诉你一个文件描述符是否就绪了，然后你可以对这个就绪的fd进行IO操作。<strong>如果你不作任何操作，内核还是会继续通知你的</strong>，所以，这种模式编程出错误可能性要小一点。传统的select&#x2F;poll都是这种模型的代表。</p><h4 id=ET模式><a href=#ET模式 class=headerlink title=ET模式></a>ET模式</h4><p>ET (edge-triggered) 是高速工作方式，只支持no-block socket(非阻塞)。 在这种模式下，<strong>当描述符从未就绪变为就绪时，内核就通过epoll告诉你，然后它会假设你知道文件描述符已经就绪，并且不会再为那个文件描述符发送更多的 就绪通知</strong>，直到你做了某些操作而导致那个文件描述符不再是就绪状态(比如 你在发送，接收或是接受请求，或者发送接收的数据少于一定量时导致了一个EWOULDBLOCK 错误)。但是请注意，如果一直不对这个fd作IO操作(从而导致它再次变成未就绪)，内核就不会发送更多的通知(only once)。不过在TCP协议中，ET模式的加速效用仍需要更多的benchmark确认。</p><h2 id=Linux命令><a href=#Linux命令 class=headerlink title=Linux命令></a>Linux命令</h2><ul><li>ps -aux 查看进程，一般配合 ps -aux ｜ grep ；</li><li>tar -zvx 目标文件 解压；</li><li>tar -zcx</li></ul></div><div class=post-copyright><div class=post-copyright-icon></div><div class=post-copyright-author><span class=post-copyright-meta>文章作者: </span><span class=post-copyright-info><a href=mailto:me@imlete.cn>MengD(萌典)</a></span></div><div class=post-copyright-type><span class=post-copyright-meta>文章链接: </span><span class=post-copyright-info><a href=http://example.com/2022/04/23/面试八股文/ >http://example.com/2022/04/23/面试八股文/</a></span></div><div class=post-copyright-notice><span class=post-copyright-meta>版权声明: </span><span class=post-copyright-info>本博客所有文章除特别声明外，均采用 <a href=https://creativecommons.org/licenses/by-nc-sa/4.0/ target=_blank>CC BY-NC-SA 4.0 </a>许可协议。转载请注明来自 <a href=http://example.com/2022/04/23/面试八股文/ target=_blank>Hexo-Theme-MengD(萌典)</a> ！</span></div></div><div class=pagination-post><a href=/2022/04/24/hello-world/ ><div class=prev-title><i class="fas fa-chevron-left"></i>Hello World</div><div class=prev-desc>Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any ...</div></a></div><div class=comment-head id=直达评论><hr><div class=comment-headline><i class="fas fa-comments fa-fw"></i> <span>评论</span></div><div id=Discuss-Comments></div><script>function LoadDiscuss(){getScript("https://cdn.jsdelivr.net/npm/discuss@latest/dist/Discuss.js",function(){let s={el:"#Discuss-Comments",serverURLs:""};Discuss.init(s)})}LoadDiscuss()</script></div></article><div id=toc-wrap><div id=toc><div class=toc-title><div>目录 <span class=num>0%</span></div><progress class=progress value=0 max=100></progress></div><div class=toc-list><ol class=toc><li class="toc-item toc-level-2"><a class=toc-link href=#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1><span class=toc-text>面向对象</span></a><ol class=toc-child><li class="toc-item toc-level-3"><a class=toc-link href=#%E5%A4%9A%E6%80%81%E5%88%86%E7%B1%BB%E5%8F%8A%E5%AE%9E%E7%8E%B0><span class=toc-text>多态分类及实现</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E5%8A%A8%E6%80%81%E5%A4%9A%E6%80%81%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86><span class=toc-text>动态多态实现原理</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E5%88%86%E7%B1%BB%E5%8F%8A%E8%B0%83%E7%94%A8><span class=toc-text>构造函数的分类及调用</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E3%80%81%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E9%A1%BA%E5%BA%8F><span class=toc-text>构造函数、析构函数调用顺序</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E8%99%9A%E5%87%BD%E6%95%B0><span class=toc-text>构造函数为什么不能虚函数</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%E6%96%B9%E5%BC%8F><span class=toc-text>拷贝构造函数的参数传递方式</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E6%8B%B7%E8%B4%9D%E8%B5%8B%E5%80%BC%E5%92%8C%E7%A7%BB%E5%8A%A8%E8%B5%8B%E5%80%BC%EF%BC%9F><span class=toc-text>拷贝赋值和移动赋值？</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D><span class=toc-text>深拷贝与浅拷贝</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E8%99%9A%E6%9E%90%E6%9E%84><span class=toc-text>虚析构</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E8%99%9A%E5%87%BD%E6%95%B0%E3%80%81%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0><span class=toc-text>虚函数、纯虚函数</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E8%99%9A%E7%BB%A7%E6%89%BF%EF%BC%88%E8%8F%B1%E5%BD%A2%E7%BB%A7%E6%89%BF%EF%BC%89><span class=toc-text>虚继承（菱形继承）</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E8%99%9A%E7%BB%A7%E6%89%BF%E3%80%81%E8%99%9A%E5%87%BD%E6%95%B0%E5%AF%B9%E6%AF%94><span class=toc-text>虚继承、虚函数对比</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E5%93%AA%E4%BA%9B%E5%87%BD%E6%95%B0%E4%B8%8D%E8%83%BD%E8%A2%AB%E5%A3%B0%E6%98%8E%E4%B8%BA%E8%99%9A%E5%87%BD%E6%95%B0><span class=toc-text>哪些函数不能被声明为虚函数</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8%E9%87%8C%E5%AD%98%E6%94%BE%E7%9A%84%E5%86%85%E5%AE%B9%E6%98%AF%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%86%99%E8%BF%9B%E5%8E%BB%E7%9A%84><span class=toc-text>虚函数表里存放的内容是什么时候写进去的</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#override%E3%80%81final><span class=toc-text>override、final</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E9%87%8D%E5%86%99%E3%80%81%E9%87%8D%E8%BD%BD%E3%80%81%E9%9A%90%E8%97%8F><span class=toc-text>重写、重载、隐藏</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#struct-class-%E5%8C%BA%E5%88%AB><span class=toc-text>struct class 区别</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#this-%E6%8C%87%E9%92%88><span class=toc-text>this 指针</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#delete-this-%E5%90%88%E6%B3%95%E5%90%97%EF%BC%9F><span class=toc-text>delete this 合法吗？</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E5%A6%82%E4%BD%95%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AA%E5%8F%AA%E8%83%BD%E5%9C%A8%E5%A0%86%E4%B8%8A%EF%BC%88%E6%A0%88%E4%B8%8A%EF%BC%89%E7%94%9F%E6%88%90%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%B1%BB%EF%BC%9F><span class=toc-text>如何定义一个只能在堆上（栈上）生成对象的类？</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#nullptr%E8%B0%83%E7%94%A8%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E5%8F%AF%E4%BB%A5%E5%90%97%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F><span class=toc-text>nullptr调用成员函数可以吗？为什么？</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#friend-%E5%8F%8B%E5%85%83%E7%B1%BB%E5%92%8C%E5%8F%8B%E5%85%83%E5%87%BD%E6%95%B0><span class=toc-text>friend 友元类和友元函数</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E6%88%90%E5%91%98%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8><span class=toc-text>成员初始化列表</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#initializer-list-%E5%88%97%E8%A1%A8%E5%88%9D%E5%A7%8B%E5%8C%96%EF%BC%88c-11%EF%BC%89><span class=toc-text>initializer_list 列表初始化（c++11）</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-1><span class=toc-text>面向对象</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E5%B0%81%E8%A3%85><span class=toc-text>封装</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E6%8A%BD%E8%B1%A1%E7%B1%BB%E3%80%81%E6%8E%A5%E5%8F%A3%E7%B1%BB%E3%80%81%E8%81%9A%E5%90%88%E7%B1%BB><span class=toc-text>抽象类、接口类、聚合类</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E4%BB%BF%E5%87%BD%E6%95%B0-%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1><span class=toc-text>仿函数(函数对象)</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E7%B1%BB%E6%A8%A1%E6%9D%BF%E5%92%8C%E6%A8%A1%E6%9D%BF%E7%B1%BB%E7%9A%84%E5%8C%BA%E5%88%AB><span class=toc-text>类模板和模板类的区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class=toc-link href=#%E5%86%85%E5%AD%98%E7%9B%B8%E5%85%B3><span class=toc-text>内存相关</span></a><ol class=toc-child><li class="toc-item toc-level-3"><a class=toc-link href=#%E7%A8%8B%E5%BA%8Fsection><span class=toc-text>程序section</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E5%86%85%E5%AD%98%E5%88%86%E5%8C%BA><span class=toc-text>内存分区</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E6%A0%88%E5%92%8C%E5%A0%86><span class=toc-text>栈和堆</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%92%8C%E7%AE%A1%E7%90%86><span class=toc-text>内存分配和管理</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2><span class=toc-text>内存泄露</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#C-%E4%B8%AD%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF><span class=toc-text>C++中内存对齐的使用场景</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E5%A4%A7%E7%AB%AF%E5%B0%8F%E7%AB%AF><span class=toc-text>大端小端</span></a></li></ol></li><li class="toc-item toc-level-2"><a class=toc-link href=#%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95><span class=toc-text>基础语法</span></a><ol class=toc-child><li class="toc-item toc-level-3"><a class=toc-link href=#%E5%8F%8C%E5%BC%95%E5%8F%B7%E2%80%9D%E2%80%9D%E5%92%8C%E5%B0%96%E6%8B%AC%E5%8F%B7-lt-gt-%E7%9A%84%E5%8C%BA%E5%88%AB><span class=toc-text>双引号””和尖括号&lt;&gt;的区别</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E6%95%B0%E7%BB%84%E5%90%8D%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%95%B0%E7%BB%84><span class=toc-text>数组名和字符串数组</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E5%8C%BA%E5%88%AB%E4%BB%A5%E4%B8%8B%E6%8C%87%E9%92%88%E7%B1%BB%E5%9E%8B><span class=toc-text>区别以下指针类型</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#const><span class=toc-text>const</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#const%E5%92%8Cdefine><span class=toc-text>const和define</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#static%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%BD%9C%E7%94%A8><span class=toc-text>static关键字的作用</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E9%87%8E%E6%8C%87%E9%92%88%EF%BC%8C%E6%82%AC%E7%A9%BA%E6%8C%87%E9%92%88><span class=toc-text>野指针，悬空指针</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#volatile><span class=toc-text>volatile</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#assert><span class=toc-text>assert()</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#explicit><span class=toc-text>explicit</span></a></li><li class="toc-item toc-level-3"><a class=toc-link><span class=toc-text></span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#pragma-pack-n><span class=toc-text>#pragma pack(n)</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E4%BD%8D%E5%9F%9F><span class=toc-text>位域</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#union-%E8%81%94%E5%90%88><span class=toc-text>union 联合</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#enum-%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B><span class=toc-text>enum 枚举类型</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#decltype><span class=toc-text>decltype</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88><span class=toc-text>智能指针</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#C-%E7%9A%84%E5%9B%9B%E7%A7%8D%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2><span class=toc-text>C++的四种强制转换</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E8%BF%90%E8%A1%8C%E6%97%B6%E7%B1%BB%E5%9E%8B%E4%BF%A1%E6%81%AF-RTTI><span class=toc-text>运行时类型信息 (RTTI)</span></a><ol class=toc-child><li class="toc-item toc-level-4"><a class=toc-link href=#-1><span class=toc-text></span></a></li></ol></li><li class="toc-item toc-level-3"><a class=toc-link href=#-2><span class=toc-text></span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#size-%E3%80%81length-%E3%80%81strlen-%E3%80%81sizeof><span class=toc-text>size()、length()、strlen()、sizeof()</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#malloc%E3%80%81free><span class=toc-text>malloc、free</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#new%E3%80%81delete><span class=toc-text>new、delete</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#new%E5%92%8Cmalloc%EF%BC%8Cdelete%E5%92%8Cfree%E7%9A%84%E5%8C%BA%E5%88%AB><span class=toc-text>new和malloc，delete和free的区别</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E5%BA%93%E5%87%BD%E6%95%B0%E3%80%81%E8%BF%90%E7%AE%97%E7%AC%A6%E3%80%81%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8><span class=toc-text>库函数、运算符、系统调用</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E%E3%80%81%E5%AE%9A%E4%B9%89><span class=toc-text>变量声明、定义</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#C-%E5%92%8CC%E7%9A%84struct%E5%8C%BA%E5%88%AB><span class=toc-text>C++和C的struct区别</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E5%AE%9A%E4%BD%8D-new><span class=toc-text>定位 new</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%E5%92%8C%E6%8C%87%E9%92%88%E5%87%BD%E6%95%B0><span class=toc-text>函数指针和指针函数</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E5%BC%95%E7%94%A8><span class=toc-text>引用</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#using%E5%A3%B0%E6%98%8E%E5%92%8C%E6%8C%87%E7%A4%BA><span class=toc-text>using声明和指示</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E8%8C%83%E5%9B%B4%E8%A7%A3%E6%9E%90%E8%BF%90%E7%AE%97%E7%AC%A6><span class=toc-text>:: 范围解析运算符</span></a><ol class=toc-child><li class="toc-item toc-level-4"><a class=toc-link href=#-3><span class=toc-text></span></a></li></ol></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E5%9B%9B%E7%B1%BBcast%E8%BD%AC%E6%8D%A2><span class=toc-text>四类cast转换</span></a></li></ol></li><li class="toc-item toc-level-2"><a class=toc-link href=#%E5%87%BD%E6%95%B0%E7%9B%B8%E5%85%B3><span class=toc-text>函数相关</span></a><ol class=toc-child><li class="toc-item toc-level-3"><a class=toc-link href=#%E4%BC%A0%E5%80%BC%E6%96%B9%E5%BC%8F%EF%BC%88%E5%BC%95%E7%94%A8%EF%BC%8C%E6%8C%87%E9%92%88%EF%BC%89><span class=toc-text>传值方式（引用，指针）</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0%E5%92%8C%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB><span class=toc-text>内联函数和函数的区别</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#C-%E4%BC%A0%E5%80%BC%E6%96%B9%E5%BC%8F%EF%BC%8C%E5%8C%BA%E5%88%AB><span class=toc-text>C++传值方式，区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class=toc-link href=#C-x2F-C><span class=toc-text>C&#x2F;C++</span></a><ol class=toc-child><li class="toc-item toc-level-3"><a class=toc-link href=#%E5%AF%BC%E5%85%A5C%E5%87%BD%E6%95%B0%E5%85%B3%E9%94%AE%E5%AD%97><span class=toc-text>导入C函数关键字</span></a><ol class=toc-child><li class="toc-item toc-level-4"><a class=toc-link href=#-4><span class=toc-text></span></a></li></ol></li><li class="toc-item toc-level-3"><a class=toc-link href=#C-x2F-C-struct%E5%8C%BA%E5%88%AB><span class=toc-text>C&#x2F;C++ struct区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class=toc-link href=#%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B><span class=toc-text>程序执行过程</span></a><ol class=toc-child><li class="toc-item toc-level-3"><a class=toc-link href=#main%E6%89%A7%E8%A1%8C%E4%B9%8B%E5%89%8D%E5%92%8C%E4%B9%8B%E5%90%8E><span class=toc-text>main执行之前和之后</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#C-%E4%BB%A3%E7%A0%81%E5%88%B0%E5%8F%AF%E6%89%A7%E8%A1%8C%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6%E7%9A%84%E8%BF%87%E7%A8%8B><span class=toc-text>C++代码到可执行二进制文件的过程</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%E5%88%9D%E5%A7%8B%E5%8C%96><span class=toc-text>静态变量初始化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class=toc-link href=#STL><span class=toc-text>STL</span></a><ol class=toc-child><li class="toc-item toc-level-3"><a class=toc-link href=#%E4%BB%80%E4%B9%88%E6%98%AFSTL%EF%BC%9F><span class=toc-text>什么是STL？</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#STL-%E7%B4%A2%E5%BC%95><span class=toc-text>STL 索引</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#STL-%E5%AE%B9%E5%99%A8><span class=toc-text>STL 容器</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#STL-%E7%AE%97%E6%B3%95><span class=toc-text>STL 算法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class=toc-link href=#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8F%8A%E5%85%B6%E7%AE%97%E6%B3%95><span class=toc-text>数据结构及其算法</span></a><ol class=toc-child><li class="toc-item toc-level-3"><a class=toc-link href=#%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%EF%BC%88%E6%AF%8F%E6%AC%A1%E9%80%89%E5%8F%96%E6%9C%80%E5%A4%A7%E7%9A%84%E5%85%83%E7%B4%A0%EF%BC%89><span class=toc-text>选择排序（每次选取最大的元素）</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F><span class=toc-text>插入排序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class=toc-link href=#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%85%B3><span class=toc-text>操作系统相关</span></a><ol class=toc-child><li class="toc-item toc-level-3"><a class=toc-link href=#%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%8D%8F%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E8%81%94%E7%B3%BB><span class=toc-text>进程、线程和协程的区别和联系</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E4%B8%80%E4%B8%AA%E8%BF%9B%E7%A8%8B%E5%8F%AF%E4%BB%A5%E5%88%9B%E5%BB%BA%E5%A4%9A%E5%B0%91%E7%BA%BF%E7%A8%8B%EF%BC%8C%E5%92%8C%E4%BB%80%E4%B9%88%E6%9C%89%E5%85%B3><span class=toc-text>一个进程可以创建多少线程，和什么有关</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E5%A4%96%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F><span class=toc-text>外中断和异常有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F><span class=toc-text>进程间通信方式</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F><span class=toc-text>线程之间的通信方式</span></a><ol class=toc-child><li class="toc-item toc-level-4"><a class=toc-link href=#%E8%BF%9B%E7%A8%8B%E4%B9%8B%E9%97%B4%E7%A7%81%E6%9C%89%E5%92%8C%E5%85%B1%E4%BA%AB%E7%9A%84%E8%B5%84%E6%BA%90><span class=toc-text>进程之间私有和共享的资源</span></a></li><li class="toc-item toc-level-4"><a class=toc-link href=#%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E7%A7%81%E6%9C%89%E5%92%8C%E5%85%B1%E4%BA%AB%E7%9A%84%E8%B5%84%E6%BA%90><span class=toc-text>线程之间私有和共享的资源</span></a></li></ol></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E5%B1%80%E9%83%A8%E6%80%A7%E5%8E%9F%E7%90%86%E4%BD%A0%E7%9F%A5%E9%81%93%E5%90%97%EF%BC%9F%E4%B8%BB%E8%A6%81%E6%9C%89%E5%93%AA%E4%B8%A4%E5%A4%A7%E5%B1%80%E9%83%A8%E6%80%A7%E5%8E%9F%E7%90%86%EF%BC%9F%E5%90%84%E8%87%AA%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F><span class=toc-text>局部性原理你知道吗？主要有哪两大局部性原理？各自是什么？</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B%E5%87%A0%E7%A7%8D%E5%85%B8%E5%9E%8B%E7%9A%84%E9%94%81%EF%BC%9F><span class=toc-text>介绍一下几种典型的锁？</span></a><ol class=toc-child><li class="toc-item toc-level-5"><a class=toc-link href=#%E8%AF%BB%E5%86%99%E9%94%81><span class=toc-text>读写锁</span></a></li><li class="toc-item toc-level-5"><a class=toc-link href=#%E4%BA%92%E6%96%A5%E9%94%81><span class=toc-text>互斥锁</span></a></li><li class="toc-item toc-level-5"><a class=toc-link href=#%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F><span class=toc-text>条件变量</span></a></li><li class="toc-item toc-level-5"><a class=toc-link href=#%E8%87%AA%E6%97%8B%E9%94%81><span class=toc-text>自旋锁</span></a></li></ol></li></ol></li></ol><li class="toc-item toc-level-2"><a class=toc-link href=#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C><span class=toc-text>计算机网络</span></a><ol class=toc-child><li class="toc-item toc-level-4"><a class=toc-link href=#OSI-%E7%9A%84%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B%E5%88%86%E5%88%AB%E6%98%AF%EF%BC%9F%E5%90%84%E8%87%AA%E7%9A%84%E5%8A%9F%E8%83%BD%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F><span class=toc-text>OSI 的七层模型分别是？各自的功能是什么？</span></a><ol class=toc-child><li class="toc-item toc-level-5"><a class=toc-link href=#%E7%AE%80%E8%A6%81%E6%A6%82%E6%8B%AC><span class=toc-text>简要概括</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class=toc-link href=#TCP><span class=toc-text>TCP</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#UDP><span class=toc-text>UDP</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#TCP-%E4%B8%8E-UDP-%E7%9A%84%E5%8C%BA%E5%88%AB><span class=toc-text>TCP 与 UDP 的区别</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#TCP-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6><span class=toc-text>TCP 拥塞控制</span></a><ol class=toc-child><li class="toc-item toc-level-5"><a class=toc-link href=#%E6%A6%82%E5%BF%B5><span class=toc-text>概念</span></a></li><li class="toc-item toc-level-5"><a class=toc-link href=#%E6%96%B9%E6%B3%95><span class=toc-text>方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class=toc-link href=#TCP-%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5%E5%85%A8%E8%BF%87%E7%A8%8B%E8%A7%A3%E9%87%8A><span class=toc-text>TCP 建立连接全过程解释</span></a><ol class=toc-child><li class="toc-item toc-level-5"><a class=toc-link href=#TCP-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%BF%9B%E8%A1%8C%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%EF%BC%9F><span class=toc-text>TCP 为什么要进行三次握手？</span></a></li></ol></li><li class="toc-item toc-level-4"><a class=toc-link href=#TCP-%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E9%87%8A%E6%94%BE%E8%BF%9E%E6%8E%A5><span class=toc-text>TCP 四次挥手释放连接</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#TCP-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%BF%9B%E8%A1%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%EF%BC%9F><span class=toc-text>TCP 为什么要进行四次挥手？</span></a><ol class=toc-child><li class="toc-item toc-level-4"><a class=toc-link href=#HTTPS%E5%92%8CHTTP%E7%9A%84%E5%8C%BA%E5%88%AB><span class=toc-text>HTTPS和HTTP的区别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class=toc-link href=#select%E3%80%81poll%E3%80%81epoll><span class=toc-text>select、poll、epoll</span></a></li><li class="toc-item toc-level-2"><a class=toc-link href=#%E5%90%8C%E6%AD%A5%E5%BC%82%E6%AD%A5%E4%B8%8E%E9%98%BB%E5%A1%9E%E9%9D%9E%E9%98%BB%E5%A1%9E><span class=toc-text>同步异步与阻塞非阻塞</span></a><ol class=toc-child><li class="toc-item toc-level-3"><a class=toc-link href=#%E7%94%A8%E6%88%B7%E7%A9%BA%E9%97%B4%E5%92%8C%E5%86%85%E6%A0%B8%E7%A9%BA%E9%97%B4><span class=toc-text>用户空间和内核空间</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E8%BF%9B%E7%A8%8B%E5%88%87%E6%8D%A2><span class=toc-text>进程切换</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E8%BF%9B%E7%A8%8B%E9%98%BB%E5%A1%9E><span class=toc-text>进程阻塞</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6><span class=toc-text>文件描述符</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E5%90%8C%E6%AD%A5><span class=toc-text>同步</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E5%BC%82%E6%AD%A5><span class=toc-text>异步</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E9%98%BB%E5%A1%9E><span class=toc-text>阻塞</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E9%9D%9E%E9%98%BB%E5%A1%9E><span class=toc-text>非阻塞</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8><span class=toc-text>多路复用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class=toc-link href=#Select><span class=toc-text>Select</span></a><ol class=toc-child><li class="toc-item toc-level-3"><a class=toc-link href=#%E6%B5%81%E7%A8%8B><span class=toc-text>流程</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#Slect-API><span class=toc-text>Slect API</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#Select%E4%BE%8B%E5%AD%90><span class=toc-text>Select例子</span></a></li></ol></li><li class="toc-item toc-level-2"><a class=toc-link href=#Poll><span class=toc-text>Poll</span></a><ol class=toc-child><li class="toc-item toc-level-3"><a class=toc-link href=#Poll%E4%BE%8B%E5%AD%90><span class=toc-text>Poll例子</span></a></li></ol></li><li class="toc-item toc-level-2"><a class=toc-link href=#Epoll><span class=toc-text>Epoll</span></a><ol class=toc-child><li class="toc-item toc-level-3"><a class=toc-link href=#%E4%BD%BF%E7%94%A8%E5%9C%BA%E5%90%88%EF%BC%9A><span class=toc-text>使用场合：</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#Epoll%E5%8E%9F%E7%90%86><span class=toc-text>Epoll原理</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#epoll%E4%BE%8B%E5%AD%90><span class=toc-text>epoll例子</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#epoll%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F><span class=toc-text>epoll工作模式</span></a><ol class=toc-child><li class="toc-item toc-level-4"><a class=toc-link href=#LT%E6%A8%A1%E5%BC%8F><span class=toc-text>LT模式</span></a></li><li class="toc-item toc-level-4"><a class=toc-link href=#ET%E6%A8%A1%E5%BC%8F><span class=toc-text>ET模式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class=toc-link href=#Linux%E5%91%BD%E4%BB%A4><span class=toc-text>Linux命令</span></a></li></div></div></div></main><section id=rightside><div class=rightside-item><a id=open-toc title=目录><i class="fas fa-list-ul"></i> </a><a href=javascript:void(0); id=darkmode title="深色/浅色 "><i class="fas fa-moon"></i> </a><a href=#直达评论 title=直达评论><i class="fas fa-comments"></i> </a><a href=# title=回到顶部><i class="fas fa-arrow-up"></i></a></div></section><footer class=footer id=footer><div class=copyright>&copy; 2020 - 2022 <i class="fas fa-fan"></i> 森森</div><div class=framework-info><span>框架</span> <a href=https://hexo.io target=_blank>Hexo</a> <span class=footer-separator>|</span> <span>主题 </span><a href=https://github.com/lete114/hexo-theme-MengD target=_blank>MengD.(萌典)</a></div><div class=custom-text>我相信我可以，但我一直在路上，所以我有无限的可能！！</div></footer></div><div id=mask onclick=closeAll()></div><div class=script><script src=/js/main.js></script><script>var titleTime,originTitle=document.title;document.addEventListener("visibilitychange",function(){document.hidden?(document.title="(つェ⊂) 我藏好了哦~ "+originTitle,clearTimeout(titleTime)):(document.title="(*´∇｀*) 被你发现啦~ "+originTitle,titleTime=setTimeout(function(){document.title=originTitle},2e3))})</script><script>function LoadPjax(){window.pjax=new Pjax({selectors:["head title",'head meta[name="keywords"]','head meta[name="description"]',"main","#rightside"],cacheBust:!1})}getScript("https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js",LoadPjax);var timer=null;function ProgressStart(){var e="pjax-progress",t=$query("."+e),r=10;t||((t=document.createElement("div")).className=e,document.body.prepend(t));clearInterval(timer),timer=setInterval(function(){var e=parseInt(7*Math.random());95<(r+=e+3)&&(r=95),t.style.width=r+"%"},500)}function ProgressFinish(){clearInterval(timer);var e=$query(".pjax-progress");e.style.width="100%",timer=setTimeout(function(){e.parentNode.removeChild(e)},700)}document.addEventListener("pjax:send",function(){ProgressStart()}),document.addEventListener("pjax:complete",function(){ProgressFinish(),exeAllFn(),document.querySelectorAll("script[data-pjax]").forEach(e=>{const t=document.createElement("script");var r=e.text||e.textContent||e.innerHTML||"";Array.from(e.attributes).forEach(e=>t.setAttribute(e.name,e.value)),t.appendChild(document.createTextNode(r)),e.parentNode.replaceChild(t,e)})}),document.addEventListener("pjax:error",e=>{404===e.request.status&&pjax.loadUrl("/404.html")})</script></div></body></html>